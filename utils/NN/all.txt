all.h:// MUZE/all.h
all.h:
all.h:#ifndef MUZE_ALL_H
all.h:#define MUZE_ALL_H
all.h:
all.h:#include "ewc.h"
all.h:#include "growth.h"
all.h:#include "mcts.h"
all.h:#include "muzero_model.h"
all.h:#include "replay_buffer.h"
all.h:#include "runtime.h"
all.h:#include "selfplay.h"
all.h:#include "toy_env.h"
all.h:#include "trainer.h"
all.h:#include "util.h"
all.h:
all.h:#endif // MUZE_ALL_H
growth.c:#include "growth.h"
growth.c:#include <stdio.h>
growth.c:#include <stdlib.h>
growth.c:#include <string.h>
growth.c:
growth.c:/* Small random init for new weights */
growth.c:static float small_rand() {
growth.c:  return ((float)rand() / (float)RAND_MAX) * 0.002f - 0.001f;
growth.c:}
growth.c:
growth.c:int mu_model_grow_latent(MuModel *m, int new_L) {
growth.c:  int old_L = m->cfg.latent_dim;
growth.c:  int O = m->cfg.obs_dim;
growth.c:  int A = m->cfg.action_count;
growth.c:
growth.c:  if (new_L <= old_L)
growth.c:    return -1;
growth.c:
growth.c:  /* Representation weights */
growth.c:  float *new_repr = malloc(sizeof(float) * new_L * O);
growth.c:  for (int i = 0; i < new_L; i++) {
growth.c:    for (int j = 0; j < O; j++) {
growth.c:      new_repr[i * O + j] = (i < old_L) ? m->repr_W[i * O + j] : small_rand();
growth.c:    }
growth.c:  }
growth.c:
growth.c:  /* Dynamics weights */
growth.c:  float *new_dyn = malloc(sizeof(float) * new_L * new_L);
growth.c:  for (int i = 0; i < new_L; i++) {
growth.c:    for (int j = 0; j < new_L; j++) {
growth.c:      new_dyn[i * new_L + j] =
growth.c:          (i < old_L && j < old_L) ? m->dyn_W[i * old_L + j] : small_rand();
growth.c:    }
growth.c:  }
growth.c:
growth.c:  /* Prediction weights */
growth.c:  float *new_pred = malloc(sizeof(float) * (A + 1) * new_L);
growth.c:  for (int a = 0; a < A + 1; a++) {
growth.c:    for (int j = 0; j < new_L; j++) {
growth.c:      new_pred[a * new_L + j] =
growth.c:          (j < old_L) ? m->pred_W[a * old_L + j] : small_rand();
growth.c:    }
growth.c:  }
growth.c:
growth.c:  free(m->repr_W);
growth.c:  free(m->dyn_W);
growth.c:  free(m->pred_W);
growth.c:
growth.c:  m->repr_W = new_repr;
growth.c:  m->dyn_W = new_dyn;
growth.c:  m->pred_W = new_pred;
growth.c:
growth.c:  m->repr_W_count = new_L * O;
growth.c:  m->dyn_W_count = new_L * new_L;
growth.c:  m->pred_W_count = (A + 1) * new_L;
growth.c:
growth.c:  m->cfg.latent_dim = new_L;
growth.c:
growth.c:  return 0;
growth.c:}
growth.h:#ifndef GROWTH_H
growth.h:#define GROWTH_H
growth.h:
growth.h:#include "muzero_model.h"
growth.h:
growth.h:int mu_model_grow_latent(MuModel *m, int new_latent_dim);
growth.h:
growth.h:#endif
mcts.c:#include "mcts.h"
mcts.c:#include <float.h>
mcts.c:#include <math.h>
mcts.c:#include <stdio.h>
mcts.c:#include <stdlib.h>
mcts.c:#include <string.h>
mcts.c:
mcts.c:/* Node structure */
mcts.c:typedef struct Node {
mcts.c:  float *W; /* sum of values per action */
mcts.c:  float *Q; /* mean value per action */
mcts.c:  int *N;   /* visit counts */
mcts.c:  float *P; /* prior probs */
mcts.c:  struct Node **children;
mcts.c:  float *latent; /* latent state stored at node */
mcts.c:  int action_count;
mcts.c:  int expanded;
mcts.c:} Node;
mcts.c:
mcts.c:/* allocate node */
mcts.c:static Node *node_create(int action_count, int latent_dim) {
mcts.c:  Node *n = (Node *)calloc(1, sizeof(Node));
mcts.c:  if (!n)
mcts.c:    return NULL;
mcts.c:  n->action_count = action_count;
mcts.c:  n->W = (float *)calloc(action_count, sizeof(float));
mcts.c:  n->Q = (float *)calloc(action_count, sizeof(float));
mcts.c:  n->N = (int *)calloc(action_count, sizeof(int));
mcts.c:  n->P = (float *)calloc(action_count, sizeof(float));
mcts.c:  n->children = (Node **)calloc(action_count, sizeof(Node *));
mcts.c:  n->latent = (float *)calloc(latent_dim, sizeof(float));
mcts.c:  n->expanded = 0;
mcts.c:  return n;
mcts.c:}
mcts.c:
mcts.c:/* free node recursively */
mcts.c:static void node_free(Node *n) {
mcts.c:  if (!n)
mcts.c:    return;
mcts.c:  free(n->W);
mcts.c:  free(n->Q);
mcts.c:  free(n->N);
mcts.c:  free(n->P);
mcts.c:  free(n->latent);
mcts.c:  if (n->children) {
mcts.c:    for (int i = 0; i < n->action_count; i++)
mcts.c:      node_free(n->children[i]);
mcts.c:    free(n->children);
mcts.c:  }
mcts.c:  free(n);
mcts.c:}
mcts.c:
mcts.c:/* sum of visits */
mcts.c:static int node_Nsum(Node *n) {
mcts.c:  int sum = 0;
mcts.c:  for (int i = 0; i < n->action_count; i++)
mcts.c:    sum += n->N[i];
mcts.c:  return sum;
mcts.c:}
mcts.c:
mcts.c:/* simple softmax */
mcts.c:static void softmax(const float *logits, int len, float *out) {
mcts.c:  float maxv = -INFINITY;
mcts.c:  for (int i = 0; i < len; i++)
mcts.c:    if (logits[i] > maxv)
mcts.c:      maxv = logits[i];
mcts.c:  float sum = 0.0f;
mcts.c:  for (int i = 0; i < len; i++) {
mcts.c:    out[i] = expf(logits[i] - maxv);
mcts.c:    sum += out[i];
mcts.c:  }
mcts.c:  if (sum > 0.0f) {
mcts.c:    for (int i = 0; i < len; i++)
mcts.c:      out[i] /= sum;
mcts.c:  } else {
mcts.c:    for (int i = 0; i < len; i++)
mcts.c:      out[i] = 1.0f / (float)len;
mcts.c:  }
mcts.c:}
mcts.c:
mcts.c:/* PUCT selection */
mcts.c:static int select_puct(Node *n, float c_puct) {
mcts.c:  int best = 0;
mcts.c:  float best_score = -FLT_MAX;
mcts.c:  float sqrt_N = sqrtf((float)(node_Nsum(n) + 1));
mcts.c:  for (int a = 0; a < n->action_count; a++) {
mcts.c:    float score = n->Q[a] + c_puct * n->P[a] * (sqrt_N / (1.0f + n->N[a]));
mcts.c:    if (score > best_score) {
mcts.c:      best_score = score;
mcts.c:      best = a;
mcts.c:    }
mcts.c:  }
mcts.c:  return best;
mcts.c:}
mcts.c:
mcts.c:/* Add Dirichlet noise to root priors */
mcts.c:static void add_dirichlet_noise(Node *root, float alpha, float eps) {
mcts.c:  if (!root || alpha <= 0.0f || eps <= 0.0f)
mcts.c:    return;
mcts.c:  int A = root->action_count;
mcts.c:  float *g = (float *)malloc(sizeof(float) * A);
mcts.c:  float sum = 0.0f;
mcts.c:  for (int i = 0; i < A; i++) {
mcts.c:    float u = (rand() + 1.0f) / (RAND_MAX + 1.0f);
mcts.c:    g[i] = -logf(u);
mcts.c:    sum += g[i];
mcts.c:  }
mcts.c:  if (sum <= 0.0f)
mcts.c:    sum = 1.0f;
mcts.c:  for (int i = 0; i < A; i++) {
mcts.c:    float d = g[i] / sum;
mcts.c:    root->P[i] = (1.0f - eps) * root->P[i] + eps * d;
mcts.c:  }
mcts.c:  free(g);
mcts.c:}
mcts.c:
mcts.c:/* Expand node: fill priors and return predicted value */
mcts.c:static float expand_node(Node *node, MuModel *model) {
mcts.c:  int A = node->action_count;
mcts.c:  float *logits = (float *)malloc(sizeof(float) * A);
mcts.c:  float value = 0.0f;
mcts.c:  mu_model_predict(model, node->latent, logits, &value);
mcts.c:
mcts.c:  float *pri = (float *)malloc(sizeof(float) * A);
mcts.c:  softmax(logits, A, pri);
mcts.c:  memcpy(node->P, pri, sizeof(float) * A);
mcts.c:  node->expanded = 1;
mcts.c:
mcts.c:  free(pri);
mcts.c:  free(logits);
mcts.c:  return value;
mcts.c:}
mcts.c:
mcts.c:/* Backup rewards + leaf value with discount */
mcts.c:static void backup_with_discount(Node *root, int *actions, float *rewards,
mcts.c:                                 int depth, float leaf_value, float gamma) {
mcts.c:  float total = leaf_value;
mcts.c:  for (int i = depth - 1; i >= 0; i--) {
mcts.c:    total = rewards[i] + gamma * total;
mcts.c:  }
mcts.c:
mcts.c:  Node *n = root;
mcts.c:  for (int i = 0; i < depth; i++) {
mcts.c:    int a = actions[i];
mcts.c:    n->W[a] += total;
mcts.c:    n->N[a] += 1;
mcts.c:    n->Q[a] = n->W[a] / (float)n->N[a];
mcts.c:    if (!n->children[a])
mcts.c:      break;
mcts.c:    n = n->children[a];
mcts.c:  }
mcts.c:}
mcts.c:
mcts.c:/* convert visit counts to policy */
mcts.c:static void visits_to_pi(Node *root, float temperature, float *pi_out) {
mcts.c:  int A = root->action_count;
mcts.c:  if (temperature <= 0.0f)
mcts.c:    temperature = 1e-6f;
mcts.c:  double sum = 0.0;
mcts.c:  for (int a = 0; a < A; a++) {
mcts.c:    double val = pow((double)root->N[a], 1.0 / (double)temperature);
mcts.c:    if (!isfinite(val))
mcts.c:      val = 0.0;
mcts.c:    pi_out[a] = (float)val;
mcts.c:    sum += val;
mcts.c:  }
mcts.c:  if (sum > 0.0) {
mcts.c:    for (int a = 0; a < A; a++)
mcts.c:      pi_out[a] /= (float)sum;
mcts.c:  } else {
mcts.c:    for (int a = 0; a < A; a++)
mcts.c:      pi_out[a] = 1.0f / (float)A;
mcts.c:  }
mcts.c:}
mcts.c:
mcts.c:MCTSResult mcts_run_latent(MuModel *model, const float *latent,
mcts.c:                           const MCTSParams *params) {
mcts.c:  MCTSResult res = {0};
mcts.c:  if (!model || !latent || !params)
mcts.c:    return res;
mcts.c:
mcts.c:  int A = model->cfg.action_count;
mcts.c:  int L = model->cfg.latent_dim;
mcts.c:
mcts.c:  Node *root = node_create(A, L);
mcts.c:  if (!root)
mcts.c:    return res;
mcts.c:
mcts.c:  /* Copy latent directly */
mcts.c:  memcpy(root->latent, latent, sizeof(float) * L);
mcts.c:
mcts.c:  float root_value = expand_node(root, model);
mcts.c:
mcts.c:  if (params->dirichlet_alpha > 0.0f && params->dirichlet_eps > 0.0f)
mcts.c:    add_dirichlet_noise(root, params->dirichlet_alpha, params->dirichlet_eps);
mcts.c:
mcts.c:  int max_depth = params->max_depth > 0 ? params->max_depth : 64;
mcts.c:  int *actions = malloc(sizeof(int) * max_depth);
mcts.c:  float *rewards = malloc(sizeof(float) * max_depth);
mcts.c:
mcts.c:  for (int sim = 0; sim < params->num_simulations; sim++) {
mcts.c:    Node *node = root;
mcts.c:    int depth = 0;
mcts.c:
mcts.c:    float *h_cur = malloc(sizeof(float) * L);
mcts.c:    memcpy(h_cur, root->latent, sizeof(float) * L);
mcts.c:
mcts.c:    while (node->expanded && depth < max_depth) {
mcts.c:      int a = select_puct(node, params->c_puct);
mcts.c:      actions[depth] = a;
mcts.c:
mcts.c:      if (!node->children[a]) {
mcts.c:        node->children[a] = node_create(A, L);
mcts.c:        float r = 0.0f;
mcts.c:        mu_model_dynamics(model, h_cur, a, node->children[a]->latent, &r);
mcts.c:        rewards[depth] = r;
mcts.c:
mcts.c:        float leaf_value = expand_node(node->children[a], model);
mcts.c:        backup_with_discount(root, actions, rewards, depth + 1, leaf_value,
mcts.c:                             params->discount);
mcts.c:        break;
mcts.c:      } else {
mcts.c:        float r = 0.0f;
mcts.c:        mu_model_dynamics(model, h_cur, a, node->children[a]->latent, &r);
mcts.c:        rewards[depth] = r;
mcts.c:        memcpy(h_cur, node->children[a]->latent, sizeof(float) * L);
mcts.c:        node = node->children[a];
mcts.c:        depth++;
mcts.c:      }
mcts.c:    }
mcts.c:    free(h_cur);
mcts.c:  }
mcts.c:
mcts.c:  float *pi = malloc(sizeof(float) * A);
mcts.c:  visits_to_pi(root, params->temperature, pi);
mcts.c:
mcts.c:  int best_a = 0;
mcts.c:  float best_q = -INFINITY;
mcts.c:  for (int a = 0; a < A; a++) {
mcts.c:    if (root->N[a] > 0 && root->Q[a] > best_q) {
mcts.c:      best_q = root->Q[a];
mcts.c:      best_a = a;
mcts.c:    }
mcts.c:  }
mcts.c:
mcts.c:  res.action_count = A;
mcts.c:  res.pi = pi;
mcts.c:  res.chosen_action = best_a;
mcts.c:  res.root_value = root_value;
mcts.c:
mcts.c:  free(actions);
mcts.c:  free(rewards);
mcts.c:  node_free(root);
mcts.c:  return res;
mcts.c:}
mcts.c:
mcts.c:/* Main MCTS run */
mcts.c:MCTSResult mcts_run(MuModel *model, const float *obs,
mcts.c:                    const MCTSParams *params) {
mcts.c:  MCTSResult res = {0};
mcts.c:
mcts.c:  if (!model || !obs || !params)
mcts.c:    return res;
mcts.c:
mcts.c:  int A = model->cfg.action_count;
mcts.c:  int L = model->cfg.latent_dim;
mcts.c:  Node *root = node_create(A, L);
mcts.c:  if (!root)
mcts.c:    return res;
mcts.c:
mcts.c:  mu_model_repr(model, obs, root->latent);
mcts.c:  float root_value = expand_node(root, model);
mcts.c:
mcts.c:  if (params->dirichlet_alpha > 0.0f && params->dirichlet_eps > 0.0f)
mcts.c:    add_dirichlet_noise(root, params->dirichlet_alpha, params->dirichlet_eps);
mcts.c:
mcts.c:  int max_depth = params->max_depth > 0 ? params->max_depth : 64;
mcts.c:  int *actions = (int *)malloc(sizeof(int) * max_depth);
mcts.c:  float *rewards = (float *)malloc(sizeof(float) * max_depth);
mcts.c:
mcts.c:  for (int sim = 0; sim < params->num_simulations; sim++) {
mcts.c:    Node *node = root;
mcts.c:    int depth = 0;
mcts.c:    float *h_cur = (float *)malloc(sizeof(float) * L);
mcts.c:    memcpy(h_cur, root->latent, sizeof(float) * L);
mcts.c:
mcts.c:    while (node->expanded && depth < max_depth) {
mcts.c:      int a = select_puct(node, params->c_puct);
mcts.c:      actions[depth] = a;
mcts.c:      float *h_next = NULL;
mcts.c:
mcts.c:      if (!node->children[a]) {
mcts.c:        node->children[a] = node_create(A, L);
mcts.c:        h_next = node->children[a]->latent;
mcts.c:        float r = 0.0f;
mcts.c:        mu_model_dynamics(model, h_cur, a, h_next, &r);
mcts.c:        rewards[depth] = r;
mcts.c:        float leaf_value = expand_node(node->children[a], model);
mcts.c:        backup_with_discount(root, actions, rewards, depth + 1, leaf_value,
mcts.c:                             params->discount);
mcts.c:        break; // only break, don't free h_cur here
mcts.c:      } else {
mcts.c:        h_next = node->children[a]->latent;
mcts.c:        float r = 0.0f;
mcts.c:        mu_model_dynamics(model, h_cur, a, h_next, &r);
mcts.c:        rewards[depth] = r;
mcts.c:        node = node->children[a];
mcts.c:        memcpy(h_cur, h_next, sizeof(float) * L);
mcts.c:        depth++;
mcts.c:      }
mcts.c:    }
mcts.c:    free(h_cur); // free exactly once
mcts.c:  }
mcts.c:
mcts.c:  float *pi = (float *)malloc(sizeof(float) * A);
mcts.c:  visits_to_pi(root, params->temperature, pi);
mcts.c:
mcts.c:  int best_a = 0;
mcts.c:  float best_q = -INFINITY;
mcts.c:  for (int a = 0; a < A; a++) {
mcts.c:    float q = (root->N[a] > 0) ? root->Q[a] : -INFINITY;
mcts.c:    if (q > best_q) {
mcts.c:      best_q = q;
mcts.c:      best_a = a;
mcts.c:    }
mcts.c:  }
mcts.c:  if (best_q == -INFINITY) { // all N==0
mcts.c:    float best_p = -INFINITY;
mcts.c:    for (int a = 0; a < A; a++)
mcts.c:      if (root->P[a] > best_p) {
mcts.c:        best_p = root->P[a];
mcts.c:        best_a = a;
mcts.c:      }
mcts.c:  }
mcts.c:
mcts.c:  res.action_count = A;
mcts.c:  res.pi = pi;
mcts.c:  res.chosen_action = best_a;
mcts.c:  res.root_value = root_value;
mcts.c:
mcts.c:  free(actions);
mcts.c:  free(rewards);
mcts.c:  node_free(root);
mcts.c:  return res;
mcts.c:}
mcts.c:
mcts.c:void mcts_result_free(MCTSResult *res) {
mcts.c:  if (!res)
mcts.c:    return;
mcts.c:  free(res->pi);
mcts.c:  res->pi = NULL;
mcts.c:  res->action_count = 0;
mcts.c:  res->chosen_action = 0;
mcts.c:  res->root_value = 0.0f;
mcts.c:}
mcts.h:#ifndef MCTS_H
mcts.h:#define MCTS_H
mcts.h:
mcts.h:#include "muzero_model.h"
mcts.h:
mcts.h:#ifdef __cplusplus
mcts.h:extern "C" {
mcts.h:#endif
mcts.h:
mcts.h:typedef struct {
mcts.h:  int num_simulations;
mcts.h:  float c_puct;
mcts.h:  int max_depth;
mcts.h:  float dirichlet_alpha;
mcts.h:  float dirichlet_eps;
mcts.h:  float temperature;
mcts.h:  float discount;
mcts.h:} MCTSParams;
mcts.h:
mcts.h:typedef struct {
mcts.h:  int chosen_action;
mcts.h:  int action_count;
mcts.h:  float *pi;        // visit-count policy, caller frees
mcts.h:  float root_value; // estimated root value
mcts.h:} MCTSResult;
mcts.h:
mcts.h:MCTSResult mcts_run(MuModel *model, const float *obs, const MCTSParams *params);
mcts.h:MCTSResult mcts_run_latent(MuModel *model, const float *latent,
mcts.h:                           const MCTSParams *params);
mcts.h:
mcts.h:void mcts_result_free(MCTSResult *res);
mcts.h:
mcts.h:#ifdef __cplusplus
mcts.h:}
mcts.h:#endif
mcts.h:#endif
muzero_model.c:#include "muzero_model.h"
muzero_model.c:#include "runtime.h"
muzero_model.c:#include <math.h>
muzero_model.c:#include <stdlib.h>
muzero_model.c:#include <string.h>
muzero_model.c:
muzero_model.c:/* ------------------------
muzero_model.c:   Create model
muzero_model.c:   ------------------------ */
muzero_model.c:MuModel *mu_model_create(const MuConfig *cfg) {
muzero_model.c:  MuModel *m = (MuModel *)malloc(sizeof(MuModel));
muzero_model.c:  m->cfg = *cfg;
muzero_model.c:
muzero_model.c:  int obs = cfg->obs_dim;
muzero_model.c:  int lat = cfg->latent_dim;
muzero_model.c:  int act = cfg->action_count;
muzero_model.c:
muzero_model.c:  /* allocate fake/placeholder weights */
muzero_model.c:  m->repr_W_count = obs * lat;
muzero_model.c:  m->dyn_W_count = (lat + 1) * lat;  // +1 for action embedding
muzero_model.c:  m->pred_W_count = lat * (act + 1); // policy + value head
muzero_model.c:
muzero_model.c:  m->repr_W = (float *)malloc(sizeof(float) * m->repr_W_count);
muzero_model.c:  m->dyn_W = (float *)malloc(sizeof(float) * m->dyn_W_count);
muzero_model.c:  m->pred_W = (float *)malloc(sizeof(float) * m->pred_W_count);
muzero_model.c:
muzero_model.c:  /* simple initialization */
muzero_model.c:  for (int i = 0; i < m->repr_W_count; i++)
muzero_model.c:    m->repr_W[i] = 0.01f;
muzero_model.c:  for (int i = 0; i < m->dyn_W_count; i++)
muzero_model.c:    m->dyn_W[i] = 0.01f;
muzero_model.c:  for (int i = 0; i < m->pred_W_count; i++)
muzero_model.c:    m->pred_W[i] = 0.01f;
muzero_model.c:
muzero_model.c:  m->runtime = mu_runtime_create(m, 0.95f);
muzero_model.c:
muzero_model.c:  return m;
muzero_model.c:}
muzero_model.c:
muzero_model.c:/* ------------------------
muzero_model.c:   Free model
muzero_model.c:   ------------------------ */
muzero_model.c:void mu_model_free(MuModel *m) {
muzero_model.c:  if (!m)
muzero_model.c:    return;
muzero_model.c:  free(m->repr_W);
muzero_model.c:  free(m->dyn_W);
muzero_model.c:  free(m->pred_W);
muzero_model.c:  free(m);
muzero_model.c:  mu_runtime_free(m->runtime);
muzero_model.c:}
muzero_model.c:
muzero_model.c:/* ------------------------
muzero_model.c:   Representation function
muzero_model.c:   obs → latent
muzero_model.c:   (Dummy linear layer)
muzero_model.c:   ------------------------ */
muzero_model.c:void mu_model_repr(MuModel *m, const float *obs, float *latent_out) {
muzero_model.c:  int O = m->cfg.obs_dim;
muzero_model.c:  int L = m->cfg.latent_dim;
muzero_model.c:
muzero_model.c:  for (int i = 0; i < L; i++) {
muzero_model.c:    float sum = 0.f;
muzero_model.c:    for (int j = 0; j < O; j++) {
muzero_model.c:      sum += obs[j] * m->repr_W[i * O + j];
muzero_model.c:    }
muzero_model.c:    latent_out[i] = tanhf(sum);
muzero_model.c:  }
muzero_model.c:}
muzero_model.c:
muzero_model.c:/* ------------------------
muzero_model.c:   Dynamics function
muzero_model.c:   latent + action → latent' + reward
muzero_model.c:   ------------------------ */
muzero_model.c:void mu_model_dynamics(MuModel *m, const float *latent_in, int action,
muzero_model.c:                       float *latent_out, float *reward_out) {
muzero_model.c:  int L = m->cfg.latent_dim;
muzero_model.c:
muzero_model.c:  /* simple deterministic dynamics */
muzero_model.c:  for (int i = 0; i < L; i++) {
muzero_model.c:    float sum = 0.f;
muzero_model.c:    for (int j = 0; j < L; j++) {
muzero_model.c:      sum += latent_in[j] * m->dyn_W[i * L + j];
muzero_model.c:    }
muzero_model.c:    sum += 0.1f * action;
muzero_model.c:    latent_out[i] = tanhf(sum);
muzero_model.c:  }
muzero_model.c:
muzero_model.c:  *reward_out = 0.01f * action; // placeholder
muzero_model.c:}
muzero_model.c:
muzero_model.c:/* ------------------------
muzero_model.c:   Prediction function
muzero_model.c:   latent → (policy_logits, value)
muzero_model.c:   ------------------------ */
muzero_model.c:void mu_model_predict(MuModel *m, const float *latent_in,
muzero_model.c:                      float *policy_logits_out, float *value_out) {
muzero_model.c:  int L = m->cfg.latent_dim;
muzero_model.c:  int A = m->cfg.action_count;
muzero_model.c:
muzero_model.c:  /* policy */
muzero_model.c:  for (int a = 0; a < A; a++) {
muzero_model.c:    float sum = 0.f;
muzero_model.c:    for (int j = 0; j < L; j++) {
muzero_model.c:      sum += latent_in[j] * m->pred_W[a * L + j];
muzero_model.c:    }
muzero_model.c:    policy_logits_out[a] = sum;
muzero_model.c:  }
muzero_model.c:
muzero_model.c:  /* value head */
muzero_model.c:  float sum = 0.f;
muzero_model.c:  for (int j = 0; j < L; j++) {
muzero_model.c:    sum += latent_in[j] * m->pred_W[(A * L) + j];
muzero_model.c:  }
muzero_model.c:  *value_out = tanhf(sum);
muzero_model.c:}
muzero_model.c:
muzero_model.c:void mu_model_step(MuModel *m, const float *obs, int action, float reward) {
muzero_model.c:  mu_runtime_step((MuRuntime *)m->runtime, m, obs, action, reward);
muzero_model.c:}
muzero_model.c:
muzero_model.c:void mu_model_end_episode(MuModel *m, float terminal_reward) {
muzero_model.c:  mu_runtime_end_episode((MuRuntime *)m->runtime, m, terminal_reward);
muzero_model.c:}
muzero_model.c:
muzero_model.c:void mu_model_reset_episode(MuModel *m) {
muzero_model.c:  mu_runtime_reset_episode((MuRuntime *)m->runtime);
muzero_model.c:}
muzero_model.c:
muzero_model.c:void mu_model_train(MuModel *m) {
muzero_model.c:  mu_runtime_train((MuRuntime *)m->runtime, m);
muzero_model.c:}
muzero_model.h:#ifndef MUZERO_MODEL_H
muzero_model.h:#define MUZERO_MODEL_H
muzero_model.h:
muzero_model.h:#ifdef __cplusplus
muzero_model.h:extern "C" {
muzero_model.h:#endif
muzero_model.h:
muzero_model.h:typedef struct {
muzero_model.h:  int obs_dim;
muzero_model.h:  int latent_dim;
muzero_model.h:  int action_count;
muzero_model.h:} MuConfig;
muzero_model.h:
muzero_model.h:typedef struct {
muzero_model.h:  MuConfig cfg;
muzero_model.h:  float *repr_W;
muzero_model.h:  float *dyn_W;
muzero_model.h:  float *pred_W;
muzero_model.h:  int repr_W_count;
muzero_model.h:  int dyn_W_count;
muzero_model.h:  int pred_W_count;
muzero_model.h:
muzero_model.h:  void *runtime;
muzero_model.h:} MuModel;
muzero_model.h:
muzero_model.h:MuModel *mu_model_create(const MuConfig *cfg);
muzero_model.h:void mu_model_free(MuModel *m);
muzero_model.h:
muzero_model.h:void mu_model_repr(MuModel *m, const float *obs, float *latent_out);
muzero_model.h:void mu_model_dynamics(MuModel *m, const float *latent_in, int action,
muzero_model.h:                       float *latent_out, float *reward_out);
muzero_model.h:void mu_model_predict(MuModel *m, const float *latent_in,
muzero_model.h:                      float *policy_logits_out, float *value_out);
muzero_model.h:
muzero_model.h:void mu_model_step(MuModel *m, const float *obs, int action, float reward);
muzero_model.h:void mu_model_end_episode(MuModel *m, float terminal_reward);
muzero_model.h:void mu_model_reset_episode(MuModel *m);
muzero_model.h:void mu_model_train(MuModel *m);
muzero_model.h:
muzero_model.h:#ifdef __cplusplus
muzero_model.h:}
muzero_model.h:#endif
muzero_model.h:#endif
replay_buffer.c:#include "replay_buffer.h"
replay_buffer.c:#include <stdlib.h>
replay_buffer.c:#include <string.h>
replay_buffer.c:#include <stdio.h>
replay_buffer.c:
replay_buffer.c:struct ReplayBuffer {
replay_buffer.c:    size_t capacity;
replay_buffer.c:    size_t size;
replay_buffer.c:    size_t write_idx;
replay_buffer.c:    int obs_dim;
replay_buffer.c:    int action_count;
replay_buffer.c:    float *obs_buf; /* capacity * obs_dim */
replay_buffer.c:    float *pi_buf;  /* capacity * action_count */
replay_buffer.c:    float *z_buf;   /* capacity */
replay_buffer.c:};
replay_buffer.c:
replay_buffer.c:ReplayBuffer *rb_create(size_t capacity, int obs_dim, int action_count) {
replay_buffer.c:    ReplayBuffer *rb = (ReplayBuffer*)malloc(sizeof(ReplayBuffer));
replay_buffer.c:    if (!rb) return NULL;
replay_buffer.c:    rb->capacity = capacity;
replay_buffer.c:    rb->size = 0;
replay_buffer.c:    rb->write_idx = 0;
replay_buffer.c:    rb->obs_dim = obs_dim;
replay_buffer.c:    rb->action_count = action_count;
replay_buffer.c:    rb->obs_buf = (float*)malloc(sizeof(float) * capacity * obs_dim);
replay_buffer.c:    rb->pi_buf  = (float*)malloc(sizeof(float) * capacity * action_count);
replay_buffer.c:    rb->z_buf   = (float*)malloc(sizeof(float) * capacity);
replay_buffer.c:    if (!rb->obs_buf || !rb->pi_buf || !rb->z_buf) { rb_free(rb); return NULL; }
replay_buffer.c:    return rb;
replay_buffer.c:}
replay_buffer.c:
replay_buffer.c:void rb_free(ReplayBuffer *rb) {
replay_buffer.c:    if (!rb) return;
replay_buffer.c:    if (rb->obs_buf) free(rb->obs_buf);
replay_buffer.c:    if (rb->pi_buf) free(rb->pi_buf);
replay_buffer.c:    if (rb->z_buf) free(rb->z_buf);
replay_buffer.c:    free(rb);
replay_buffer.c:}
replay_buffer.c:
replay_buffer.c:void rb_push(ReplayBuffer *rb, const float *obs, const float *pi, float z) {
replay_buffer.c:    if (!rb) return;
replay_buffer.c:    size_t idx = rb->write_idx;
replay_buffer.c:    memcpy(rb->obs_buf + idx * rb->obs_dim, obs, sizeof(float) * rb->obs_dim);
replay_buffer.c:    memcpy(rb->pi_buf  + idx * rb->action_count, pi,  sizeof(float) * rb->action_count);
replay_buffer.c:    rb->z_buf[idx] = z;
replay_buffer.c:    rb->write_idx = (rb->write_idx + 1) % rb->capacity;
replay_buffer.c:    if (rb->size < rb->capacity) rb->size++;
replay_buffer.c:}
replay_buffer.c:
replay_buffer.c:static int rand_int(int n) {
replay_buffer.c:    return (int)((double)rand() / ((double)RAND_MAX + 1.0) * n);
replay_buffer.c:}
replay_buffer.c:
replay_buffer.c:int rb_sample(ReplayBuffer *rb, int batch, float *obs_batch, float *pi_batch, float *z_batch) {
replay_buffer.c:    if (!rb || rb->size == 0) return 0;
replay_buffer.c:    int actual = batch;
replay_buffer.c:    if ((size_t)batch > rb->size) actual = (int)rb->size;
replay_buffer.c:    for (int i=0;i<actual;i++) {
replay_buffer.c:        int idx = rand_int((int)rb->size);
replay_buffer.c:        memcpy(obs_batch + i*rb->obs_dim, rb->obs_buf + idx*rb->obs_dim, sizeof(float)*rb->obs_dim);
replay_buffer.c:        memcpy(pi_batch  + i*rb->action_count, rb->pi_buf + idx*rb->action_count, sizeof(float)*rb->action_count);
replay_buffer.c:        z_batch[i] = rb->z_buf[idx];
replay_buffer.c:    }
replay_buffer.c:    return actual;
replay_buffer.c:}
replay_buffer.c:
replay_buffer.c:size_t rb_size(ReplayBuffer *rb) { return rb ? rb->size : 0; }
replay_buffer.c:
replay_buffer.h:#ifndef REPLAY_BUFFER_H
replay_buffer.h:#define REPLAY_BUFFER_H
replay_buffer.h:
replay_buffer.h:#include <stddef.h>
replay_buffer.h:
replay_buffer.h:#ifdef __cplusplus
replay_buffer.h:extern "C" {
replay_buffer.h:#endif
replay_buffer.h:
replay_buffer.h:typedef struct ReplayBuffer ReplayBuffer;
replay_buffer.h:
replay_buffer.h:ReplayBuffer *rb_create(size_t capacity, int obs_dim, int action_count);
replay_buffer.h:void rb_free(ReplayBuffer *rb);
replay_buffer.h:void rb_push(ReplayBuffer *rb, const float *obs, const float *pi, float z);
replay_buffer.h:int rb_sample(ReplayBuffer *rb, int batch, float *obs_batch, float *pi_batch,
replay_buffer.h:              float *z_batch);
replay_buffer.h:size_t rb_size(ReplayBuffer *rb);
replay_buffer.h:
replay_buffer.h:#ifdef __cplusplus
replay_buffer.h:}
replay_buffer.h:#endif
replay_buffer.h:
replay_buffer.h:#endif
runtime.c:#include "runtime.h"
runtime.c:#include <stdio.h>
runtime.c:#include <stdlib.h>
runtime.c:#include <string.h>
runtime.c:
runtime.c:MuRuntime *mu_runtime_create(MuModel *model, float gamma) {
runtime.c:  MuRuntime *rt = calloc(1, sizeof(MuRuntime));
runtime.c:
runtime.c:  rt->rb = rb_create(TRAIN_WINDOW, model->cfg.obs_dim, model->cfg.action_count);
runtime.c:
runtime.c:  rt->last_obs = malloc(sizeof(float) * model->cfg.obs_dim);
runtime.c:  rt->has_last = 0;
runtime.c:  rt->gamma = gamma;
runtime.c:  rt->total_steps = 0;
runtime.c:
runtime.c:  return rt;
runtime.c:}
runtime.c:
runtime.c:void mu_runtime_free(MuRuntime *rt) {
runtime.c:  if (!rt)
runtime.c:    return;
runtime.c:  rb_free(rt->rb);
runtime.c:  free(rt->last_obs);
runtime.c:  free(rt);
runtime.c:}
runtime.c:
runtime.c:void mu_runtime_step(MuRuntime *rt, MuModel *model, const float *obs,
runtime.c:                     int action, float reward) {
runtime.c:  rt->total_steps++;
runtime.c:
runtime.c:  if (!rt->has_last) {
runtime.c:    memcpy(rt->last_obs, obs, sizeof(float) * model->cfg.obs_dim);
runtime.c:    rt->last_action = action;
runtime.c:    rt->has_last = 1;
runtime.c:    return;
runtime.c:  }
runtime.c:
runtime.c:  /* One-step bootstrap target */
runtime.c:  float z = reward;
runtime.c:
runtime.c:  float pi[model->cfg.action_count];
runtime.c:  for (int i = 0; i < model->cfg.action_count; i++)
runtime.c:    pi[i] = (i == rt->last_action) ? 1.0f : 0.0f;
runtime.c:
runtime.c:  rb_push(rt->rb, rt->last_obs, pi, z);
runtime.c:
runtime.c:  memcpy(rt->last_obs, obs, sizeof(float) * model->cfg.obs_dim);
runtime.c:  rt->last_action = action;
runtime.c:}
runtime.c:
runtime.c:void mu_runtime_end_episode(MuRuntime *rt, MuModel *model,
runtime.c:                            float terminal_reward) {
runtime.c:  if (!rt->has_last)
runtime.c:    return;
runtime.c:
runtime.c:  float pi[model->cfg.action_count];
runtime.c:  memset(pi, 0, sizeof(pi));
runtime.c:
runtime.c:  rb_push(rt->rb, rt->last_obs, pi, terminal_reward);
runtime.c:  rt->has_last = 0;
runtime.c:}
runtime.c:
runtime.c:void mu_runtime_reset_episode(MuRuntime *rt) { rt->has_last = 0; }
runtime.c:
runtime.c:void mu_runtime_train(MuRuntime *rt, MuModel *model) {
runtime.c:  if (rb_size(rt->rb) < 32)
runtime.c:    return;
runtime.c:
runtime.c:  /* Placeholder training hook */
runtime.c:}
runtime.h:#ifndef MUZE_RUNTIME_H
runtime.h:#define MUZE_RUNTIME_H
runtime.h:
runtime.h:#include "muzero_model.h"
runtime.h:#include "replay_buffer.h"
runtime.h:#include <stdint.h>
runtime.h:
runtime.h:#define TRAIN_WINDOW 256 // training cache size, NOT memory size
runtime.h:
runtime.h:typedef struct {
runtime.h:  ReplayBuffer *rb;
runtime.h:
runtime.h:  float *last_obs;
runtime.h:  int last_action;
runtime.h:  int has_last;
runtime.h:
runtime.h:  float gamma;
runtime.h:
runtime.h:  /* infinite logical memory */
runtime.h:  uint64_t total_steps;
runtime.h:} MuRuntime;
runtime.h:
runtime.h:/* Runtime lifecycle */
runtime.h:MuRuntime *mu_runtime_create(MuModel *model, float gamma);
runtime.h:void mu_runtime_free(MuRuntime *rt);
runtime.h:
runtime.h:/* Runtime operations (internal) */
runtime.h:void mu_runtime_step(MuRuntime *rt, MuModel *model, const float *obs,
runtime.h:                     int action, float reward);
runtime.h:
runtime.h:void mu_runtime_end_episode(MuRuntime *rt, MuModel *model,
runtime.h:                            float terminal_reward);
runtime.h:
runtime.h:void mu_runtime_reset_episode(MuRuntime *rt);
runtime.h:void mu_runtime_train(MuRuntime *rt, MuModel *model);
runtime.h:
runtime.h:#endif
selfplay.c:#include "selfplay.h"
selfplay.c:#include "toy_env.h"
selfplay.c:#include <stdio.h>
selfplay.c:#include <stdlib.h>
selfplay.c:#include <string.h>
selfplay.c:
selfplay.c:/* Helper: compute discounted returns for an episode of length T.
selfplay.c:   rewards[0..T-1], gamma -> returns z_t = sum_{k=0..T-1-t} gamma^k *
selfplay.c:   rewards[t+k] output z_out must be length T
selfplay.c:*/
selfplay.c:static void compute_discounted_returns(const float *rewards, int T, float gamma,
selfplay.c:                                       float *z_out) {
selfplay.c:  for (int t = 0; t < T; t++) {
selfplay.c:    float acc = 0.0f;
selfplay.c:    float g = 1.0f;
selfplay.c:    for (int k = t; k < T; k++) {
selfplay.c:      acc += g * rewards[k];
selfplay.c:      g *= gamma;
selfplay.c:    }
selfplay.c:    z_out[t] = acc;
selfplay.c:  }
selfplay.c:}
selfplay.c:
selfplay.c:/* Runs self-play episodes and pushes training tuples into replay buffer */
selfplay.c:void selfplay_run(MuModel *model, void *env_state, env_reset_fn env_reset,
selfplay.c:                  env_step_fn env_step, MCTSParams *mcts_params,
selfplay.c:                  SelfPlayParams *sp_params, ReplayBuffer *rb) {
selfplay.c:  if (!model || !env_reset || !env_step || !mcts_params || !sp_params || !rb)
selfplay.c:    return;
selfplay.c:
selfplay.c:  int obs_dim = model->cfg.obs_dim;
selfplay.c:  int A = model->cfg.action_count;
selfplay.c:  int max_steps = sp_params->max_steps > 0 ? sp_params->max_steps : 200;
selfplay.c:
selfplay.c:  /* temporary buffers for one episode */
selfplay.c:  float *obs_buf = malloc(sizeof(float) * max_steps * obs_dim);
selfplay.c:  float *pi_buf = malloc(sizeof(float) * max_steps * A);
selfplay.c:  float *reward_buf = malloc(sizeof(float) * max_steps);
selfplay.c:  int *act_buf = malloc(sizeof(int) * max_steps);
selfplay.c:
selfplay.c:  for (int ep = 0; ep < sp_params->total_episodes; ep++) {
selfplay.c:    /* reset env */
selfplay.c:    float *obs0 = malloc(sizeof(float) * obs_dim);
selfplay.c:    env_reset(env_state, obs0);
selfplay.c:
selfplay.c:    int step = 0;
selfplay.c:    int done = 0;
selfplay.c:    float obs_cur[obs_dim];
selfplay.c:    memcpy(obs_cur, obs0, sizeof(float) * obs_dim);
selfplay.c:
selfplay.c:    while (!done && step < max_steps) {
selfplay.c:      /* run MCTS for current obs */
selfplay.c:      MCTSParams mp = *mcts_params;
selfplay.c:      mp.temperature = sp_params->temperature > 0.0f ? sp_params->temperature
selfplay.c:                                                     : mcts_params->temperature;
selfplay.c:
selfplay.c:      MCTSResult mr = mcts_run(model, obs_cur, &mp);
selfplay.c:
selfplay.c:      /* sample action according to pi (with rng) */
selfplay.c:      float r = (float)rand() / (float)RAND_MAX;
selfplay.c:      float cum = 0.0f;
selfplay.c:      int chosen = 0;
selfplay.c:      for (int a = 0; a < A; a++) {
selfplay.c:        cum += mr.pi[a];
selfplay.c:        if (r <= cum) {
selfplay.c:          chosen = a;
selfplay.c:          break;
selfplay.c:        }
selfplay.c:      }
selfplay.c:
selfplay.c:      /* store obs and pi */
selfplay.c:      memcpy(obs_buf + step * obs_dim, obs_cur, sizeof(float) * obs_dim);
selfplay.c:      memcpy(pi_buf + step * A, mr.pi, sizeof(float) * A);
selfplay.c:
selfplay.c:      /* step env */
selfplay.c:      float next_obs[obs_dim];
selfplay.c:      float reward = 0.0f;
selfplay.c:      int done_flag = 0;
selfplay.c:      int ret = env_step(env_state, chosen, next_obs, &reward, &done_flag);
selfplay.c:      if (ret != 0) {
selfplay.c:        /* env error: stop episode */
selfplay.c:        done_flag = 1;
selfplay.c:      }
selfplay.c:      reward_buf[step] = reward;
selfplay.c:      act_buf[step] = chosen;
selfplay.c:
selfplay.c:      /* advance */
selfplay.c:      memcpy(obs_cur, next_obs, sizeof(float) * obs_dim);
selfplay.c:      step++;
selfplay.c:
selfplay.c:      mcts_result_free(&mr);
selfplay.c:
selfplay.c:      if (done_flag)
selfplay.c:        done = 1;
selfplay.c:    }
selfplay.c:
selfplay.c:    /* compute discounted returns z_t and push samples to replay buffer */
selfplay.c:    float *z = malloc(sizeof(float) * step);
selfplay.c:    compute_discounted_returns(reward_buf, step, sp_params->gamma, z);
selfplay.c:    for (int t = 0; t < step; t++) {
selfplay.c:      rb_push(rb, obs_buf + t * obs_dim, pi_buf + t * A, z[t]);
selfplay.c:    }
selfplay.c:    free(z);
selfplay.c:    free(obs0);
selfplay.c:  }
selfplay.c:
selfplay.c:  free(obs_buf);
selfplay.c:  free(pi_buf);
selfplay.c:  free(reward_buf);
selfplay.c:  free(act_buf);
selfplay.c:}
selfplay.h:#ifndef SELFPLAY_H
selfplay.h:#define SELFPLAY_H
selfplay.h:
selfplay.h:#include "mcts.h"
selfplay.h:#include "muzero_model.h"
selfplay.h:#include "replay_buffer.h"
selfplay.h:
selfplay.h:#ifdef __cplusplus
selfplay.h:extern "C" {
selfplay.h:#endif
selfplay.h:
selfplay.h:/* Environment callback signatures:
selfplay.h:   - reset: should write initial observation into obs_out (length obs_dim)
selfplay.h:   - step: given action, perform env step, write next obs to obs_out (length
selfplay.h:   obs_dim), set *reward_out and *done_out (0/1). Return 0 on success. env_state
selfplay.h:   is an opaque pointer to environment instance. */
selfplay.h:typedef void (*env_reset_fn)(void *env_state, float *obs_out);
selfplay.h:typedef int (*env_step_fn)(void *state, int action, float *obs, float *reward,
selfplay.h:                           int *done);
selfplay.h:
selfplay.h:/* Self-play params */
selfplay.h:typedef struct {
selfplay.h:  int max_steps;      /* max steps per episode */
selfplay.h:  float gamma;        /* discount for returns */
selfplay.h:  float temperature;  /* sampling temperature during self-play (root) */
selfplay.h:  int total_episodes; /* how many episodes to run */
selfplay.h:} SelfPlayParams;
selfplay.h:
selfplay.h:/* Run self-play episodes: each episode uses MCTS to choose actions (with
selfplay.h:   MCTSParams) and pushes (obs, pi, z) samples into the replay buffer. env_state
selfplay.h:   is user-provided and env callbacks operate on it.
selfplay.h:*/
selfplay.h:void selfplay_run(MuModel *model, void *env_state, env_reset_fn env_reset,
selfplay.h:                  env_step_fn env_step, MCTSParams *mcts_params,
selfplay.h:                  SelfPlayParams *sp_params, ReplayBuffer *rb);
selfplay.h:
selfplay.h:#ifdef __cplusplus
selfplay.h:}
selfplay.h:#endif
selfplay.h:#endif
toy_env.c:#include "toy_env.h"
toy_env.c:#include <string.h>
toy_env.c:
toy_env.c:void toy_env_reset(void *state_ptr, float *obs) {
toy_env.c:  ToyEnvState *state = (ToyEnvState *)state_ptr;
toy_env.c:  state->pos = 0;
toy_env.c:  memset(obs, 0, sizeof(float) * state->size);
toy_env.c:  obs[state->pos] = 1.0f; // one-hot position
toy_env.c:}
toy_env.c:
toy_env.c:// changed return type from void -> int
toy_env.c:int toy_env_step(void *state_ptr, int action, float *obs, float *reward,
toy_env.c:                 int *done) {
toy_env.c:  ToyEnvState *state = (ToyEnvState *)state_ptr;
toy_env.c:
toy_env.c:  if (action == 0 && state->pos > 0)
toy_env.c:    state->pos--;
toy_env.c:  if (action == 1 && state->pos < state->size - 1)
toy_env.c:    state->pos++;
toy_env.c:
toy_env.c:  *reward = (state->pos == state->size - 1) ? 1.0f : 0.0f;
toy_env.c:  *done = (state->pos == state->size - 1) ? 1 : 0;
toy_env.c:
toy_env.c:  // update observation (one-hot)
toy_env.c:  memset(obs, 0, sizeof(float) * state->size);
toy_env.c:  obs[state->pos] = 1.0f;
toy_env.c:
toy_env.c:  return 0; // success
toy_env.c:}
toy_env.h:#ifndef TOY_ENV_H
toy_env.h:#define TOY_ENV_H
toy_env.h:
toy_env.h:typedef struct {
toy_env.h:  int pos;
toy_env.h:  int size;
toy_env.h:} ToyEnvState;
toy_env.h:
toy_env.h:typedef void (*env_reset_fn)(void *state, float *obs);
toy_env.h:typedef int (*env_step_fn)(void *state, int action, float *obs, float *reward,
toy_env.h:                           int *done);
toy_env.h:
toy_env.h:void toy_env_reset(void *state_ptr, float *obs);
toy_env.h:int toy_env_step(void *state_ptr, int action, float *obs, float *reward,
toy_env.h:                 int *done);
toy_env.h:
toy_env.h:#endif
