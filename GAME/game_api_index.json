[
  {"kind":"typedef_struct","vis":"PRIVATE","name":"MuzeReplayBuffer","file":"game.c","line_start":79,"line_end":98,"snippet":"double GetTime(void) {\n    return (double)SDL_GetTicks() / 1000.0;\n}\n\n// Clean API imports - includes all types and functions (after Raylib includes)\n#include \"framework/api.h\"\n\n// Include implementations\n#include \"framework/impl.h\"\n\n\nSDL_Window *g_window = NULL;\n\n// SDL input state tracking - must be declared before functions that use them\nstatic const bool *g_keyboard_state = NULL;\nstatic Uint32 g_mouse_state = 0;\nstatic float g_mouse_x = 0.0f, g_mouse_y = 0.0f;\nstatic bool g_prev_keyboard_state[SDL_SCANCODE_COUNT] = {0};\nstatic Uint32 g_prev_mouse_state = 0;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"MuzeLoopThread","file":"game.c","line_start":98,"line_end":120,"snippet":"\nSDL_Surface *TTF_RenderText_Blended(TTF_Font *font, const char *text,\n                                    size_t len, SDL_Color fg);\nSDL_Surface *SDL_ConvertSurface(SDL_Surface *src, Uint32 format);\nvoid SDL_FreeSurface(SDL_Surface *surf);\nvoid SDL_DestroySurface(SDL_Surface *surf);\nconst char *SDL_GetError(void);\n#define SDL_PIXELFORMAT_RGBA32 0x16462004\n\n// Custom ReplayBuffer type to avoid conflict with RL_AGENT\ntypedef struct {\n  size_t capacity;\n  size_t size;\n  size_t write_idx;\n  int obs_dim;\n  int action_count;\n  int support_size;\n  float *obs_buf;\n  float *pi_buf;\n  float *z_buf;\n  float *vprefix_buf;\n  float *prio_buf;\n  float *value_dist_buf;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"MuzeConfig","file":"game.c","line_start":120,"line_end":172,"snippet":"  float *value_dist_buf;\n  int *a_buf;\n  float *r_buf;\n  float *next_obs_buf;\n  int *done_buf;\n} MuzeReplayBuffer;\n\n// Local MuzeLoopThread definition to avoid including header with ReplayBuffer\ntypedef struct {\n  pthread_t thread;\n  int running;\n  int stop;\n  int use_multi;\n  void *model;          // MuModel *\n  void *env;            // MuzeEnv\n  MuzeReplayBuffer *rb; // Use our custom type\n  void *gr;             // GameReplay *\n  void *mcts;           // MCTSParams\n  void *selfplay;       // SelfPlayParams\n  void *loop;           // MuLoopConfig\n  struct {\n    void *ctx;\n    float (*rand01)(void *ctx); // Changed from double to float\n  } rng; // MCTSRng - use struct to avoid void* access issues\n  pthread_mutex_t *model_mutex;\n  pthread_mutex_t *rb_mutex;\n  pthread_mutex_t *gr_mutex;\n} MuzeLoopThread;\n\n// Local MuzeConfig definition to avoid including headers with ReplayBuffer\ntypedef struct {\n  struct {\n    int obs_dim;\n    int latent_dim;\n    int action_count;\n    int hidden_pred;\n    int hidden_vprefix;\n    int hidden_reward;\n    int hidden_dyn;\n    int hidden_repr;\n    int action_embed_dim;\n    int support_size;\n  } nn;\n  struct {\n    int obs_dim;\n    int latent_dim;\n    int action_count;\n  } model;\n  struct {\n    int num_simulations;\n    int batch_simulations;\n    float c_puct;\n    int max_depth;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"RayHit","file":"game.c","line_start":539,"line_end":546,"snippet":"#define R_DEATH (-1.000f)\n\n#define OBS_BASE_DIM 84\n#define OBS_GRID_W 8\n#define OBS_GRID_H 8\n#define OBS_HEIGHT_BINS 3\n#define OBS_CELL_TYPES 9\n#define OBS_TOKEN_DIM 16"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"ObsBuffer","file":"game.c","line_start":576,"line_end":584,"snippet":"  STATE_PAUSED,\n  STATE_COUNT\n} GameStateType;\n\ntypedef enum {\n  TOOL_HAND = 0,\n  TOOL_AXE = 1,\n  TOOL_PICKAXE = 2,\n  TOOL_SWORD = 3,"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Resource","file":"game.c","line_start":584,"line_end":595,"snippet":"  TOOL_SWORD = 3,\n  TOOL_ARMOR = 4,\n  TOOL_BOW = 5,\n  TOOL_COUNT = 6,\n  TOOL_NONE = -1\n} ToolType;\n\ntypedef enum {\n  RES_TREE = 0,\n  RES_ROCK,\n  RES_GOLD,\n  RES_FOOD,"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Mob","file":"game.c","line_start":595,"line_end":610,"snippet":"  RES_FOOD,\n  RES_NONE,\n  RES_COUNT\n} ResourceType;\n\ntypedef enum {\n  MOB_PIG = 0,\n  MOB_SHEEP,\n  MOB_SKELETON,\n  MOB_ZOMBIE,\n  MOB_COUNT\n} MobType;\n\ntypedef enum {\n  INTENT_NONE = 0,\n  INTENT_ATTACK,"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Projectile","file":"game.c","line_start":610,"line_end":620,"snippet":"  INTENT_ATTACK,\n  INTENT_HARVEST,\n  INTENT_COUNT\n} IntentType;\n\ntypedef enum {\n  HIT_NONE = 0,\n  HIT_RESOURCE = 1,\n  HIT_MOB = 2,\n  HIT_BASE = 3\n} HitKind;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"GrassBlade","file":"game.c","line_start":620,"line_end":628,"snippet":"} HitKind;\n\ntypedef struct {\n  HitKind kind;\n  float t;         // distance along ray (world units)\n  int cx, cy;      // chunk coords of hit\n  int index;       // resource index OR mob index OR tribe index\n  Vector2 hit_pos; // world-space hit point\n} RayHit;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Chunk","file":"game.c","line_start":628,"line_end":646,"snippet":"} RayHit;\n\ntypedef enum {\n  ACTION_UP = 0,\n  ACTION_DOWN,\n  ACTION_LEFT,\n  ACTION_RIGHT,\n  ACTION_ATTACK,\n  ACTION_FIRE,\n  ACTION_HARVEST,\n  ACTION_EAT,\n  ACTION_CRAFT,\n  ACTION_CRAFT_AXE,\n  ACTION_CRAFT_PICKAXE,\n  ACTION_CRAFT_SWORD,\n  ACTION_CRAFT_ARMOR,\n  ACTION_CRAFT_BOW,\n  ACTION_CRAFT_ARROWS,\n  ACTION_JUMP,"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Base","file":"game.c","line_start":646,"line_end":651,"snippet":"  ACTION_JUMP,\n  ACTION_NONE,\n  ACTION_COUNT\n} ActionType;\n\ntypedef enum {"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Tribe","file":"game.c","line_start":651,"line_end":661,"snippet":"typedef enum {\n  PROJ_OWNER_PLAYER = 0,\n  PROJ_OWNER_AGENT = 1,\n  PROJ_OWNER_MOB = 2\n} ProjOwner;\n\ntypedef enum { PICK_FOOD = 0, PICK_SHARD, PICK_ARROW } PickupType;\n\n// ----- forward prototypes -----\n/* =======================\n       STRUCTS"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Agent","file":"game.c","line_start":661,"line_end":701,"snippet":"       STRUCTS\n    ======================= */\n\ntypedef struct {\n  float *data;\n  int size;\n  int capacity;\n} ObsBuffer;\n\ntypedef struct {\n  Vector2 position; // LOCAL pos inside chunk\n  ResourceType type;\n  int health;\n  bool visited;\n\n  // animation\n  float hit_timer;   // shake\n  float break_flash; // white flash\n} Resource;\n\ntypedef struct {\n  Vector2 position; // LOCAL pos inside chunk\n  MobType type;\n  int health;\n  bool visited;\n\n  // AI / motion (chunk-local)\n  Vector2 vel;\n  float ai_timer;    // when to pick new wander dir\n  float aggro_timer; // stays angry after being hit\n  float attack_cd;\n  float hurt_timer;  // flash\n  float lunge_timer; // attack anim\n} Mob;\n\ntypedef struct {\n  bool alive;\n  Vector2 pos; // WORLD pos\n  Vector2 vel;\n  float ttl;\n  int damage;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Player","file":"game.c","line_start":701,"line_end":708,"snippet":"  int damage;\n  int owner_agent_id;\n  ProjOwner owner;\n} Projectile;\n\ntypedef struct {\n  float x;\n  float y;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Pickup","file":"game.c","line_start":708,"line_end":717,"snippet":"  float y;\n  float z;\n  float yaw;\n  float scale;\n} GrassBlade;\n\ntypedef struct Chunk {\n  int biome_type;\n  int terrain[CHUNK_SIZE][CHUNK_SIZE];\n  Resource resources[MAX_RESOURCES];"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Recipe","file":"game.c","line_start":717,"line_end":723,"snippet":"  Resource resources[MAX_RESOURCES];\n  int resource_count;\n  Mob mobs[MAX_MOBS];\n  bool generated;\n  float mob_spawn_timer;\n\n  GrassBlade *grass;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"WorldList","file":"game.c","line_start":723,"line_end":730,"snippet":"  GrassBlade *grass;\n  int grass_count;\n  int grass_capacity;\n  int grass_ready;\n  int grass_building;\n\n  pthread_rwlock_t lock;\n} Chunk;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"SaveAgent","file":"game.c","line_start":733,"line_end":763,"snippet":"  Vector2 position;\n  float radius;\n} Base;\n\ntypedef struct {\n  int tribe_id;\n  Color color;\n  Base base;\n  float integrity; // 0..100\n\n  int wood, stone, gold, food;\n  int shards, arrows;\n} Tribe;\n\ntypedef struct Agent {\n  Vector2 position;\n  Vector2 facing;\n  float health, stamina;\n  int agent_id;\n  bool alive;\n  float flash_timer;\n  int agent_start;\n  float reward_accumulator;\n  int age;\n  int last_action;\n\n  float attack_cd;\n  float harvest_cd;\n  float fire_cd;\n\n  int inv_food;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"SavePickup","file":"game.c","line_start":763,"line_end":772,"snippet":"  int inv_food;\n  int inv_arrows;\n  int inv_shards;\n\n  bool has_axe;\n  bool has_pickaxe;\n  bool has_sword;\n  bool has_armor;\n  bool has_bow;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"SaveProjectile","file":"game.c","line_start":772,"line_end":781,"snippet":"\n  int tool_selected;\n  int last_craft_selected;\n\n  // --- continuous actions (latches) ---\n  int fire_latched;       // 0/1\n  float fire_latch_timer; // seconds remaining to keep trying\n\n  // --- jumping ---\n  float jump_timer;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"SaveHeader","file":"game.c","line_start":781,"line_end":813,"snippet":"  float jump_timer;\n  float jump_velocity;\n\n  uint32_t rng_state;\n} Agent;\n\ntypedef struct {\n  Vector2 position;\n  Vector2 facing;\n  float health;\n  float stamina;\n} Player;\n\ntypedef struct {\n  bool alive;\n  Vector2 pos; // WORLD pos\n  PickupType type;\n  int amount;\n  float ttl;\n  float bob_t;\n} Pickup;\n\ntypedef struct {\n  const char *name;\n  int wood, stone, gold, food;\n  bool *unlock_flag; // set to true on craft\n} Recipe;\n\ntypedef struct {\n  char names[MAX_WORLDS][WORLD_NAME_MAX];\n  int count;\n  int selected; // -1 if none\n  int scroll;   // index offset for drawing"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"SaveChunkHeader","file":"game.c","line_start":813,"line_end":822,"snippet":"  int scroll;   // index offset for drawing\n} WorldList;\n\n#pragma pack(push, 1)\n\ntypedef struct {\n  // identity\n  int32_t agent_id;\n  int32_t alive;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"SaveResource","file":"game.c","line_start":822,"line_end":830,"snippet":"\n  // pose\n  float x, y;\n  float fx, fy;\n\n  // vitals\n  float health, stamina;\n\n  // bookkeeping"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"SaveMob","file":"game.c","line_start":830,"line_end":838,"snippet":"  // bookkeeping\n  int32_t age;\n  int32_t last_action;\n  float reward_accumulator;\n\n  // cooldowns + latches\n  float attack_cd, harvest_cd, fire_cd;\n  int32_t fire_latched;\n  float fire_latch_timer;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"VisionIdMap","file":"game.c","line_start":863,"line_end":884,"snippet":"  int32_t damage;\n  int32_t owner;\n} SaveProjectile;\n\ntypedef struct {\n  char magic[4];    // \"SAMW\"\n  uint32_t version; // 1\n  uint32_t seed;\n  uint32_t world_size;\n  uint32_t chunk_size;\n  float time_of_day;\n\n  // player\n  float player_x, player_y;\n  float player_health, player_stamina;\n\n  // player inv/tools\n  int32_t inv_wood, inv_stone, inv_gold, inv_food;\n  int32_t inv_shards, inv_arrows;\n  int32_t has_axe, has_pickaxe, has_sword, has_armor, has_bow;\n\n  // tribes"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"DamageNumber","file":"game.c","line_start":1014,"line_end":1021,"snippet":"  // Check for nearby mobs (targets)\n  for (int i = 0; i < MAX_MOBS; i++) {\n    Mob *m = &c->mobs[i];\n    if (m->health <= 0)\n      continue;\n\n    Vector2 mob_world = chunk_origin_to_world(cx, cy, m->position);\n    float dist = Vector2Distance(pos, mob_world);"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Keybind","file":"game.c","line_start":1076,"line_end":1081,"snippet":"static float TREE_SCALE = 2.35f; // MUCH larger\nstatic float ROCK_SCALE = 1.35f;\nstatic float GOLD_SCALE = 1.25f;\nstatic float FOOD_SCALE = 1.20f;\n\n// mobs can also be bigger if you want"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"GrassJob","file":"game.c","line_start":7108,"line_end":7113,"snippet":"      if (!load_world_from_disk(g_world_name)) {\n        // if load fails, create fresh using current seed\n        world_reset(g_world_seed);\n        save_world_to_disk(g_world_name);\n        save_models_to_disk(g_world_name);\n      } else {"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Vec3","file":"game.c","line_start":7250,"line_end":7254,"snippet":"static GrassJob g_grass_jobs[GRASS_JOB_CAP];\nstatic int g_grass_head = 0;\nstatic int g_grass_tail = 0;\nstatic int g_grass_quit = 0;\nstatic int g_grass_thread_started = 0;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"Mat4","file":"game.c","line_start":7254,"line_end":7258,"snippet":"static int g_grass_thread_started = 0;\n\nstatic void grass_enqueue_job(int cx, int cy) {\n  pthread_mutex_lock(&g_grass_mtx);\n  int next_tail = (g_grass_tail + 1) % GRASS_JOB_CAP;"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"GameMesh","file":"game.c","line_start":7258,"line_end":7265,"snippet":"  int next_tail = (g_grass_tail + 1) % GRASS_JOB_CAP;\n  if (next_tail != g_grass_head) {\n    g_grass_jobs[g_grass_tail] = (GrassJob){cx, cy};\n    g_grass_tail = next_tail;\n    pthread_cond_signal(&g_grass_cv);\n  }\n  pthread_mutex_unlock(&g_grass_mtx);\n}"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"UiFontEntry","file":"game.c","line_start":7310,"line_end":7313,"snippet":"      float cxp = gx * patch_cell + patch_cell * 0.5f;\n      float czp = gz * patch_cell + patch_cell * 0.5f;\n      int blades =\n          (int)(GRASS_PATCH_DENSITY * 0.75f) +"},
  {"kind":"typedef_struct","vis":"PRIVATE","name":"UiTextCache","file":"game.c","line_start":7316,"line_end":7323,"snippet":"      for (int i = 0; i < blades; i++) {\n        float jx = hash2d(gx * 131 + i * 7, gz * 173 - i * 11) * 2.0f - 1.0f;\n        float jz = hash2d(gx * 197 - i * 5, gz * 149 + i * 13) * 2.0f - 1.0f;\n        float px = cxp + jx * GRASS_PATCH_SIZE;\n        float pz = czp + jz * GRASS_PATCH_SIZE;\n        if (px < 0.0f || pz < 0.0f || px > world_span || pz > world_span)\n          continue;\n        float seed = hash2d(gx + i * 3, gz - i * 5);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"GetTime","file":"game.c","line_start":52,"line_end":54,"snippet":"typedef struct SDL_Surface SDL_Surface;\ntypedef struct {\n  unsigned char r, g, b, a;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"SDL_FreeSurface","file":"game.c","line_start":75,"line_end":75,"snippet":"                      int *h);"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"SDL_DestroySurface","file":"game.c","line_start":76,"line_end":76,"snippet":"                      */"},
  {"kind":"fn_def","vis":"PRIVATE","name":"update_sdl_input_state","file":"game.c","line_start":177,"line_end":187,"snippet":"  } mcts;\n  struct {\n    int batch_size;\n    int train_steps;\n    int min_replay_size;\n  } trainer;\n  struct {\n    int iterations;\n    int selfplay_episodes_per_iter;\n    int selfplay_disable;\n    int train_calls_per_iter;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"is_key_pressed","file":"game.c","line_start":189,"line_end":197,"snippet":"    int eval_interval;\n    int checkpoint_interval;\n    int selfplay_actor_count;\n    int selfplay_use_threads;\n  } loop;\n  struct {\n    int batch_size;\n    int train_steps;\n    int min_replay_size;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"is_mouse_button_down","file":"game.c","line_start":199,"line_end":201,"snippet":"} MuzeConfig;\n\n/*"},
  {"kind":"fn_def","vis":"PRIVATE","name":"IsKeyPressed_SDL","file":"game.c","line_start":204,"line_end":206,"snippet":"float Vector2Distance(Vector2 v1, Vector2 v2);\nVector2 Vector2Scale(Vector2 v, float scale);\nVector2 Vector2Add(Vector2 v1, Vector2 v2);"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"is_key_pressed","file":"game.c","line_start":205,"line_end":205,"snippet":"Vector2 Vector2Scale(Vector2 v, float scale);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"IsMouseButtonDown_SDL","file":"game.c","line_start":208,"line_end":210,"snippet":"float Vector2Length(Vector2 v);\nfloat Vector2DotProduct(Vector2 v1, Vector2 v2);\nvoid SetMouseVisible(int visible);"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"is_mouse_button_down","file":"game.c","line_start":209,"line_end":209,"snippet":"float Vector2DotProduct(Vector2 v1, Vector2 v2);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"IsMouseButtonPressed_SDL","file":"game.c","line_start":212,"line_end":214,"snippet":"*/\n\n// SDL Input helper functions to replace Raylib"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"is_mouse_button_down","file":"game.c","line_start":213,"line_end":213,"snippet":""},
  {"kind":"fn_def","vis":"PRIVATE","name":"IsMouseButtonReleased_SDL","file":"game.c","line_start":216,"line_end":218,"snippet":"  // Update keyboard state\n  g_keyboard_state = SDL_GetKeyboardState(NULL);\n  "},
  {"kind":"fn_def","vis":"PRIVATE","name":"IsKeyDown_SDL","file":"game.c","line_start":220,"line_end":222,"snippet":"  g_prev_mouse_state = g_mouse_state;\n  g_mouse_state = SDL_GetMouseState(&g_mouse_x, &g_mouse_y);\n  "},
  {"kind":"fn_def","vis":"PRIVATE","name":"update_ai_training","file":"game.c","line_start":320,"line_end":324,"snippet":"#define KEY_M SDL_SCANCODE_M\n#define KEY_F6 SDL_SCANCODE_F6\n#define KEY_F7 SDL_SCANCODE_F7\n#define KEY_P SDL_SCANCODE_P\n#define KEY_UP SDL_SCANCODE_UP"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"muze_loop_thread_start","file":"game.c","line_start":327,"line_end":327,"snippet":"#define KEY_RIGHT SDL_SCANCODE_RIGHT"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"muze_loop_thread_stop","file":"game.c","line_start":328,"line_end":328,"snippet":"#define KEY_ENTER SDL_SCANCODE_RETURN"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"muze_config_init_defaults","file":"game.c","line_start":329,"line_end":329,"snippet":"#define KEY_BACKSPACE SDL_SCANCODE_BACKSPACE"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"rb_enable_value_support","file":"game.c","line_start":332,"line_end":332,"snippet":"#define KEY_W SDL_SCANCODE_W"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"init_3d_renderer","file":"game.c","line_start":335,"line_end":335,"snippet":"#define KEY_D SDL_SCANCODE_D"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"rb_set_value_prefix","file":"game.c","line_start":338,"line_end":338,"snippet":"#define KEY_Y SDL_SCANCODE_Y"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"rb_free","file":"game.c","line_start":339,"line_end":339,"snippet":"#define KEY_X SDL_SCANCODE_X"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"chunk_origin_to_world","file":"game.c","line_start":343,"line_end":343,"snippet":"#define MOUSE_BUTTON_LEFT SDL_BUTTON_LEFT"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"hash2d","file":"game.c","line_start":354,"line_end":354,"snippet":""},
  {"kind":"fn_proto","vis":"PRIVATE","name":"terrain_height","file":"game.c","line_start":355,"line_end":355,"snippet":"/*"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"terrain_height_raw","file":"game.c","line_start":356,"line_end":356,"snippet":"// Implementations for missing Raylib Vector2 functions"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"grass_enqueue_job","file":"game.c","line_start":357,"line_end":357,"snippet":"Vector2 Vector2Normalize(Vector2 v) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"chunk_origin_to_world","file":"game.c","line_start":477,"line_end":482,"snippet":"#define MOB_ATTACK_RANGE 1.25f\n#define MOB_SPEED_PASSIVE 2.55f\n#define MOB_SPEED_SCARED (MOB_SPEED_PASSIVE * 2.0f)\n#define MOB_SPEED_HOSTILE 3.85f\n\n#define MAX_PROJECTILES 64"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"randf","file":"game.c","line_start":892,"line_end":892,"snippet":"  // ---- extra dynamic state ----"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"is_night","file":"game.c","line_start":893,"line_end":893,"snippet":"  uint32_t agent_count;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"init_tribes","file":"game.c","line_start":894,"line_end":894,"snippet":"  uint32_t pickup_count;     // number of alive pickups written"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"init_agents","file":"game.c","line_start":895,"line_end":895,"snippet":"  uint32_t projectile_count; // number of alive projectiles written"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"ensure_agents_ready_on_enter","file":"game.c","line_start":896,"line_end":896,"snippet":""},
  {"kind":"fn_proto","vis":"PRIVATE","name":"ensure_save_root","file":"game.c","line_start":897,"line_end":897,"snippet":"} SaveHeader;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"clamp_local_to_chunk","file":"game.c","line_start":898,"line_end":898,"snippet":""},
  {"kind":"fn_proto","vis":"PRIVATE","name":"find_free_mob_slot","file":"game.c","line_start":899,"line_end":899,"snippet":"typedef struct {"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"mob_radius_world","file":"game.c","line_start":903,"line_end":903,"snippet":""},
  {"kind":"fn_proto","vis":"PRIVATE","name":"on_mob_killed","file":"game.c","line_start":904,"line_end":904,"snippet":"  uint32_t resource_count;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"is_near_obstacle_or_target","file":"game.c","line_start":908,"line_end":944,"snippet":"typedef struct {\n  float lx, ly; // local pos\n  int32_t type;\n  int32_t health;\n  float hit_timer;\n  float break_flash;\n} SaveResource;\n\ntypedef struct {\n  float lx, ly; // local pos\n  int32_t type;\n  int32_t health;\n  float velx, vely;\n  float ai_timer, aggro_timer, attack_cd, hurt_timer, lunge_timer;\n} SaveMob;\n#pragma pack(pop)\n\nstatic uint32_t g_world_seed = 0;\nstatic GameStateType g_state = STATE_TITLE;\nstatic char g_world_name[WORLD_NAME_MAX] = {0};\nstatic char g_seed_text[64] = {0};\nstatic int g_typing_name = 0;\nstatic int g_typing_seed = 0;\nstatic int g_tribes_ready = 0;\nstatic float g_base_flat_height[TRIBE_COUNT] = {0};\nstatic const float g_base_open_half_angle = 0.61f; // ~35 deg\nstatic MuzeConfig g_muze_cfg;\nstatic MuModel *g_muze_model = NULL;\nstatic MuzeReplayBuffer *g_muze_rb = NULL;\nstatic pthread_mutex_t g_muze_model_mtx = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_mutex_t g_muze_rb_mtx = PTHREAD_MUTEX_INITIALIZER;\nstatic MuzeLoopThread g_muze_loop;\nstatic uint32_t g_muze_loop_rng_state = 0;\nstatic int g_muze_loop_started = 0;\nstatic int g_use_obs_transformer = 1;\nstatic Transformer_t *g_obs_transformer = NULL;\nstatic long double *g_obs_token_buf = NULL;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"start_ai_vs_ai_training","file":"game.c","line_start":947,"line_end":947,"snippet":""},
  {"kind":"fn_proto","vis":"PRIVATE","name":"stop_ai_vs_ai_training","file":"game.c","line_start":948,"line_end":948,"snippet":"typedef struct {"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"save_ai_models","file":"game.c","line_start":949,"line_end":949,"snippet":"  int self_id;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"update_ai_training","file":"game.c","line_start":950,"line_end":950,"snippet":"  int agent_same_id;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"toggle_spectator_mode","file":"game.c","line_start":953,"line_end":953,"snippet":"  int res_base;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"update_spectator_camera","file":"game.c","line_start":954,"line_end":954,"snippet":"  int base_base;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"update_spectator_controls","file":"game.c","line_start":955,"line_end":955,"snippet":"  int mob_stride;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"render_spectator_hud","file":"game.c","line_start":956,"line_end":956,"snippet":"  int res_stride;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"res_radius_world","file":"game.c","line_start":957,"line_end":957,"snippet":"  int base_stride;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"wrap_pi","file":"game.c","line_start":1129,"line_end":1135,"snippet":"\n// store last hand positions (screen space) for cooldown rings\nstatic Vector2 g_handL = {0}, g_handR = {0};\nstatic float g_dt = 1.0f / 60.0f;\nstatic float g_player_yaw = 0.0f;\nstatic float g_player_yaw_target = 0.0f;\nstatic float g_player_pitch = 0.0f;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"key_from_name","file":"game.c","line_start":1201,"line_end":1243,"snippet":"\nstatic Recipe recipes[] = {\n    {\"Axe (Wood+Stone)\", 3, 2, 0, 0, &has_axe},\n    {\"Pickaxe (Wood+Stone)\", 3, 3, 0, 0, &has_pickaxe},\n    {\"Sword (Stone+Gold)\", 0, 4, 2, 0, &has_sword},\n    {\"Armor (Stone+Gold)\", 0, 5, 2, 0, &has_armor},\n    {\"Bow (Wood+Gold)\", 4, 0, 1, 0, &has_bow},\n    {\"Arrows (Wood+Shards)\", 1, 0, 0, 0, NULL}, // Special case for arrows\n};\n\nstatic int recipe_count = sizeof(recipes) / sizeof(recipes[0]);\n\nstatic float wrap_pi(float a) {\n  while (a > PI)\n    a -= 2.0f * PI;\n  while (a < -PI)\n    a += 2.0f * PI;\n  return a;\n}\n\nstatic const char *bind_action_ids[BIND_COUNT] = {\n    \"move_forward\", \"move_back\", \"move_left\", \"move_right\", \"jump\",\n    \"sprint\",       \"pause\",     \"attack\",    \"harvest\",    \"fire\",\n};\n\nstatic const char *key_name(KeyboardKey k) {\n  if (k >= KEY_A && k <= KEY_Z) {\n    static char buf[8];\n    buf[0] = 'K';\n    buf[1] = 'E';\n    buf[2] = 'Y';\n    buf[3] = '_';\n    buf[4] = (char)('A' + (k - KEY_A));\n    buf[5] = '\\0';\n    return buf;\n  }\n  if (k >= KEY_ONE && k <= KEY_ZERO) {\n    static char buf[8];\n    buf[0] = 'K';\n    buf[1] = 'E';\n    buf[2] = 'Y';\n    buf[3] = '_';\n    buf[4] = (char)('1' + (k - KEY_ONE));"},
  {"kind":"fn_def","vis":"PRIVATE","name":"save_keybinds","file":"game.c","line_start":1273,"line_end":1282,"snippet":"    return \"KEY_F5\";\n  case KEY_F6:\n    return \"KEY_F6\";\n  case KEY_F7:\n    return \"KEY_F7\";\n  case KEY_NULL:\n    return \"KEY_NULL\";\n  default:\n    return \"KEY_UNKNOWN\";\n  }"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"rebuild_ground_perlin_mesh","file":"game.c","line_start":1284,"line_end":1284,"snippet":""},
  {"kind":"fn_def","vis":"PRIVATE","name":"prof_smooth","file":"game.c","line_start":1288,"line_end":1295,"snippet":"  if (strncmp(s, \"KEY_\", 4) == 0 && s[4] >= 'A' && s[4] <= 'Z' && !s[5]) {\n    return (KeyboardKey)(KEY_A + (s[4] - 'A'));\n  }\n  if (strncmp(s, \"KEY_\", 4) == 0 && s[4] >= '1' && s[4] <= '9' && !s[5]) {\n    return (KeyboardKey)(KEY_ONE + (s[4] - '1'));\n  }\n  if (strcmp(s, \"KEY_UP\") == 0)\n    return KEY_UP;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"save_graphics_config","file":"game.c","line_start":1297,"line_end":1306,"snippet":"    return KEY_DOWN;\n  if (strcmp(s, \"KEY_LEFT\") == 0)\n    return KEY_LEFT;\n  if (strcmp(s, \"KEY_RIGHT\") == 0)\n    return KEY_RIGHT;\n  if (strcmp(s, \"KEY_SPACE\") == 0)\n    return KEY_SPACE;\n  if (strcmp(s, \"KEY_TAB\") == 0)\n    return KEY_TAB;\n  if (strcmp(s, \"KEY_ENTER\") == 0)"},
  {"kind":"fn_def","vis":"PRIVATE","name":"load_graphics_config","file":"game.c","line_start":1308,"line_end":1333,"snippet":"  if (strcmp(s, \"KEY_BACKSPACE\") == 0)\n    return KEY_BACKSPACE;\n  if (strcmp(s, \"KEY_ESCAPE\") == 0)\n    return KEY_ESCAPE;\n  if (strcmp(s, \"KEY_MINUS\") == 0)\n    return KEY_MINUS;\n  if (strcmp(s, \"KEY_EQUAL\") == 0)\n    return KEY_EQUAL;\n  if (strcmp(s, \"KEY_LEFT_SHIFT\") == 0)\n    return KEY_LEFT_SHIFT;\n  if (strcmp(s, \"KEY_F5\") == 0)\n    return KEY_F5;\n  if (strcmp(s, \"KEY_F6\") == 0)\n    return KEY_F6;\n  if (strcmp(s, \"KEY_F7\") == 0)\n    return KEY_F7;\n  if (strcmp(s, \"KEY_NULL\") == 0)\n    return KEY_NULL;\n  return KEY_NULL;\n}\n\ntypedef enum {\n  GFX_LOW = 0,\n  GFX_MED,\n  GFX_HIGH,\n  GFX_CUSTOM,"},
  {"kind":"fn_def","vis":"PRIVATE","name":"load_keybinds","file":"game.c","line_start":1335,"line_end":1367,"snippet":"} GraphicsQuality;\n\nstatic GraphicsQuality g_gfx_quality = GFX_HIGH;\nstatic int g_enable_grass = 0;\nstatic int g_enable_ground_tex = 1;\nstatic float g_ground_tex_scale = 0.06f;\nstatic int g_grass_stride_near = GRASS_STRIDE_NEAR;\nstatic int g_grass_stride_mid = GRASS_STRIDE_MID;\nstatic int g_grass_stride_far = GRASS_STRIDE_FAR;\nstatic int g_grass_max_chunk_near = GRASS_MAX_CHUNK_NEAR;\nstatic int g_grass_max_chunk_mid = GRASS_MAX_CHUNK_MID;\nstatic int g_grass_max_chunk_far = GRASS_MAX_CHUNK_FAR;\nstatic int g_minimap_cells_normal = 40;\nstatic int g_minimap_cells_zoom = 56;\nstatic int g_profiler_enabled = 0;\nstatic double g_prof_update_ms = 0.0;\nstatic double g_prof_render_ms = 0.0;\nstatic double g_prof_ui_ms = 0.0;\nstatic double g_prof_total_ms = 0.0;\nstatic int g_prof_draw_calls = 0;\nstatic int g_prof_triangles = 0;\n\nstatic void save_keybinds(void) {\n  FILE *f = fopen(\"keybinds.cfg\", \"w\");\n  if (!f)\n    return;\n  for (int i = 0; i < BIND_COUNT; i++) {\n    fprintf(f, \"%s=%s,%s\\n\", bind_action_ids[i],\n            key_name(g_keybinds[i].primary), key_name(g_keybinds[i].secondary));\n  }\n  fclose(f);\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"bind_down","file":"game.c","line_start":1369,"line_end":1373,"snippet":"\nstatic double prof_now_ms(void) { return GetTime() * 1000.0; }\n\nstatic void prof_smooth(double *dst, double v) {\n  if (!dst)"},
  {"kind":"fn_def","vis":"PRIVATE","name":"can_afford","file":"game.c","line_start":1381,"line_end":1388,"snippet":"static void save_graphics_config(void) {\n  FILE *f = fopen(\"graphics.cfg\", \"w\");\n  if (!f)\n    return;\n  fprintf(f, \"quality=%d\\n\", (int)g_gfx_quality);\n  fprintf(f, \"enable_grass=%d\\n\", g_enable_grass ? 1 : 0);\n  fprintf(f, \"enable_ground_tex=%d\\n\", g_enable_ground_tex ? 1 : 0);\n  fprintf(f, \"ground_tex_scale=%.4f\\n\", g_ground_tex_scale);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"craft","file":"game.c","line_start":1390,"line_end":1405,"snippet":"}\n\nstatic void load_graphics_config(void) {\n  FILE *f = fopen(\"graphics.cfg\", \"r\");\n  if (!f)\n    return;\n  char line[128];\n  while (fgets(line, sizeof(line), f)) {\n    char *eq = strchr(line, '=');\n    if (!eq)\n      continue;\n    *eq = '\\0';\n    char *val = eq + 1;\n    char *newline = strchr(val, '\\n');\n    if (newline)\n      *newline = '\\0';"},
  {"kind":"fn_def","vis":"PRIVATE","name":"make_world_path","file":"game.c","line_start":1407,"line_end":1409,"snippet":"      g_gfx_quality = (GraphicsQuality)atoi(val);\n    } else if (strcmp(line, \"enable_grass\") == 0) {\n      g_enable_grass = atoi(val) ? 1 : 0;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"make_save_file_path","file":"game.c","line_start":1411,"line_end":1413,"snippet":"      g_enable_ground_tex = atoi(val) ? 1 : 0;\n    } else if (strcmp(line, \"ground_tex_scale\") == 0) {\n      g_ground_tex_scale = (float)atof(val);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"make_models_dir","file":"game.c","line_start":1415,"line_end":1417,"snippet":"  }\n  fclose(f);\n}"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"spawn_player_in_base","file":"game.c","line_start":1424,"line_end":1424,"snippet":"  while (fgets(line, sizeof(line), f)) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"world_reset","file":"game.c","line_start":1426,"line_end":1461,"snippet":"    if (!eq)\n      continue;\n    *eq = '\\0';\n    char *val = eq + 1;\n    char *comma = strchr(val, ',');\n    if (comma) {\n      *comma = '\\0';\n    }\n    char *newline = strchr(val, '\\n');\n    if (newline)\n      *newline = '\\0';\n    if (comma) {\n      char *newline2 = strchr(comma + 1, '\\n');\n      if (newline2)\n        *newline2 = '\\0';\n    }\n    for (int i = 0; i < BIND_COUNT; i++) {\n      if (strcmp(line, bind_action_ids[i]) == 0) {\n        g_keybinds[i].primary = key_from_name(val);\n        g_keybinds[i].secondary = comma ? key_from_name(comma + 1) : KEY_NULL;\n        break;\n      }\n    }\n  }\n  fclose(f);\n}\n\nstatic int bind_down(BindAction a) {\n  KeyboardKey p = g_keybinds[a].primary;\n  KeyboardKey s = g_keybinds[a].secondary;\n  return (p != KEY_NULL && IsKeyDown(p)) || (s != KEY_NULL && IsKeyDown(s));\n}\n\n/*\nstatic int bind_pressed(BindAction a) {\n  KeyboardKey p = g_keybinds[a].primary;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"save_world_to_disk","file":"game.c","line_start":1463,"line_end":1726,"snippet":"  return (p != KEY_NULL && IsKeyPressed(p)) ||\n         (s != KEY_NULL && IsKeyPressed(s));\n}\n\nstatic int bind_released(BindAction a) {\n  KeyboardKey p = g_keybinds[a].primary;\n  KeyboardKey s = g_keybinds[a].secondary;\n  return (p != KEY_NULL && IsKeyReleased(p)) ||\n         (s != KEY_NULL && IsKeyReleased(s));\n}\n*/\n\n// Temporary replacements\nstatic int bind_pressed(BindAction a) { return 0; }\nstatic int bind_released(BindAction a) { return 0; }\n\nstatic int can_afford(const Recipe *r) {\n  // Special case for arrows that requires shards\n  if (strcmp(r->name, \"Arrows (Wood+Shards)\") == 0) {\n    return inv_wood >= r->wood && inv_shards >= 1;\n  }\n  return inv_wood >= r->wood && inv_stone >= r->stone && inv_gold >= r->gold &&\n         inv_food >= r->food;\n}\n\nstatic void craft(const Recipe *r) {\n  if (!can_afford(r))\n    return;\n  inv_wood -= r->wood;\n  inv_stone -= r->stone;\n  inv_gold -= r->gold;\n  inv_food -= r->food;\n\n  // Special case for arrows\n  if (strcmp(r->name, \"Arrows (Wood+Shards)\") == 0) {\n    inv_shards -= 1; // Consume 1 shard\n    inv_arrows += 5; // Craft 5 arrows per recipe\n  } else if (r->unlock_flag) {\n    *r->unlock_flag = true;\n  }\n}\n\nstatic void make_world_path(char *out, size_t cap, const char *world_name) {\n  snprintf(out, cap, \"%s/%s\", SAVE_ROOT, world_name);\n}\n\nstatic void make_save_file_path(char *out, size_t cap, const char *world_name) {\n  snprintf(out, cap, \"%s/%s/world.sav\", SAVE_ROOT, world_name);\n}\n\nstatic void make_models_dir(char *out, size_t cap, const char *world_name) {\n  snprintf(out, cap, \"%s/%s/models\", SAVE_ROOT, world_name);\n}\n\nstatic void make_global_model_path(char *out, size_t cap,\n                                   const char *world_name) {\n  snprintf(out, cap, \"%s/%s/models/muze_model.bin\", SAVE_ROOT, world_name);\n}\n\nstatic Vector2 spawn_player_in_base(void);\n\nstatic void world_reset(uint32_t seed) {\n  srand(seed);\n\n  // reset chunks but KEEP locks valid\n  for (int x = 0; x < WORLD_SIZE; x++) {\n    for (int y = 0; y < WORLD_SIZE; y++) {\n      Chunk *c = &world[x][y];\n      // NOTE: lock should already be init'd once at program start\n      pthread_rwlock_wrlock(&c->lock);\n      c->generated = false;\n      c->resource_count = 0;\n      c->biome_type = 0;\n      c->mob_spawn_timer = randf(1.0f, 3.0f);\n      for (int i = 0; i < MAX_MOBS; i++)\n        c->mobs[i].health = 0;\n      pthread_rwlock_unlock(&c->lock);\n    }\n  }\n\n  init_tribes();\n  init_agents();\n\n  // reset player (spawn inside base)\n  player.position = spawn_player_in_base();\n  player.health = 100.0f;\n  player.stamina = 100.0f;\n\n  // reset globals\n  time_of_day = 0.25f;\n  is_night_cached = is_night();\n\n  inv_wood = inv_stone = inv_gold = inv_food = 0;\n  inv_shards = inv_arrows = 0;\n\n  has_axe = has_pickaxe = has_sword = has_armor = has_bow = false;\n}\n\nstatic int save_world_to_disk(const char *world_name) {\n  ensure_save_root();\n\n  char world_dir[256];\n  make_world_path(world_dir, sizeof(world_dir), world_name);\n  if (mkdir(world_dir, 0755) != 0 && errno != EEXIST) {\n    fprintf(stderr, \"mkdir(%s) failed: %s\\n\", world_dir, strerror(errno));\n    return 0;\n  }\n\n  char final_path[256];\n  make_save_file_path(final_path, sizeof(final_path), world_name);\n\n  char tmp_path[256];\n  snprintf(tmp_path, sizeof(tmp_path), \"%s.tmp\", final_path);\n\n  FILE *f = fopen(tmp_path, \"wb\");\n  if (!f) {\n    fprintf(stderr, \"fopen(%s) failed: %s\\n\", tmp_path, strerror(errno));\n    return 0;\n  }\n\n  SaveHeader h = {0};\n  h.magic[0] = 'S';\n  h.magic[1] = 'A';\n  h.magic[2] = 'M';\n  h.magic[3] = 'W';\n  h.version = 3;\n  h.seed = g_world_seed;\n  h.world_size = WORLD_SIZE;\n  h.chunk_size = CHUNK_SIZE;\n  h.time_of_day = time_of_day;\n\n  // player\n  h.player_x = player.position.x;\n  h.player_y = player.position.y;\n  h.player_health = player.health;\n  h.player_stamina = player.stamina;\n\n  // player inv/tools\n  h.inv_wood = inv_wood;\n  h.inv_stone = inv_stone;\n  h.inv_gold = inv_gold;\n  h.inv_food = inv_food;\n  h.inv_shards = inv_shards;\n  h.inv_arrows = inv_arrows;\n  h.has_axe = has_axe;\n  h.has_pickaxe = has_pickaxe;\n  h.has_sword = has_sword;\n  h.has_armor = has_armor;\n  h.has_bow = has_bow;\n\n  // tribes\n  for (int t = 0; t < TRIBE_COUNT; t++) {\n    h.tribe_integrity[t] = tribes[t].integrity;\n    h.tribe_wood[t] = tribes[t].wood;\n    h.tribe_stone[t] = tribes[t].stone;\n    h.tribe_gold[t] = tribes[t].gold;\n    h.tribe_food[t] = tribes[t].food;\n    h.tribe_shards[t] = tribes[t].shards;\n    h.tribe_arrows[t] = tribes[t].arrows;\n  }\n\n  // chunk_count\n  uint32_t chunk_count = 0;\n  for (int cx = 0; cx < WORLD_SIZE; cx++)\n    for (int cy = 0; cy < WORLD_SIZE; cy++)\n      if (world[cx][cy].generated)\n        chunk_count++;\n  h.chunk_count = chunk_count;\n\n  // agents (always MAX_AGENTS)\n  h.agent_count = MAX_AGENTS;\n\n  // pickups (alive only)\n  uint32_t pcount = 0;\n  for (int i = 0; i < MAX_PICKUPS; i++)\n    if (pickups[i].alive)\n      pcount++;\n  h.pickup_count = pcount;\n\n  // projectiles (alive only)\n  uint32_t prcount = 0;\n  for (int i = 0; i < MAX_PROJECTILES; i++)\n    if (projectiles[i].alive)\n      prcount++;\n  h.projectile_count = prcount;\n\n  // ---- write header ONCE ----\n  if (fwrite(&h, sizeof(h), 1, f) != 1) {\n    fclose(f);\n    return 0;\n  }\n\n  // ---- write agents ONCE ----\n  for (int i = 0; i < MAX_AGENTS; i++) {\n    Agent *a = &agents[i];\n    SaveAgent sa = {0};\n\n    sa.agent_id = a->agent_id;\n    sa.alive = a->alive ? 1 : 0;\n\n    sa.x = a->position.x;\n    sa.y = a->position.y;\n    sa.fx = a->facing.x;\n    sa.fy = a->facing.y;\n\n    sa.health = a->health;\n    sa.stamina = a->stamina;\n\n    sa.age = a->age;\n    sa.last_action = a->last_action;\n    sa.reward_accumulator = a->reward_accumulator;\n\n    sa.attack_cd = a->attack_cd;\n    sa.harvest_cd = a->harvest_cd;\n    sa.fire_cd = a->fire_cd;\n\n    sa.fire_latched = a->fire_latched;\n    sa.fire_latch_timer = a->fire_latch_timer;\n\n    sa.inv_food = a->inv_food;\n    sa.inv_arrows = a->inv_arrows;\n    sa.inv_shards = a->inv_shards;\n\n    sa.has_axe = a->has_axe;\n    sa.has_pickaxe = a->has_pickaxe;\n    sa.has_sword = a->has_sword;\n    sa.has_armor = a->has_armor;\n    sa.has_bow = a->has_bow;\n\n    sa.tool_selected = a->tool_selected;\n    sa.last_craft_selected = a->last_craft_selected;\n\n    if (fwrite(&sa, sizeof(sa), 1, f) != 1) {\n      fclose(f);\n      return 0;\n    }\n  }\n\n  // ---- write pickups ONCE ----\n  for (int i = 0; i < MAX_PICKUPS; i++) {\n    if (!pickups[i].alive)\n      continue;\n    SavePickup sp = {0};\n    sp.alive = 1;\n    sp.x = pickups[i].pos.x;\n    sp.y = pickups[i].pos.y;\n    sp.type = (int32_t)pickups[i].type;\n    sp.amount = pickups[i].amount;\n    sp.ttl = pickups[i].ttl;\n    sp.bob_t = pickups[i].bob_t;\n    if (fwrite(&sp, sizeof(sp), 1, f) != 1) {\n      fclose(f);\n      return 0;\n    }\n  }\n\n  // ---- write projectiles ONCE ----\n  for (int i = 0; i < MAX_PROJECTILES; i++) {\n    if (!projectiles[i].alive)\n      continue;\n    SaveProjectile sp = {0};\n    sp.alive = 1;\n    sp.x = projectiles[i].pos.x;\n    sp.y = projectiles[i].pos.y;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"load_world_from_disk","file":"game.c","line_start":1728,"line_end":1979,"snippet":"    sp.vy = projectiles[i].vel.y;\n    sp.ttl = projectiles[i].ttl;\n    sp.damage = projectiles[i].damage;\n    sp.owner = (int32_t)projectiles[i].owner;\n    if (fwrite(&sp, sizeof(sp), 1, f) != 1) {\n      fclose(f);\n      return 0;\n    }\n  }\n\n  // ---- write chunks ----\n  for (int cx = 0; cx < WORLD_SIZE; cx++) {\n    for (int cy = 0; cy < WORLD_SIZE; cy++) {\n      Chunk *c = &world[cx][cy];\n      if (!c->generated)\n        continue;\n\n      pthread_rwlock_rdlock(&c->lock);\n\n      SaveChunkHeader ch = {0};\n      ch.cx = cx;\n      ch.cy = cy;\n      ch.biome_type = c->biome_type;\n      ch.mob_spawn_timer = c->mob_spawn_timer;\n      ch.resource_count = (uint32_t)c->resource_count;\n\n      uint32_t alive_mobs = 0;\n      for (int i = 0; i < MAX_MOBS; i++)\n        if (c->mobs[i].health > 0)\n          alive_mobs++;\n      ch.mob_count = alive_mobs;\n\n      if (fwrite(&ch, sizeof(ch), 1, f) != 1) {\n        pthread_rwlock_unlock(&c->lock);\n        fclose(f);\n        return 0;\n      }\n\n      // resources\n      for (int i = 0; i < c->resource_count; i++) {\n        const Resource *r = &c->resources[i];\n        SaveResource sr = {0};\n        sr.lx = r->position.x;\n        sr.ly = r->position.y;\n        sr.type = (int32_t)r->type;\n        sr.health = (int32_t)r->health;\n        sr.hit_timer = r->hit_timer;\n        sr.break_flash = r->break_flash;\n        if (fwrite(&sr, sizeof(sr), 1, f) != 1) {\n          pthread_rwlock_unlock(&c->lock);\n          fclose(f);\n          return 0;\n        }\n      }\n\n      // mobs (alive only)\n      for (int i = 0; i < MAX_MOBS; i++) {\n        const Mob *m = &c->mobs[i];\n        if (m->health <= 0)\n          continue;\n\n        SaveMob sm = {0};\n        sm.lx = m->position.x;\n        sm.ly = m->position.y;\n        sm.type = (int32_t)m->type;\n        sm.health = (int32_t)m->health;\n        sm.velx = m->vel.x;\n        sm.vely = m->vel.y;\n        sm.ai_timer = m->ai_timer;\n        sm.aggro_timer = m->aggro_timer;\n        sm.attack_cd = m->attack_cd;\n        sm.hurt_timer = m->hurt_timer;\n        sm.lunge_timer = m->lunge_timer;\n\n        if (fwrite(&sm, sizeof(sm), 1, f) != 1) {\n          pthread_rwlock_unlock(&c->lock);\n          fclose(f);\n          return 0;\n        }\n      }\n\n      pthread_rwlock_unlock(&c->lock);\n    }\n  }\n\n  fflush(f);\n  fclose(f);\n\n  // atomic replace\n  if (rename(tmp_path, final_path) != 0) {\n    fprintf(stderr, \"rename(%s -> %s) failed: %s\\n\", tmp_path, final_path,\n            strerror(errno));\n    return 0;\n  }\n\n  return 1;\n}\n\nstatic int load_world_from_disk(const char *world_name) {\n  char path[256];\n  make_save_file_path(path, sizeof(path), world_name);\n\n  FILE *f = fopen(path, \"rb\");\n  if (!f) {\n    return 0;\n  }\n\n  SaveHeader h = {0};\n  if (fread(&h, sizeof(h), 1, f) != 1) {\n    fclose(f);\n    return 0;\n  }\n\n  if (h.magic[0] != 'S' || h.magic[1] != 'A' || h.magic[2] != 'M' ||\n      h.magic[3] != 'W') {\n    fclose(f);\n    return 0;\n  }\n  if (h.version != 3) {\n    // you *can* keep your old v1/v2 loader if you want backwards compat,\n    // but DO NOT mix layouts. For now: reject.\n    fclose(f);\n    fprintf(stderr, \"Unsupported save version: %u\\n\", h.version);\n    return 0;\n  }\n\n  g_world_seed = h.seed;\n  world_reset(g_world_seed);\n\n  time_of_day = h.time_of_day;\n  is_night_cached = is_night();\n\n  // player\n  player.position = (Vector2){h.player_x, h.player_y};\n  player.health = h.player_health;\n  player.stamina = h.player_stamina;\n\n  // inv/tools\n  inv_wood = h.inv_wood;\n  inv_stone = h.inv_stone;\n  inv_gold = h.inv_gold;\n  inv_food = h.inv_food;\n  inv_shards = h.inv_shards;\n  inv_arrows = h.inv_arrows;\n\n  has_axe = h.has_axe;\n  has_pickaxe = h.has_pickaxe;\n  has_sword = h.has_sword;\n  has_armor = h.has_armor;\n  has_bow = h.has_bow;\n\n  // tribes\n  for (int t = 0; t < TRIBE_COUNT; t++) {\n    tribes[t].integrity = h.tribe_integrity[t];\n    tribes[t].wood = h.tribe_wood[t];\n    tribes[t].stone = h.tribe_stone[t];\n    tribes[t].gold = h.tribe_gold[t];\n    tribes[t].food = h.tribe_food[t];\n    tribes[t].shards = h.tribe_shards[t];\n    tribes[t].arrows = h.tribe_arrows[t];\n  }\n\n  // ---- agents ONCE ----\n  uint32_t acount = h.agent_count;\n  if (acount != MAX_AGENTS) {\n    // if you later allow variable agent_count, handle it; for now keep\n    // fixed.\n    fprintf(stderr, \"Save has agent_count=%u but build expects %d\\n\", acount,\n            MAX_AGENTS);\n    fclose(f);\n    return 0;\n  }\n\n  for (int i = 0; i < MAX_AGENTS; i++) {\n    SaveAgent sa = {0};\n    if (fread(&sa, sizeof(sa), 1, f) != 1) {\n      fclose(f);\n      return 0;\n    }\n\n    Agent *a = &agents[i];\n    a->agent_id = sa.agent_id;\n    a->alive = sa.alive ? true : false;\n\n    a->position = (Vector2){sa.x, sa.y};\n    a->facing = (Vector2){sa.fx, sa.fy};\n\n    a->health = sa.health;\n    a->stamina = sa.stamina;\n\n    a->age = sa.age;\n    a->last_action = sa.last_action;\n    a->reward_accumulator = sa.reward_accumulator;\n\n    a->attack_cd = sa.attack_cd;\n    a->harvest_cd = sa.harvest_cd;\n    a->fire_cd = sa.fire_cd;\n\n    a->fire_latched = sa.fire_latched;\n    a->fire_latch_timer = sa.fire_latch_timer;\n\n    a->inv_food = sa.inv_food;\n    a->inv_arrows = sa.inv_arrows;\n    a->inv_shards = sa.inv_shards;\n\n    a->has_axe = sa.has_axe;\n    a->has_pickaxe = sa.has_pickaxe;\n    a->has_sword = sa.has_sword;\n    a->has_armor = sa.has_armor;\n    a->has_bow = sa.has_bow;\n\n    a->tool_selected = sa.tool_selected;\n    a->last_craft_selected = sa.last_craft_selected;\n  }\n  ensure_agents_ready_on_enter();\n\n  // ---- pickups ONCE ----\n  for (int i = 0; i < MAX_PICKUPS; i++)\n    pickups[i].alive = false;\n\n  uint32_t pcount = h.pickup_count;\n  for (uint32_t k = 0; k < pcount; k++) {\n    SavePickup sp = {0};\n    if (fread(&sp, sizeof(sp), 1, f) != 1) {\n      fclose(f);\n      return 0;\n    }\n\n    for (int i = 0; i < MAX_PICKUPS; i++) {\n      if (!pickups[i].alive) {\n        pickups[i].alive = true;\n        pickups[i].pos = (Vector2){sp.x, sp.y};\n        pickups[i].type = (PickupType)sp.type;\n        pickups[i].amount = sp.amount;\n        pickups[i].ttl = sp.ttl;\n        pickups[i].bob_t = sp.bob_t;\n        break;\n      }\n    }\n  }\n\n  // ---- projectiles ONCE ----\n  for (int i = 0; i < MAX_PROJECTILES; i++)\n    projectiles[i].alive = false;\n\n  uint32_t prcount = h.projectile_count;\n  for (uint32_t k = 0; k < prcount; k++) {\n    SaveProjectile sp = {0};\n    if (fread(&sp, sizeof(sp), 1, f) != 1) {\n      fclose(f);\n      return 0;\n    }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"save_models_to_disk","file":"game.c","line_start":1981,"line_end":1998,"snippet":"    for (int i = 0; i < MAX_PROJECTILES; i++) {\n      if (!projectiles[i].alive) {\n        projectiles[i].alive = true;\n        projectiles[i].pos = (Vector2){sp.x, sp.y};\n        projectiles[i].vel = (Vector2){sp.vx, sp.vy};\n        projectiles[i].ttl = sp.ttl;\n        projectiles[i].damage = sp.damage;\n        projectiles[i].owner = (ProjOwner)sp.owner;\n        break;\n      }\n    }\n  }\n\n  // ---- chunks ----\n  for (uint32_t k = 0; k < h.chunk_count; k++) {\n    SaveChunkHeader ch = {0};\n    if (fread(&ch, sizeof(ch), 1, f) != 1) {\n      fclose(f);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"load_models_from_disk","file":"game.c","line_start":2000,"line_end":2013,"snippet":"    }\n\n    int cx = (int)ch.cx;\n    int cy = (int)ch.cy;\n    if (cx < 0 || cx >= WORLD_SIZE || cy < 0 || cy >= WORLD_SIZE) {\n      fclose(f);\n      return 0;\n    }\n\n    Chunk *c = &world[cx][cy];\n    pthread_rwlock_wrlock(&c->lock);\n\n    c->generated = true;\n    c->biome_type = ch.biome_type;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"obs_init","file":"game.c","line_start":2036,"line_end":2040,"snippet":"        r->type = (ResourceType)sr.type;\n        r->health = (int)sr.health;\n        r->visited = false;\n        r->hit_timer = sr.hit_timer;\n        r->break_flash = sr.break_flash;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"obs_push","file":"game.c","line_start":2042,"line_end":2048,"snippet":"    }\n\n    // clear mobs then load alive mobs\n    for (int i = 0; i < MAX_MOBS; i++)\n      c->mobs[i].health = 0;\n\n    for (uint32_t i = 0; i < ch.mob_count; i++) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"obs_free","file":"game.c","line_start":2050,"line_end":2054,"snippet":"      if (fread(&sm, sizeof(sm), 1, f) != 1) {\n        pthread_rwlock_unlock(&c->lock);\n        fclose(f);\n        return 0;\n      }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"wrap_angle","file":"game.c","line_start":2058,"line_end":2064,"snippet":"        Mob *m = &c->mobs[slot];\n        m->position = clamp_local_to_chunk((Vector2){sm.lx, sm.ly});\n        m->type = (MobType)sm.type;\n        m->health = (int)sm.health;\n        m->visited = false;\n        m->vel = (Vector2){sm.velx, sm.vely};\n        m->ai_timer = sm.ai_timer;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"lerp_angle","file":"game.c","line_start":2066,"line_end":2069,"snippet":"        m->attack_cd = sm.attack_cd;\n        m->hurt_timer = sm.hurt_timer;\n        m->lunge_timer = sm.lunge_timer;\n      }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"randf","file":"game.c","line_start":2072,"line_end":2074,"snippet":"    pthread_rwlock_unlock(&c->lock);\n  }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"xorshift32","file":"game.c","line_start":2076,"line_end":2083,"snippet":"  return 1;\n}\n\nstatic int save_models_to_disk(const char *world_name) {\n  char dir[256];\n  make_models_dir(dir, sizeof(dir), world_name);\n  mkdir(dir, 0755);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"agent_rng01","file":"game.c","line_start":2085,"line_end":2091,"snippet":"    return 1;\n  char path[256];\n  make_global_model_path(path, sizeof(path), world_name);\n  pthread_mutex_lock(&g_muze_model_mtx);\n  if (!mu_model_save(g_muze_model, path)) {\n    fprintf(stderr, \"Failed to save Muze model\\n\");\n    pthread_mutex_unlock(&g_muze_model_mtx);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"loop_rng01","file":"game.c","line_start":2093,"line_end":2101,"snippet":"  }\n  pthread_mutex_unlock(&g_muze_model_mtx);\n  return 1;\n}\n\nstatic int load_models_from_disk(const char *world_name) {\n  char path[256];\n  make_global_model_path(path, sizeof(path), world_name);\n  pthread_mutex_lock(&g_muze_model_mtx);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"sample_action","file":"game.c","line_start":2103,"line_end":2111,"snippet":"  if (loaded) {\n    if (g_muze_model)\n      mu_model_free(g_muze_model);\n    g_muze_model = loaded;\n    g_muze_loop.model = g_muze_model;\n  }\n  pthread_mutex_unlock(&g_muze_model_mtx);\n  return 1;\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"transformer_seq_free","file":"game.c","line_start":2113,"line_end":2119,"snippet":"Color biome_colors[] = {\n    (Color){40, 120, 40, 255},   // grass\n    (Color){140, 140, 140, 255}, // stone\n    (Color){200, 180, 80, 255},  // desert\n};\n\nColor mob_colors[] = {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vision_id_map_init_defaults","file":"game.c","line_start":2121,"line_end":2157,"snippet":"    RAYWHITE, // sheep\n    DARKGRAY, // skeleton\n    GREEN     // zombie\n};\n\nColor resource_colors[] = {\n    DARKGREEN, // tree\n    GRAY,      // rock\n    GOLD,      // gold\n    RED        // food\n};\n\n/* =======================\n   OBS BUFFER\n * ====================== */\nstatic inline void obs_init(ObsBuffer *o) {\n  o->capacity = 32;\n  o->size = 0;\n  o->data = malloc(sizeof(float) * o->capacity);\n}\n\nstatic inline void obs_push(ObsBuffer *o, float v) {\n  if (o->size >= o->capacity) {\n    o->capacity *= 2;\n    o->data = realloc(o->data, sizeof(float) * o->capacity);\n  }\n  o->data[o->size++] = v;\n}\n\nstatic inline void obs_free(ObsBuffer *o) {\n  free(o->data);\n  o->data = NULL;\n  o->size = o->capacity = 0;\n}\n/* =======================\n   HELPERS\n======================= */"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vision_id_agent","file":"game.c","line_start":2160,"line_end":2163,"snippet":"static inline float wrap_angle(float a) {\n  while (a > PI)\n    a -= 2.0f * PI;\n  while (a < -PI)"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vision_id_mob","file":"game.c","line_start":2164,"line_end":2168,"snippet":"    a += 2.0f * PI;\n  return a;\n}\n\nstatic inline float lerp_angle(float a, float b, float t) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vision_id_resource","file":"game.c","line_start":2169,"line_end":2172,"snippet":"  float d = wrap_angle(b - a);\n  return a + d * t;\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vision_id_base","file":"game.c","line_start":2173,"line_end":2180,"snippet":"static inline int wrap(int v) { return (v + WORLD_SIZE) % WORLD_SIZE; }\nstatic inline float randf(float a, float b) {\n  return a + (float)rand() / RAND_MAX * (b - a);\n}\n\nstatic inline uint32_t xorshift32(uint32_t *s) {\n  uint32_t x = *s;\n  x ^= x << 13;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"clamp01","file":"game.c","line_start":2182,"line_end":2188,"snippet":"  x ^= x << 5;\n  *s = x;\n  return x;\n}\n\nstatic float agent_rng01(void *ctx) {\n  Agent *a = (Agent *)ctx;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"clampf","file":"game.c","line_start":2190,"line_end":2192,"snippet":"  x = xorshift32(&x);\n  a->rng_state = x;\n  return (float)(x & 0xFFFFFFu) / (float)0x1000000u;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"clamp_local_to_chunk","file":"game.c","line_start":2194,"line_end":2198,"snippet":"\nstatic float loop_rng01(void *ctx) {\n  uint32_t *s = (uint32_t *)ctx;\n  uint32_t x = *s ? *s : 0x12345678u;\n  x ^= x << 13;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"player_fire_bow_charged","file":"game.c","line_start":2200,"line_end":2214,"snippet":"  x ^= x << 5;\n  *s = x;\n  return (float)(x & 0xFFFFFFu) / (float)0x1000000u;\n}\n\nstatic int sample_action(const float *pi, int n, float r) {\n  float c = 0.0f;\n  for (int i = 0; i < n; i++) {\n    c += pi[i];\n    if (r <= c)\n      return i;\n  }\n  return (n > 0) ? (n - 1) : 0;\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_bow_charge_fx","file":"game.c","line_start":2216,"line_end":2247,"snippet":"  if (!seq)\n    return;\n  for (size_t t = 0; t < T; t++)\n    free(seq[t]);\n  free(seq);\n}\n\nstatic void vision_id_map_init_defaults(void) {\n  // 0 = empty, 1 = self, 2/3 = agents (same/other tribe), then even/odd pairs\n  g_vision_id_map.self_id = 1;\n  g_vision_id_map.agent_same_id = 2;\n  g_vision_id_map.agent_other_id = 3;\n\n  g_vision_id_map.mob_stride = 2;\n  g_vision_id_map.res_stride = 2;\n  g_vision_id_map.base_stride = 2;\n\n  g_vision_id_map.mob_odd_hostile = 1;\n  g_vision_id_map.res_odd_variant = 1;\n  g_vision_id_map.base_odd_variant = 1;\n\n  g_vision_id_map.mob_base = 4;\n  g_vision_id_map.res_base = g_vision_id_map.mob_base;\n  g_vision_id_map.base_base = g_vision_id_map.mob_base;\n  g_vision_id_map.use_overrides = 1;\n\n  int next_id = 4;\n  for (int i = 0; i < MOB_COUNT; i++) {\n    g_vision_id_map.mob_even[i] = next_id++;\n    g_vision_id_map.mob_odd[i] = next_id++;\n  }\n  g_vision_id_map.res_base = next_id;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"is_night","file":"game.c","line_start":2249,"line_end":2252,"snippet":"    g_vision_id_map.res_even[i] = next_id++;\n    g_vision_id_map.res_odd[i] = next_id++;\n  }\n  g_vision_id_map.base_base = next_id;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"update_daynight","file":"game.c","line_start":2254,"line_end":2259,"snippet":"    g_vision_id_map.base_even[i] = next_id++;\n    g_vision_id_map.base_odd[i] = next_id++;\n  }\n\n  g_vision_id_max = next_id;\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_daynight_overlay","file":"game.c","line_start":2262,"line_end":2288,"snippet":"static inline int vision_id_agent(int same_tribe) {\n  return same_tribe ? g_vision_id_map.agent_same_id\n                    : g_vision_id_map.agent_other_id;\n}\nstatic inline int vision_id_mob(int mob_type, bool hostile) {\n  /* IDs encode class in the low bit:\n     - passive mobs start at 2 (type 0 -> 2)\n     - hostile mobs start at 3 (type 0 -> 3)\n     Each mob type gets its own pair: (2 + type*2) and (3 + type*2)\n  */\n  int base = 2 + mob_type * 2;\n  return hostile ? (base + 1) : base;\n}\nstatic inline int vision_id_resource(int res_type) {\n  /* Keep resources in their own ID range (>= 100) so they never collide with\n   * mobs/agents/self. */\n  return 100 + res_type;\n}\nstatic inline int vision_id_base(int tribe, int variant) {\n  if (g_vision_id_map.use_overrides && tribe >= 0 && tribe < TRIBE_COUNT) {\n    return variant ? g_vision_id_map.base_odd[tribe]\n                   : g_vision_id_map.base_even[tribe];\n  }\n  return g_vision_id_map.base_base + g_vision_id_map.base_stride * tribe +\n         (variant ? g_vision_id_map.base_odd_variant : 0);\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"player_attack_range","file":"game.c","line_start":2292,"line_end":2295,"snippet":"  if (x > 1.0f)\n    return 1.0f;\n  return x;\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"player_attack_damage","file":"game.c","line_start":2297,"line_end":2299,"snippet":"static inline float clampf(float v, float a, float b) {\n  return (v < a) ? a : (v > b) ? b : v;\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"player_attack_cooldown","file":"game.c","line_start":2301,"line_end":2303,"snippet":"static inline Vector2 clamp_local_to_chunk(Vector2 lp) {\n  lp.x = clampf(lp.x, 0.25f, (float)CHUNK_SIZE - 0.25f);\n  lp.y = clampf(lp.y, 0.25f, (float)CHUNK_SIZE - 0.25f);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"player_resource_damage","file":"game.c","line_start":2305,"line_end":2319,"snippet":"}\n\nstatic void player_fire_bow_charged(Vector2 dir, float charge01) {\n  charge01 = clamp01(charge01);\n\n  float spd = lerp(BOW_SPEED_MIN, BOW_SPEED_MAX, charge01);\n  float ttl = lerp(BOW_TTL_MIN, BOW_TTL_MAX, charge01);\n\n  int dmg = (int)roundf(lerp((float)BOW_DMG_MIN, (float)BOW_DMG_MAX, charge01));\n  if (has_sword)\n    dmg += 4; // keep your upgrade synergy if you want\n\n  spawn_projectile(player.position, dir, spd, ttl, dmg, PROJ_OWNER_PLAYER);\n\n  // tiny feedback"},
  {"kind":"fn_def","vis":"PRIVATE","name":"player_resource_cooldown","file":"game.c","line_start":2321,"line_end":2329,"snippet":"}\n\nstatic void draw_bow_charge_fx(void) {\n  if (!bow_charging || !has_bow)\n    return;\n\n  // bowstring between hands\n  DrawLineEx(g_handL, g_handR, 3.0f, (Color){20, 20, 20, 180});"},
  {"kind":"fn_def","vis":"PRIVATE","name":"player_resource_stamina_cost","file":"game.c","line_start":2331,"line_end":2339,"snippet":"  float r = 26.0f;\n  draw_circle_outline_opengl(g_handR.x, g_handR.y, r, (Color){255, 255, 255, 140});\n\n  // progress arc (simple: draw a few small segments)\n  int segs = 22;\n  float a0 = -PI / 2.0f;\n  float a1 = a0 + (2.0f * PI * bow_charge01);\n  for (int i = 0; i < segs; i++) {\n    float t0 = (float)i / (float)segs;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"agent_in_base","file":"game.c","line_start":2341,"line_end":2344,"snippet":"    float aa0 = lerp(a0, a1, t0);\n    float aa1 = lerp(a0, a1, t1);\n\n    Vector2 p0 ="},
  {"kind":"fn_def","vis":"PRIVATE","name":"agent_try_general_craft","file":"game.c","line_start":2346,"line_end":2437,"snippet":"    Vector2 p1 =\n        (Vector2){g_handR.x + cosf(aa1) * r, g_handR.y + sinf(aa1) * r};\n    draw_line_opengl(p0.x, p0.y, p1.x, p1.y, 3.0f, (Color){255, 220, 120, 220});\n  }\n\n  // tiny text\n  DrawText(TextFormat(\"Charge %d%%\", (int)(bow_charge01 * 100.0f)),\n           (int)g_handR.x + 18, (int)g_handR.y - 42, 14, RAYWHITE);\n}\n\nstatic inline int is_night(void) {\n  // night from ~0.75 -> 1.0 and 0.0 -> 0.25 (tweak)\n  return (time_of_day >= 0.75f || time_of_day <= 0.25f);\n}\n\nstatic void update_daynight(float dt) {\n  time_of_day += dt / day_length_seconds;\n  while (time_of_day >= 1.0f)\n    time_of_day -= 1.0f;\n  is_night_cached = is_night();\n}\n\n// a simple overlay (dark at night)\nstatic void draw_daynight_overlay(void) {\n  float t = time_of_day;\n\n  // how dark is it curve: darkest at midnight, brightest at noon\n  // (0 at noon, 1 at midnight)\n  float midnight_dist = fabsf(t - 0.0f);\n  midnight_dist = fminf(midnight_dist, fabsf(t - 1.0f));\n  float noon_dist = fabsf(t - 0.5f);\n\n  // 0..1 where 1 is midnight-ish\n  float night01 = clamp01((0.5f - noon_dist) * 2.0f);\n  night01 = 1.0f - night01;\n\n  unsigned char a = (unsigned char)(150 * night01); // max darkness alpha\n  // OpenGL equivalent of DrawRectangle - temporarily commented out\n  // glBegin(GL_QUADS);\n  // glColor4f(10.0f/255.0f, 20.0f/255.0f, 40.0f/255.0f, a/255.0f);\n  // glVertex2f(0, 0);\n  // glVertex2f(SCREEN_WIDTH, 0);\n  // glVertex2f(SCREEN_WIDTH, SCREEN_HEIGHT);\n  // glVertex2f(0, SCREEN_HEIGHT);\n  // glVertex2f(0, 0);\n  // glEnd();\n\n  DrawText(is_night_cached ? \"Night\" : \"Day\", 20, 210, 20, RAYWHITE);\n  DrawText(TextFormat(\"Time: %0.2f\", time_of_day), 20, 235, 18, RAYWHITE);\n}\n\nstatic inline float px(float base) { return base * WORLD_SCALE * scale_size; }\n\nstatic inline float player_attack_range(void) {\n  // sword gives a bit more reach\n  return ATTACK_DISTANCE + (has_sword ? 0.55f : 0.0f);\n}\n\nstatic inline int player_attack_damage(void) {\n  return PLAYER_ATTACK_DAMAGE + (has_sword ? 10 : 0);\n}\n\nstatic inline float player_attack_cooldown(void) {\n  return PLAYER_ATTACK_COOLDOWN * (has_sword ? 0.88f : 1.0f);\n}\n\nstatic inline int player_resource_damage(ResourceType t) {\n  // tree prefers axe\n  if (t == RES_TREE)\n    return PLAYER_HARVEST_DAMAGE + (has_axe ? 18 : 0);\n\n  // rocks/gold prefer pickaxe\n  if (t == RES_ROCK || t == RES_GOLD)\n    return PLAYER_MINE_DAMAGE + (has_pickaxe ? 16 : 0);\n\n  // food is harvestable\n  if (t == RES_FOOD)\n    return PLAYER_HARVEST_DAMAGE;\n\n  return PLAYER_HARVEST_DAMAGE;\n}\n\nstatic inline float player_resource_cooldown(ResourceType t) {\n  if (t == RES_TREE)\n    return PLAYER_HARVEST_COOLDOWN * (has_axe ? 0.75f : 1.0f);\n  if (t == RES_ROCK || t == RES_GOLD)\n    return PLAYER_MINE_COOLDOWN * (has_pickaxe ? 0.78f : 1.0f);\n  if (t == RES_FOOD)\n    return PLAYER_HARVEST_COOLDOWN;\n  return PLAYER_HARVEST_COOLDOWN;\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"ensure_agents_ready_on_enter","file":"game.c","line_start":2538,"line_end":2558,"snippet":"  }\n\n  // Nothing to craft\n  if (reward)\n    *reward += -0.002f;\n  return 0;\n}\n\nstatic int agent_try_craft_action(Agent *a, Tribe *tr, ActionType craft_action,\n                                  float *reward) {\n  if (!agent_in_base(a, tr)) {\n    if (reward)\n      *reward += -0.006f;\n    return 0;\n  }\n\n  // Helper macro: spend if possible\n#define TRY_CRAFT(cond_have, w, s, g, f, on_success)                           \\\n  do {                                                                         \\\n    if (cond_have) {                                                           \\\n      if (reward)                                                              \\"},
  {"kind":"fn_def","vis":"PRIVATE","name":"update_projectiles","file":"game.c","line_start":2576,"line_end":2670,"snippet":"  } while (0)\n\n  switch (craft_action) {\n  case ACTION_CRAFT_AXE:\n    TRY_CRAFT(a->has_axe, 3, 2, 0, 0, {\n      a->has_axe = true;\n      a->last_craft_selected = TOOL_AXE;\n    });\n    break;\n\n  case ACTION_CRAFT_PICKAXE:\n    TRY_CRAFT(a->has_pickaxe, 3, 3, 0, 0, {\n      a->has_pickaxe = true;\n      a->last_craft_selected = TOOL_PICKAXE;\n    });\n    break;\n\n  case ACTION_CRAFT_SWORD:\n    TRY_CRAFT(a->has_sword, 0, 4, 2, 0, {\n      a->has_sword = true;\n      a->last_craft_selected = TOOL_SWORD;\n    });\n    break;\n\n  case ACTION_CRAFT_ARMOR:\n    TRY_CRAFT(a->has_armor, 0, 5, 2, 0, {\n      a->has_armor = true;\n      a->last_craft_selected = TOOL_ARMOR;\n    });\n    break;\n\n  case ACTION_CRAFT_BOW:\n    TRY_CRAFT(a->has_bow, 4, 0, 1, 0, {\n      a->has_bow = true;\n      a->last_craft_selected = TOOL_BOW;\n    });\n    break;\n\n  case ACTION_CRAFT_ARROWS:\n    // explicit ammo craft (no oh you probably need ammo)\n    if (tr->shards < 1 || tr->wood < 1) {\n      if (reward)\n        *reward += -0.003f;\n      return 0;\n    }\n    tr->shards -= 1;\n    tr->wood -= 1;\n    {\n      int made = 6;\n      tr->arrows += made;\n      a->inv_arrows += made;\n    }\n    if (reward)\n      *reward += 0.06f;\n    return 1;\n\n  default:\n    if (reward)\n      *reward += -0.003f;\n    return 0;\n  }\n\n  if (reward)\n    *reward += -0.003f;\n  return 0;\n\n#undef TRY_CRAFT\n}\n\nstatic void ensure_agents_ready_on_enter(void) {\n  int alive = 0;\n  for (int i = 0; i < MAX_AGENTS; i++) {\n    if (agents[i].alive)\n      alive++;\n  }\n  if (alive == 0) {\n    init_agents();\n  }\n  for (int i = 0; i < MAX_AGENTS; i++) {\n    if (agents[i].rng_state == 0) {\n      agents[i].rng_state =\n          (uint32_t)time(NULL) ^ (0x9e3779b9u * (uint32_t)(i + 1));\n    }\n  }\n\n  // Initialize 3D renderer when entering gameplay\n  if (g_use_3d && !g_3d_ready) {\n    init_3d_renderer();\n  }\n}\n\nstatic void spawn_projectile(Vector2 pos, Vector2 dir, float speed, float ttl,\n                             int dmg, ProjOwner owner) {\n  for (int i = 0; i < MAX_PROJECTILES; i++) {\n    if (!projectiles[i].alive) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"world_to_screen","file":"game.c","line_start":2672,"line_end":2682,"snippet":"      projectiles[i].pos = pos;\n      projectiles[i].vel = Vector2Scale(Vector2Normalize(dir), speed);\n      projectiles[i].ttl = ttl;\n      projectiles[i].damage = dmg;\n      projectiles[i].owner = owner;\n      projectiles[i].owner_agent_id = -1;\n      return;\n    }\n  }\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_projectiles","file":"game.c","line_start":2684,"line_end":2695,"snippet":"  for (int i = 0; i < MAX_PROJECTILES; i++) {\n    Projectile *p = &projectiles[i];\n    if (!p->alive)\n      continue;\n\n    p->ttl -= dt;\n    if (p->ttl <= 0.0f) {\n      p->alive = false;\n      continue;\n    }\n\n    p->pos = Vector2Add(p->pos, Vector2Scale(p->vel, dt));"},
  {"kind":"fn_def","vis":"PRIVATE","name":"agent_move_speed","file":"game.c","line_start":2699,"line_end":2702,"snippet":"    // ---------------------------\n    if (p->owner == PROJ_OWNER_MOB) {\n      float d = Vector2Distance(p->pos, player.position);\n      if (d < 0.55f) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"agent_harvest_cost","file":"game.c","line_start":2711,"line_end":2719,"snippet":"      for (int aidx = 0; aidx < MAX_AGENTS; aidx++) {\n        Agent *a = &agents[aidx];\n        if (!a->alive)\n          continue;\n        if (Vector2Distance(p->pos, a->position) < 0.55f) {\n          a->health -= (float)p->damage;\n          a->flash_timer = 0.18f;\n          p->alive = false;\n          cam_shake = fmaxf(cam_shake, 0.08f);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"agent_harvest_damage","file":"game.c","line_start":2721,"line_end":2729,"snippet":"        }\n      }\n      if (!p->alive)\n        continue;\n    }\n\n    // -----------------------------------\n    // PLAYER/AGENT projectiles: hit mobs\n    // -----------------------------------"},
  {"kind":"fn_def","vis":"PRIVATE","name":"mob_is_hostile","file":"game.c","line_start":2731,"line_end":2733,"snippet":"      int cx = (int)(p->pos.x / CHUNK_SIZE);\n      int cy = (int)(p->pos.y / CHUNK_SIZE);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"agent_try_move","file":"game.c","line_start":2735,"line_end":2774,"snippet":"      for (int dx = -1; dx <= 1 && p->alive; dx++) {\n        for (int dy = -1; dy <= 1 && p->alive; dy++) {\n          Chunk *c = get_chunk(cx + dx, cy + dy);\n\n          pthread_rwlock_wrlock(&c->lock);\n\n          Vector2 origin = (Vector2){(float)((cx + dx) * CHUNK_SIZE),\n                                     (float)((cy + dy) * CHUNK_SIZE)};\n\n          for (int mi = 0; mi < MAX_MOBS; mi++) {\n            Mob *m = &c->mobs[mi];\n            if (m->health <= 0)\n              continue;\n\n            Vector2 mw = Vector2Add(origin, m->position);\n            float mr = mob_radius_world(m->type);\n\n            // projectile collision radius ~ small\n            if (Vector2Distance(p->pos, mw) < (mr * 0.85f)) {\n              m->health -= p->damage;\n              m->hurt_timer = 0.18f;\n              m->aggro_timer = 3.0f;\n\n              p->alive = false;\n              cam_shake = fmaxf(cam_shake, 0.08f);\n\n              if (m->health <= 0) {\n                Vector2 mob_world_pos =\n                    (Vector2){(float)((cx + dx) * CHUNK_SIZE) + m->position.x,\n                              (float)((cy + dy) * CHUNK_SIZE) + m->position.y};\n                on_mob_killed(m->type, mob_world_pos);\n                m->health = 0;\n              }\n              break;\n            }\n          }\n\n          pthread_rwlock_unlock(&c->lock);\n        }\n      }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"agent_gain_loot_for_mob_kill","file":"game.c","line_start":2776,"line_end":2792,"snippet":"  }\n}\n\nstatic inline Vector2 world_to_screen(Vector2 wp) {\n  // Use current screen dimensions, not cached ones\n  int current_w, current_h;\n  SDL_GetWindowSize(g_window, &current_w, &current_h);\n\n  Vector2 sp = Vector2Subtract(wp, camera_pos);\n  sp = Vector2Scale(sp, WORLD_SCALE);\n  sp.x += current_w / 2;\n  sp.y += current_h / 2;\n  return sp;\n}\n\nstatic void draw_projectiles(void) {\n  for (int i = 0; i < MAX_PROJECTILES; i++) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"raycast_world_objects","file":"game.c","line_start":2815,"line_end":2898,"snippet":"static inline float agent_harvest_cooldown(void) { return 0.28f; }\nstatic inline float agent_fire_cooldown(void) { return 0.85f; }\n\nstatic inline float agent_harvest_cost(ResourceType t) {\n  if (t == RES_ROCK || t == RES_GOLD)\n    return 3.0f;\n  if (t == RES_TREE)\n    return 2.0f;\n  if (t == RES_FOOD)\n    return 1.2f;\n  return 2.0f;\n}\n\nstatic inline int agent_harvest_damage(ResourceType t) {\n  if (t == RES_ROCK || t == RES_GOLD)\n    return 14;\n  if (t == RES_TREE)\n    return 12;\n  if (t == RES_FOOD)\n    return 10;\n  return 10;\n}\n\nstatic inline int mob_is_hostile(MobType t) {\n  return (t == MOB_ZOMBIE || t == MOB_SKELETON);\n}\n\nstatic void agent_try_move(Agent *a, Vector2 dir) {\n  // dir is expected to be -1/0/1 style\n  float dt = g_dt;\n  float spd = agent_move_speed();\n\n  float len = Vector2Length(dir);\n  if (len < 1e-6f)\n    return;\n  dir = Vector2Scale(dir, 1.0f / len);\n\n  Vector2 old = a->position;\n  Vector2 next = Vector2Add(a->position, Vector2Scale(dir, spd * dt));\n\n  // simple blocked test (uses generated chunks + locks safely)\n  int cx = (int)(next.x / CHUNK_SIZE);\n  int cy = (int)(next.y / CHUNK_SIZE);\n\n  if (world_pos_blocked_nearby(cx, cy, next, agent_radius_world(), -999999,\n                               -999999)) {\n    // try a tiny slide in x or y\n    Vector2 tryX = (Vector2){next.x, old.y};\n    Vector2 tryY = (Vector2){old.x, next.y};\n\n    int cxX = (int)(tryX.x / CHUNK_SIZE);\n    int cyX = (int)(tryX.y / CHUNK_SIZE);\n    int cxY = (int)(tryY.x / CHUNK_SIZE);\n    int cyY = (int)(tryY.y / CHUNK_SIZE);\n\n    if (!world_pos_blocked_nearby(cxX, cyX, tryX, agent_radius_world(), -999999,\n                                  -999999))\n      a->position = tryX;\n    else if (!world_pos_blocked_nearby(cxY, cyY, tryY, agent_radius_world(),\n                                       -999999, -999999))\n      a->position = tryY;\n    else\n      a->position = old;\n  } else {\n    a->position = next;\n  }\n}\n\nstatic void agent_gain_loot_for_mob_kill(Agent *a, Tribe *tr, MobType t) {\n  if (t == MOB_PIG || t == MOB_SHEEP) {\n    int f = 1 + (rand() % 2);\n    a->inv_food += f;\n    tr->food += f;\n  } else if (t == MOB_ZOMBIE) {\n    int s = 1 + (rand() % 3);\n    a->inv_shards += s;\n    tr->shards += s;\n  } else if (t == MOB_SKELETON) {\n    int arr = 2 + (rand() % 3);\n    a->inv_arrows += arr;\n    tr->arrows += arr;\n    a->inv_shards += 1;\n    tr->shards += 1;\n  }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"agent_try_attack_forward","file":"game.c","line_start":2900,"line_end":2959,"snippet":"\nstatic inline int ray_circle_intersect(Vector2 ro, Vector2 rd, Vector2 c,\n                                       float r, float *out_t) {\n  // rd must be normalized\n  Vector2 oc = Vector2Subtract(ro, c);\n  float b = Vector2DotProduct(oc, rd);\n  float cc = Vector2DotProduct(oc, oc) - r * r;\n  float disc = b * b - cc;\n  if (disc < 0.0f)\n    return 0;\n  float s = sqrtf(disc);\n  float t0 = -b - s;\n  float t1 = -b + s;\n\n  float t = (t0 > 1e-4f) ? t0 : ((t1 > 1e-4f) ? t1 : -1.0f);\n  if (t < 0.0f)\n    return 0;\n\n  *out_t = t;\n  return 1;\n}\n\nstatic RayHit raycast_world_objects(Vector2 ro, Vector2 rd, float maxT) {\n  RayHit best = {0};\n  best.kind = HIT_NONE;\n  best.t = maxT;\n\n  // check bases (global, cheap)\n  for (int t = 0; t < TRIBE_COUNT; t++) {\n    float thit = 0.0f;\n    if (ray_circle_intersect(ro, rd, tribes[t].base.position,\n                             tribes[t].base.radius, &thit)) {\n      if (thit < best.t && thit <= maxT) {\n        best.kind = HIT_BASE;\n        best.t = thit;\n        best.index = t;\n        best.hit_pos = Vector2Add(ro, Vector2Scale(rd, thit));\n      }\n    }\n  }\n\n  // check nearby chunks (3x3 around ray origin chunk)\n  int ocx = (int)(ro.x / CHUNK_SIZE);\n  int ocy = (int)(ro.y / CHUNK_SIZE);\n\n  for (int dx = -1; dx <= 1; dx++) {\n    for (int dy = -1; dy <= 1; dy++) {\n      int cx = ocx + dx;\n      int cy = ocy + dy;\n\n      Chunk *c = get_chunk(cx, cy);\n      pthread_rwlock_rdlock(&c->lock);\n\n      Vector2 origin =\n          (Vector2){(float)(cx * CHUNK_SIZE), (float)(cy * CHUNK_SIZE)};\n\n      // resources (circles)\n      for (int i = 0; i < c->resource_count; i++) {\n        Resource *r = &c->resources[i];\n        if (r->health <= 0)"},
  {"kind":"fn_def","vis":"PRIVATE","name":"agent_try_harvest_forward","file":"game.c","line_start":2961,"line_end":3047,"snippet":"\n        Vector2 cw = Vector2Add(origin, r->position);\n        float rr = res_radius_world(r->type);\n\n        float thit = 0.0f;\n        if (ray_circle_intersect(ro, rd, cw, rr, &thit)) {\n          if (thit < best.t && thit <= maxT) {\n            best.kind = HIT_RESOURCE;\n            best.t = thit;\n            best.cx = cx;\n            best.cy = cy;\n            best.index = i;\n            best.hit_pos = Vector2Add(ro, Vector2Scale(rd, thit));\n          }\n        }\n      }\n\n      // mobs (circles)\n      for (int i = 0; i < MAX_MOBS; i++) {\n        Mob *m = &c->mobs[i];\n        if (m->health <= 0)\n          continue;\n\n        Vector2 mw = Vector2Add(origin, m->position);\n        float mr = mob_radius_world(m->type);\n\n        float thit = 0.0f;\n        if (ray_circle_intersect(ro, rd, mw, mr, &thit)) {\n          if (thit < best.t && thit <= maxT) {\n            best.kind = HIT_MOB;\n            best.t = thit;\n            best.cx = cx;\n            best.cy = cy;\n            best.index = i;\n            best.hit_pos = Vector2Add(ro, Vector2Scale(rd, thit));\n          }\n        }\n      }\n\n      pthread_rwlock_unlock(&c->lock);\n    }\n  }\n\n  return best;\n}\n\nstatic int agent_try_attack_forward(Agent *a, Tribe *tr, float *reward) {\n  (void)tr;\n\n  if (a->attack_cd > 0.0f) {\n    *reward += R_ATTACK_WASTE * 0.25f; // tiny slap for spamming on cooldown\n    return 0;\n  }\n\n  Vector2 ro = a->position;\n  Vector2 rd = Vector2Normalize(a->facing);\n  if (Vector2Length(rd) < 1e-3f)\n    rd = (Vector2){1, 0};\n\n  bool using_sword = (a->tool_selected == TOOL_SWORD) && a->has_sword;\n  float range = agent_attack_range() + (using_sword ? 0.45f : 0.0f);\n  int dmg = agent_attack_damage() + (using_sword ? 10 : 0);\n\n  RayHit hit = raycast_world_objects(ro, rd, range);\n\n  if (hit.kind != HIT_MOB) {\n    // wasted swing into air\n    a->attack_cd = agent_attack_cooldown() * 0.35f; // small whiff cooldown\n    *reward += R_ATTACK_WASTE;\n    return 0;\n  }\n\n  Chunk *c = get_chunk(hit.cx, hit.cy);\n  pthread_rwlock_wrlock(&c->lock);\n\n  Mob *m = &c->mobs[hit.index];\n  if (m->health > 0) {\n    a->attack_cd = agent_attack_cooldown();\n\n    m->health -= dmg;\n    m->hurt_timer = 0.18f;\n    m->aggro_timer = 3.0f;\n    m->lunge_timer = 0.10f;\n\n    *reward += R_ATTACK_HIT;\n\n    if (m->health <= 0) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"agent_try_eat","file":"game.c","line_start":3083,"line_end":3102,"snippet":"  RayHit hit = raycast_world_objects(ro, rd, range);\n  if (hit.kind != HIT_RESOURCE) {\n    // wasted harvest swing\n    a->harvest_cd = agent_harvest_cooldown() * 0.35f; // small whiff cooldown\n    *reward += R_HARVEST_WASTE;\n    return 0;\n  }\n\n  Chunk *c = get_chunk(hit.cx, hit.cy);\n  pthread_rwlock_wrlock(&c->lock);\n\n  Resource *r = &c->resources[hit.index];\n  if (r->health <= 0) {\n    pthread_rwlock_unlock(&c->lock);\n    *reward += R_HARVEST_WASTE * 0.5f;\n    return 0;\n  }\n\n  float cost = agent_harvest_cost(r->type);\n  if (r->type == RES_TREE && using_axe)"},
  {"kind":"fn_def","vis":"PRIVATE","name":"tribe_try_repair_base","file":"game.c","line_start":3104,"line_end":3116,"snippet":"  if ((r->type == RES_ROCK || r->type == RES_GOLD) && using_pick)\n    cost *= 0.78f;\n\n  if (a->stamina < cost) {\n    pthread_rwlock_unlock(&c->lock);\n    *reward += R_HARVEST_NO_STAMINA;\n    return 0;\n  }\n\n  a->harvest_cd = agent_harvest_cooldown();\n  a->stamina -= cost;\n\n  int dmg = agent_harvest_damage(r->type);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"spawn_pickup","file":"game.c","line_start":3118,"line_end":3130,"snippet":"    dmg += 10;\n  if ((r->type == RES_ROCK || r->type == RES_GOLD) && using_pick)\n    dmg += 14;\n\n  r->health -= dmg;\n  r->hit_timer = 0.14f;\n  r->break_flash = 0.06f;\n\n  *reward += R_HARVEST_HIT;\n\n  if (r->health <= 0) {\n    r->health = 0;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"give_pickup","file":"game.c","line_start":3132,"line_end":3148,"snippet":"    case RES_TREE:\n      tr->wood += 1;\n      break;\n    case RES_ROCK:\n      tr->stone += 1;\n      break;\n    case RES_GOLD:\n      tr->gold += 1;\n      break;\n    case RES_FOOD:\n      a->inv_food += 1;\n      tr->food += 1;\n      break;\n    default:\n      break;\n    }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"update_pickups","file":"game.c","line_start":3150,"line_end":3160,"snippet":"  }\n\n  pthread_rwlock_unlock(&c->lock);\n  return 1;\n}\n\nstatic void agent_try_fire_forward(Agent *a, float *reward,\n                                   bool is_continuous) {\n  if (!a->has_bow) {\n    if (reward)\n      *reward += -0.006f;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"collect_nearby_pickups","file":"game.c","line_start":3162,"line_end":3172,"snippet":"  }\n\n  if (a->fire_cd > 0.0f) {\n    if (!is_continuous && reward)\n      *reward += R_FIRE_WASTE * 0.10f;\n    return;\n  }\n\n  if (a->inv_arrows <= 0) {\n    if (reward)\n      *reward += R_FIRE_NO_AMMO;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"ui_nearest_base_pos","file":"game.c","line_start":3174,"line_end":3185,"snippet":"  }\n\n  Vector2 rd = Vector2Normalize(a->facing);\n  if (Vector2Length(rd) < 1e-3f)\n    rd = (Vector2){1, 0};\n\n  // consume + spawn; outcome handled by projectile collision only\n  a->inv_arrows--;\n  a->fire_cd = agent_fire_cooldown();\n\n  spawn_projectile(a->position, rd, 13.0f, 1.65f, 10, PROJ_OWNER_AGENT);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_pickups","file":"game.c","line_start":3187,"line_end":3236,"snippet":"  if (reward && !is_continuous)\n    *reward += -0.002f;\n}\nstatic void agent_try_eat(Agent *a, float *reward) {\n  if (a->inv_food <= 0) {\n    *reward += R_EAT_NO_FOOD;\n    return;\n  }\n\n  // if basically full, it's waste\n  if (a->health > 92.0f && a->stamina > 75.0f) {\n    a->inv_food--; // still consumes -> true waste punishment\n    *reward += R_EAT_WASTE;\n    return;\n  }\n\n  a->inv_food--;\n\n  a->health = fminf(100.0f, a->health + 18.0f);\n  a->stamina = fminf(100.0f, a->stamina + 32.0f);\n\n  *reward += R_EAT_GOOD;\n}\n\nstatic void tribe_try_repair_base(Tribe *tr, float *reward) {\n  // simple repair rule: if damaged, spend mats to repair slowly\n  if (tr->integrity >= 99.9f)\n    return;\n\n  // spend 1 wood + 1 stone for +6 integrity\n  if (tr->wood >= 1 && tr->stone >= 1) {\n    tr->wood -= 1;\n    tr->stone -= 1;\n    tr->integrity = fminf(100.0f, tr->integrity + 6.0f);\n    *reward += 0.08f;\n  }\n}\n\nstatic void spawn_pickup(PickupType type, Vector2 pos, int amount) {\n  for (int i = 0; i < MAX_PICKUPS; i++) {\n    if (!pickups[i].alive) {\n      pickups[i].alive = true;\n      pickups[i].pos = pos;\n      pickups[i].type = type;\n      pickups[i].amount = amount;\n      pickups[i].ttl = 30.0f;\n      pickups[i].bob_t = randf(0.0f, 10.0f);\n      return;\n    }\n  }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"on_mob_killed","file":"game.c","line_start":3238,"line_end":3252,"snippet":"\nstatic void give_pickup(PickupType t, int amount) {\n  if (amount <= 0)\n    return;\n  switch (t) {\n  case PICK_FOOD:\n    inv_food += amount;\n    break;\n  case PICK_SHARD:\n    inv_shards += amount;\n    break;\n  case PICK_ARROW:\n    inv_arrows += amount;\n    break;\n  default:"},
  {"kind":"fn_def","vis":"PRIVATE","name":"give_drop","file":"game.c","line_start":3254,"line_end":3271,"snippet":"  }\n}\n\nstatic void update_pickups(float dt) {\n  for (int i = 0; i < MAX_PICKUPS; i++) {\n    Pickup *p = &pickups[i];\n    if (!p->alive)\n      continue;\n    p->ttl -= dt;\n    p->bob_t += dt;\n    if (p->ttl <= 0.0f)\n      p->alive = false;\n  }\n}\n\nstatic void collect_nearby_pickups(void) {\n  for (int i = 0; i < MAX_PICKUPS; i++) {\n    Pickup *p = &pickups[i];"},
  {"kind":"fn_def","vis":"PRIVATE","name":"safe_norm","file":"game.c","line_start":3303,"line_end":3305,"snippet":"    float bob = sinf(p->bob_t * 5.0f) * (s * 0.35f);\n    sp.y += bob;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"obs_finalize_fixed","file":"game.c","line_start":3309,"line_end":3318,"snippet":"\n    switch (p->type) {\n    case PICK_FOOD: {\n      draw_circle_filled_opengl(sp.x, sp.y, s * 0.75f, (Color){220, 60, 60, 255});\n      draw_circle_outline_opengl(sp.x, sp.y, s * 0.75f, (Color){0, 0, 0, 160});\n      draw_triangle_opengl((Vector2){sp.x, sp.y - s * 0.9f},\n                   (Vector2){sp.x - s * 0.35f, sp.y - s * 1.25f},\n                   (Vector2){sp.x + s * 0.35f, sp.y - s * 1.25f},\n                   (Color){40, 180, 60, 255});\n    } break;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"mob_too_close_local","file":"game.c","line_start":3567,"line_end":3576,"snippet":"    int ocx = (int)(o->position.x / CHUNK_SIZE);\n    int ocy = (int)(o->position.y / CHUNK_SIZE);\n    int cx = (int)(a->position.x / CHUNK_SIZE);\n    int cy = (int)(a->position.y / CHUNK_SIZE);\n    if (ocx != cx || ocy != cy)\n      continue;\n    int tribe = o->agent_id / AGENT_PER_TRIBE;\n    int idv = vision_id_agent(tribe == my_tribe);\n    float sizev = agent_radius_world();\n    float eh = g_use_perlin_ground"},
  {"kind":"fn_def","vis":"PRIVATE","name":"chunk_alive_mobs","file":"game.c","line_start":3578,"line_end":3584,"snippet":"                   : 0.0f;\n    STAMP_ENTITY(o->position, sizev, 4, idv, 1, sizev,\n                 (float)tribe / (float)(TRIBE_COUNT - 1), eh + sizev);\n  }\n\n  // mobs\n  for (int i = 0; i < MAX_MOBS; i++) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"find_free_mob_slot","file":"game.c","line_start":3586,"line_end":3591,"snippet":"    if (m->health <= 0)\n      continue;\n    Vector2 world_pos = Vector2Add(chunk_origin, m->position);\n    int hostile = mob_is_hostile(m->type) ? 1 : 0;\n    int idv = vision_id_mob(m->type, hostile);\n    float eh ="},
  {"kind":"fn_def","vis":"PRIVATE","name":"pick_spawn_type","file":"game.c","line_start":3593,"line_end":3603,"snippet":"    float sizev = mob_radius_world(m->type);\n    STAMP_ENTITY(world_pos, sizev, 3, idv, 2, sizev,\n                 (float)m->type / (float)(MOB_COUNT - 1), eh + sizev);\n  }\n\n  // resources\n  for (int i = 0; i < c->resource_count; i++) {\n    Resource *r = &c->resources[i];\n    if (r->health <= 0)\n      continue;\n    Vector2 world_pos = Vector2Add(chunk_origin, r->position);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"init_mob","file":"game.c","line_start":3605,"line_end":3617,"snippet":"    float eh =\n        g_use_perlin_ground ? terrain_height(world_pos.x, world_pos.y) : 0.0f;\n    float sizev = res_radius_world(r->type);\n    STAMP_ENTITY(world_pos, sizev, 2, idv, 3, sizev,\n                 (float)r->type / (float)(RES_COUNT - 1), eh + sizev);\n  }\n\n  // bases\n  for (int t = 0; t < TRIBE_COUNT; t++) {\n    Vector2 bp = tribes[t].base.position;\n    int bcx = (int)(bp.x / CHUNK_SIZE);\n    int bcy = (int)(bp.y / CHUNK_SIZE);\n    int cx = (int)(a->position.x / CHUNK_SIZE);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"try_spawn_mobs_in_chunk","file":"game.c","line_start":3619,"line_end":3667,"snippet":"    if (bcx != cx || bcy != cy)\n      continue;\n    int idv = vision_id_base(t, 0);\n    float eh = g_use_perlin_ground ? terrain_height(bp.x, bp.y) : 0.0f;\n    float sizev = tribes[t].base.radius;\n    STAMP_ENTITY(bp, sizev, 1, idv, 4, sizev,\n                 (float)t / (float)(TRIBE_COUNT - 1), eh + sizev);\n  }\n\n#undef STAMP_ENTITY\n\n  size_t max_tokens = (size_t)OBS_GRID_W * (size_t)OBS_GRID_H;\n  size_t token_count =\n      (g_obs_token_count < max_tokens) ? g_obs_token_count : max_tokens;\n\n  for (int gz = 0; gz < OBS_GRID_H; gz++) {\n    for (int gx = 0; gx < OBS_GRID_W; gx++) {\n      size_t tidx = (size_t)gz * (size_t)OBS_GRID_W + (size_t)gx;\n      if (tidx >= token_count)\n        continue;\n      long double *tok = g_obs_tokens[tidx];\n\n      size_t idx = tidx;\n      float h = cell_height[idx];\n      int hbin = (int)clampf(h / hstep, 0.0f, (float)(OBS_HEIGHT_BINS - 1));\n      float nx = ((float)gx + 0.5f) / (float)OBS_GRID_W;\n      float nz = ((float)gz + 0.5f) / (float)OBS_GRID_H;\n      float dist01 = clamp01(cell_dist[idx] / (float)CHUNK_SIZE);\n      float size01 = clamp01(cell_size[idx] / size_norm_max);\n      float id_norm =\n          (id_max > 0) ? ((float)cell_id[idx] / (float)id_max) : 0.0f;\n      float class_norm = (float)cell_class[idx] / 4.0f;\n      float hcell01 = clamp01(h / hmax);\n      float hent01 = clamp01(cell_ent_h[idx] / hmax);\n\n      tok[0] = (long double)id_norm;\n      tok[1] = (long double)class_norm;\n      tok[2] = (long double)cell_shape[idx];\n      tok[3] = (long double)size01;\n      tok[4] = (long double)hent01;\n      tok[5] = (long double)hcell01;\n      tok[6] = (long double)((nx * 2.0f) - 1.0f);\n      tok[7] = (long double)((nz * 2.0f) - 1.0f);\n      tok[8] = (long double)dist01;\n      tok[9] = (long double)((OBS_HEIGHT_BINS > 1)\n                                 ? ((float)hbin / (float)(OBS_HEIGHT_BINS - 1))\n                                 : 0.0f);\n      tok[10] =\n          (long double)clampf((cell_ent_h[idx] - agent_h) / 6.0f, -1.0f, 1.0f);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"player_try_attack_forward","file":"game.c","line_start":3669,"line_end":3720,"snippet":"      tok[15] = 1.0L;\n    }\n  }\n}\n\n/* =======================\n   WORLD\n======================= */\nstatic inline int mob_is_alive(const Mob *m) { return m->health > 0; }\n\nstatic int mob_too_close_local(const Chunk *c, Vector2 p, float minD) {\n  for (int i = 0; i < MAX_MOBS; i++) {\n    const Mob *m = &c->mobs[i];\n    if (!mob_is_alive(m))\n      continue;\n    if (Vector2Distance(m->position, p) < minD)\n      return 1;\n  }\n  return 0;\n}\n\nstatic int chunk_alive_mobs(Chunk *c) {\n  int n = 0;\n  for (int i = 0; i < MAX_MOBS; i++)\n    if (c->mobs[i].health > 0)\n      n++;\n  return n;\n}\n\nstatic int find_free_mob_slot(Chunk *c) {\n  for (int i = 0; i < MAX_MOBS; i++)\n    if (c->mobs[i].health <= 0)\n      return i;\n  return -1;\n}\n\nstatic MobType pick_spawn_type(int night, int biome) {\n  // Simple rule: day = mostly passive, night = mostly hostile\n  if (!night) {\n    return (rand() % 2 == 0) ? MOB_PIG : MOB_SHEEP;\n  } else {\n    // night hostiles; biome can bias\n    if (biome == 2)\n      return MOB_SKELETON; // desert -> more skeletons\n    return (rand() % 2 == 0) ? MOB_ZOMBIE : MOB_SKELETON;\n  }\n}\n\nstatic void init_mob(Mob *m, MobType type, Vector2 local_pos, int make_angry) {\n  m->type = type;\n  m->position = clamp_local_to_chunk(local_pos);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"player_try_harvest_forward","file":"game.c","line_start":3722,"line_end":3773,"snippet":"  m->visited = false;\n  m->vel = (Vector2){0, 0};\n  m->ai_timer = randf(0.2f, 1.2f);\n  m->aggro_timer = make_angry ? 2.0f : 0.0f;\n  m->attack_cd = randf(0.2f, 1.0f);\n  m->hurt_timer = 0.0f;\n  m->lunge_timer = 0.0f;\n}\n\nstatic void try_spawn_mobs_in_chunk(Chunk *c, int cx, int cy, float dt) {\n  c->mob_spawn_timer -= dt;\n  if (c->mob_spawn_timer > 0.0f)\n    return;\n\n  c->mob_spawn_timer = randf(1.5f, 4.0f);\n\n  int night = is_night_cached;\n\n  // cap populations differently for day/night\n  int cap = night ? 10 : 6;\n  if (chunk_alive_mobs(c) >= cap)\n    return;\n\n  // spawn 1 mob\n  int slot = find_free_mob_slot(c);\n  if (slot < 0)\n    return;\n\n  Mob *m = &c->mobs[slot];\n  MobType mt = pick_spawn_type(night, c->biome_type);\n\n  // spacing: larger mobs -> larger min distance\n  Vector2 p = {0};\n  int placed = 0;\n\n  float rad = mob_radius_world(mt);\n\n  for (int tries = 0; tries < 35; tries++) {\n    p = (Vector2){randf(0.8f, CHUNK_SIZE - 0.8f),\n                  randf(0.8f, CHUNK_SIZE - 0.8f)};\n\n    Vector2 worldPos = (Vector2){(float)(cx * CHUNK_SIZE) + p.x,\n                                 (float)(cy * CHUNK_SIZE) + p.y};\n\n    if (!world_pos_blocked_nearby(cx, cy, worldPos, rad, cx, cy)) {\n      placed = 1;\n      break;\n    }\n  }\n\n  if (!placed) {\n    // fallback (still float, but no spacing guarantee)"},
  {"kind":"fn_def","vis":"PRIVATE","name":"res_radius_world","file":"game.c","line_start":3912,"line_end":3925,"snippet":"  // terrain fill\n  for (int i = 0; i < CHUNK_SIZE; i++) {\n    for (int j = 0; j < CHUNK_SIZE; j++) {\n      c->terrain[i][j] = c->biome_type;\n    }\n  }\n\n  // resources\n  c->resource_count = 0;\n  {\n    const int desired = 12; // density\n    for (int k = 0; k < desired && c->resource_count < MAX_RESOURCES; k++) {\n      ResourceType rt = (ResourceType)(rand() % 4);\n      float rad = res_radius_world(rt);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"mob_radius_world","file":"game.c","line_start":3930,"line_end":3943,"snippet":"      for (int tries = 0; tries < 80; tries++) {\n        local = (Vector2){\n            randf(0.9f, (float)CHUNK_SIZE - 0.9f),\n            randf(0.9f, (float)CHUNK_SIZE - 0.9f),\n        };\n\n        Vector2 worldPos = (Vector2){\n            (float)(cx * CHUNK_SIZE) + local.x,\n            (float)(cy * CHUNK_SIZE) + local.y,\n        };\n\n        if (!world_pos_blocked_nearby(cx, cy, worldPos, rad, cx, cy)) {\n          placed = 1;\n          break;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"resource_radius_world","file":"game.c","line_start":3945,"line_end":3958,"snippet":"      }\n\n      if (!placed)\n        continue;\n\n      Resource *r = &c->resources[c->resource_count++];\n      r->type = rt;\n      r->position = clamp_local_to_chunk(local);\n      r->health = 100;\n      r->visited = false;\n      r->hit_timer = 0.0f;\n      r->break_flash = 0.0f;\n    }\n  }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"base_allows_entry","file":"game.c","line_start":3960,"line_end":3970,"snippet":"  // mobs init (ONLY ONCE)\n  for (int i = 0; i < MAX_MOBS; i++) {\n    c->mobs[i].health = 0;\n    c->mobs[i].visited = false;\n    c->mobs[i].vel = (Vector2){0, 0};\n    c->mobs[i].ai_timer = 0.0f;\n    c->mobs[i].aggro_timer = 0.0f;\n    c->mobs[i].attack_cd = 0.0f;\n    c->mobs[i].hurt_timer = 0.0f;\n    c->mobs[i].lunge_timer = 0.0f;\n  }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"push_out","file":"game.c","line_start":3972,"line_end":3985,"snippet":"  // spawn timer\n  c->mob_spawn_timer = randf(1.0f, 3.0f);\n\n  // seed mobs (ONE loop, spacing-aware)\n  {\n    const int seed_count = 6; // tweak 4..8\n    int night = is_night_cached;\n\n    for (int k = 0; k < seed_count; k++) {\n      int slot = find_free_mob_slot(c);\n      if (slot < 0)\n        break;\n\n      MobType mt = pick_spawn_type(night, c->biome_type);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"resolve_player_collisions","file":"game.c","line_start":3987,"line_end":4039,"snippet":"\n      int placed = 0;\n      Vector2 p = {0};\n\n      for (int tries = 0; tries < 55; tries++) {\n        p = (Vector2){\n            randf(0.9f, (float)CHUNK_SIZE - 0.9f),\n            randf(0.9f, (float)CHUNK_SIZE - 0.9f),\n        };\n\n        Vector2 worldPos = (Vector2){\n            (float)(cx * CHUNK_SIZE) + p.x,\n            (float)(cy * CHUNK_SIZE) + p.y,\n        };\n\n        if (!world_pos_blocked_nearby(cx, cy, worldPos, rad, cx, cy)) {\n          placed = 1;\n          break;\n        }\n      }\n\n      if (!placed)\n        continue;\n\n      init_mob(&c->mobs[slot], mt, p, /*make_angry=*/0);\n    }\n  }\n\n  pthread_rwlock_unlock(&c->lock);\n  // Kick grass generation after chunk init\n  if (!c->grass_ready && !c->grass_building) {\n    c->grass_building = 1;\n    grass_enqueue_job(cx, cy);\n  }\n  return c;\n}\n\nstatic inline float res_radius_world(ResourceType t) {\n  switch (t) {\n  case RES_TREE:\n    return 1.35f;\n  case RES_ROCK:\n    return 1.05f;\n  case RES_GOLD:\n    return 1.00f;\n  case RES_FOOD:\n    return 0.90f;\n  default:\n    return 1.00f;\n  }\n}\n\n// ---- Mob radius in WORLD units (used for spacing / collisions during"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_chunks","file":"game.c","line_start":4137,"line_end":4179,"snippet":"\n      for (int i = 0; i < MAX_MOBS; i++) {\n        Mob *m = &c->mobs[i];\n        if (m->health <= 0)\n          continue;\n        Vector2 mp = {(pcx + dx) * CHUNK_SIZE + m->position.x,\n                      (pcy + dy) * CHUNK_SIZE + m->position.y};\n        float mr = mob_radius_world(m->type) + pr;\n        push_out(&player.position, mp, mr);\n      }\n\n      pthread_rwlock_unlock(&c->lock);\n    }\n  }\n}\n\n// ---- Spacing test: is \"worldPos\" too close to ANY resource/mob nearby?\n// ---- IMPORTANT: we do NOT call get_chunk() here (avoids recursive\n// generation). We only check chunks that are already generated.\n// ---- Spacing test: is \"worldPos\" too close to ANY resource/mob nearby?\n// ---- IMPORTANT:\n// - Does NOT call get_chunk() (no recursive generation)\n// - Safely reads generated chunks by taking a read lock\n// - If the caller already holds the lock for (self_cx,self_cy), pass those\n// so\n//   we DON'T try to lock it again (avoids deadlock).\nstatic int world_pos_blocked_nearby(int cx, int cy, Vector2 worldPos,\n                                    float radius, int self_cx, int self_cy) {\n  const float padding = 0.25f; // extra spacing so things don't touch\n\n  // Bases are solid obstacles.\n  Vector2 world_center = (Vector2){WORLD_SIZE * 0.5f, WORLD_SIZE * 0.5f};\n  for (int t = 0; t < TRIBE_COUNT; t++) {\n    Vector2 bp = tribes[t].base.position;\n    Vector2 to_center = {world_center.x - bp.x, world_center.y - bp.y};\n    float yaw = atan2f(to_center.x, -to_center.y);\n    if (base_allows_entry(bp, yaw, worldPos)) {\n      continue;\n    }\n    float br = tribes[t].base.radius + radius + padding;\n    if (Vector2Distance(worldPos, bp) < br) {\n      return 1;\n    }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"spawn_mob_at_world","file":"game.c","line_start":4181,"line_end":4219,"snippet":"\n  for (int dx = -1; dx <= 1; dx++) {\n    for (int dy = -1; dy <= 1; dy++) {\n\n      int ncx = wrap(cx + dx);\n      int ncy = wrap(cy + dy);\n\n      Chunk *c = &world[ncx][ncy];\n      if (!c->generated)\n        continue;\n\n      // Avoid deadlock: if caller already holds this chunk's lock, don't\n      // lock it again.\n      bool is_self = (ncx == wrap(self_cx) && ncy == wrap(self_cy));\n\n      if (!is_self) {\n        pthread_rwlock_rdlock(&c->lock);\n        // chunk could have been toggled while we waited (rare, but safe)\n        if (!c->generated) {\n          pthread_rwlock_unlock(&c->lock);\n          continue;\n        }\n      }\n\n      Vector2 origin =\n          (Vector2){(float)(ncx * CHUNK_SIZE), (float)(ncy * CHUNK_SIZE)};\n\n      // check resources\n      for (int i = 0; i < c->resource_count; i++) {\n        Resource *r = &c->resources[i];\n        if (r->health <= 0)\n          continue;\n\n        Vector2 r_world = Vector2Add(origin, r->position);\n        float rr = res_radius_world(r->type);\n\n        if (Vector2Distance(worldPos, r_world) < (radius + rr + padding)) {\n          if (!is_self)\n            pthread_rwlock_unlock(&c->lock);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"despawn_hostiles_if_day","file":"game.c","line_start":4221,"line_end":4243,"snippet":"        }\n      }\n\n      // check mobs\n      for (int i = 0; i < MAX_MOBS; i++) {\n        Mob *m = &c->mobs[i];\n        if (m->health <= 0)\n          continue;\n\n        Vector2 m_world = Vector2Add(origin, m->position);\n        float mr = mob_radius_world(m->type);\n\n        if (Vector2Distance(worldPos, m_world) < (radius + mr + padding)) {\n          if (!is_self)\n            pthread_rwlock_unlock(&c->lock);\n          return 1;\n        }\n      }\n\n      if (!is_self) {\n        pthread_rwlock_unlock(&c->lock);\n      }\n    }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"spawn_raid_wave","file":"game.c","line_start":4245,"line_end":4270,"snippet":"\n  return 0;\n}\n\nvoid draw_chunks(void) {\n  int view_radius = 6;\n\n  int pcx = (int)(player.position.x / CHUNK_SIZE);\n  int pcy = (int)(player.position.y / CHUNK_SIZE);\n\n  float chunk_px = (float)CHUNK_SIZE * WORLD_SCALE;\n\n  for (int dx = -view_radius; dx <= view_radius; dx++) {\n    for (int dy = -view_radius; dy <= view_radius; dy++) {\n      int cx = pcx + dx;\n      int cy = pcy + dy;\n      Chunk *c = get_chunk(cx, cy);\n\n      Vector2 world_pos = {cx * CHUNK_SIZE, cy * CHUNK_SIZE};\n\n      Vector2 screen = Vector2Subtract(world_pos, camera_pos);\n      screen = Vector2Scale(screen, WORLD_SCALE);\n      // Use current screen dimensions, not cached ones\n      int current_w = GetScreenWidth();\n      int current_h = GetScreenHeight();\n      screen.x += current_w / 2;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_resources","file":"game.c","line_start":4272,"line_end":4524,"snippet":"\n      // IMPORTANT: snap to pixel grid to avoid seams\n      int sx = (int)floorf(screen.x);\n      int sy = (int)floorf(screen.y);\n\n      // IMPORTANT: ceil size (and +1) so we never leave a 1px gap\n      int sw = (int)ceilf(chunk_px) + 1;\n      int sh = (int)ceilf(chunk_px) + 1;\n\n      // DrawRectangle(sx, sy, sw, sh, Fade(biome_colors[c->biome_type], 0.9f));\n  // glBegin(GL_QUADS);\n  // glColor4f(biome_colors[c->biome_type].r/255.0f, biome_colors[c->biome_type].g/255.0f, biome_colors[c->biome_type].b/255.0f, 0.9f);\n  // glVertex2f(sx, sy);\n  // glVertex2f(sx + sw, sy);\n  // glVertex2f(sx, sy + sh);\n  // glVertex2f(sx + sw, sy + sh);\n  // glEnd();\n    }\n  }\n}\n\nstatic void spawn_mob_at_world(MobType type, Vector2 world_pos) {\n  float rad = mob_radius_world(type);\n\n  Vector2 chosen = world_pos;\n  int found = 0;\n\n  for (int tries = 0; tries < 20; tries++) {\n    Vector2 cand = world_pos;\n    cand.x += randf(-1.2f, 1.2f);\n    cand.y += randf(-1.2f, 1.2f);\n\n    int ccx = (int)(cand.x / CHUNK_SIZE);\n    int ccy = (int)(cand.y / CHUNK_SIZE);\n\n    if (!world_pos_blocked_nearby(ccx, ccy, cand, rad, -999999, -999999)) {\n      chosen = cand;\n      found = 1;\n      break;\n    }\n  }\n\n  // if we didn't find a clean spot, just use the original (fallback)\n  if (!found)\n    chosen = world_pos;\n\n  int cx = (int)(chosen.x / CHUNK_SIZE);\n  int cy = (int)(chosen.y / CHUNK_SIZE);\n\n  Chunk *c = get_chunk(cx, cy);\n  int slot = find_free_mob_slot(c);\n  if (slot < 0)\n    return;\n\n  Vector2 origin =\n      (Vector2){(float)(cx * CHUNK_SIZE), (float)(cy * CHUNK_SIZE)};\n  Vector2 local = Vector2Subtract(chosen, origin);\n\n  init_mob(&c->mobs[slot], type, local, /*make_angry=*/1);\n}\n\nstatic void despawn_hostiles_if_day(Chunk *c) {\n  // If it's night, do nothing.\n  if (is_night_cached)\n    return;\n\n  // Daytime: remove hostile mobs in this chunk so day feels safer.\n  // You can tune this: either hard-despawn all hostiles, or probabilistic.\n  for (int i = 0; i < MAX_MOBS; i++) {\n    Mob *m = &c->mobs[i];\n    if (m->health <= 0)\n      continue;\n\n    bool hostile = (m->type == MOB_ZOMBIE || m->type == MOB_SKELETON);\n    if (!hostile)\n      continue;\n\n    // Option A: despawn all hostiles immediately:\n    m->health = 0;\n\n    // Option B (comment A out, uncomment B) for softer cleanup:\n    // if ((rand() % 100) < 35) m->health = 0;\n  }\n}\n\nstatic void spawn_raid_wave(void) {\n  // Called only at night in your main loop.\n  // Spawn a small wave near each base.\n  for (int t = 0; t < TRIBE_COUNT; t++) {\n    Tribe *tr = &tribes[t];\n\n    // How many attackers per mini-wave per base:\n    int count = 1 + (rand() % 3); // 1..3\n\n    for (int k = 0; k < count; k++) {\n      // pick hostile type\n      MobType mt = (rand() % 2 == 0) ? MOB_ZOMBIE : MOB_SKELETON;\n\n      // spawn in a ring around the base\n      float ang = randf(0.0f, 2.0f * PI);\n      float r = tr->base.radius + randf(6.0f, 14.0f); // distance from base edge\n\n      Vector2 pos = (Vector2){\n          tr->base.position.x + cosf(ang) * r,\n          tr->base.position.y + sinf(ang) * r,\n      };\n\n      spawn_mob_at_world(mt, pos);\n    }\n  }\n}\n\nvoid draw_resources(void) {\n  int pcx = (int)(player.position.x / CHUNK_SIZE);\n  int pcy = (int)(player.position.y / CHUNK_SIZE);\n\n  for (int dx = -6; dx <= 6; dx++) {\n    for (int dy = -6; dy <= 6; dy++) {\n      int cx = pcx + dx;\n      int cy = pcy + dy;\n      Chunk *c = get_chunk(cx, cy);\n\n      for (int i = 0; i < c->resource_count; i++) {\n        Resource *r = &c->resources[i];\n        if (r->health <= 0)\n          continue;\n\n        Vector2 wp = {(float)(cx * CHUNK_SIZE) + r->position.x,\n                      (float)(cy * CHUNK_SIZE) + r->position.y};\n        Vector2 sp = world_to_screen(wp);\n        // shake animation when hit\n        float mul = 1.0f;\n        switch (r->type) {\n        case RES_TREE:\n          mul = TREE_SCALE;\n          break;\n        case RES_ROCK:\n          mul = ROCK_SCALE;\n          break;\n        case RES_GOLD:\n          mul = GOLD_SCALE;\n          break;\n        case RES_FOOD:\n          mul = FOOD_SCALE;\n          break;\n        default:\n          mul = 1.0f;\n          break;\n        }\n        float s = px(0.20f) * RESOURCE_SCALE * mul;\n        float s2 = s * 1.2f;\n\n        // shake animation when hit\n        if (r->hit_timer > 0.0f) {\n          float k = r->hit_timer * 18.0f;\n          sp.x += sinf(GetTime() * 70.0f) * (s * 0.02f) * k;\n          sp.y += cosf(GetTime() * 55.0f) * (s * 0.02f) * k;\n        }\n\n        // health tint\n        float hp01 = (float)r->health / 100.0f;\n\n        switch (r->type) {\n        case RES_TREE: {\n          // shadow\n          DrawEllipse((int)sp.x, (int)(sp.y + s * 0.65f), (int)(s * 0.9f),\n                      (int)(s * 0.35f), (Color){0, 0, 0, 70});\n\n          // trunk\n          DrawRectangle((int)(sp.x - s * 0.18f), (int)(sp.y - s * 0.20f),\n                        (int)(s * 0.36f), (int)(s * 0.65f),\n                        (Color){120, 80, 40, 255});\n          DrawRectangleLines((int)(sp.x - s * 0.18f), (int)(sp.y - s * 0.20f),\n                             (int)(s * 0.36f), (int)(s * 0.65f),\n                             (Color){0, 0, 0, 150});\n\n          // canopy (3 blobs)\n          Color leaf = (Color){30, (unsigned char)(140 + 60 * hp01), 30, 255};\n          DrawCircleV((Vector2){sp.x, sp.y - s * 0.55f}, s * 0.55f, leaf);\n          DrawCircleV((Vector2){sp.x - s * 0.45f, sp.y - s * 0.35f}, s * 0.45f,\n                      leaf);\n          DrawCircleV((Vector2){sp.x + s * 0.45f, sp.y - s * 0.35f}, s * 0.45f,\n                      leaf);\n          DrawCircleLines((int)sp.x, (int)(sp.y - s * 0.55f), s * 0.55f,\n                          (Color){0, 0, 0, 110});\n\n          // small fruit dots\n          DrawCircleV((Vector2){sp.x - s * 0.18f, sp.y - s * 0.55f}, s * 0.06f,\n                      RED);\n          DrawCircleV((Vector2){sp.x + s * 0.22f, sp.y - s * 0.40f}, s * 0.06f,\n                      RED);\n\n          // health bar\n          draw_health_bar((Vector2){sp.x, sp.y - s2 * 1.2f}, s * 1.4f,\n                          s * 0.18f, hp01, (Color){60, 220, 60, 255});\n\n          // cracks (more cracks when low hp)\n          if (r->health > 0) {\n            float hp01 = (float)r->health / 100.0f;\n            int cracks = (hp01 > 0.66f) ? 0 : (hp01 > 0.33f) ? 2 : 4;\n            for (int k = 0; k < cracks; k++) {\n              float a = (float)k / (float)(cracks + 1) * PI;\n              DrawLine((int)(sp.x - cosf(a) * s * 0.30f),\n                       (int)(sp.y - sinf(a) * s * 0.25f),\n                       (int)(sp.x + cosf(a) * s * 0.18f),\n                       (int)(sp.y + sinf(a) * s * 0.22f),\n                       (Color){0, 0, 0, 120});\n            }\n          }\n          // break flash overlay\n          if (r->break_flash > 0.0f) {\n            DrawCircleV((Vector2){sp.x, sp.y}, s * 0.35f,\n                        (Color){255, 255, 255,\n                                (unsigned char)(120 * clamp01(r->break_flash *\n                                                              20.0f))});\n          }\n\n        } break;\n\n        case RES_ROCK: {\n          DrawEllipse((int)sp.x, (int)(sp.y + s * 0.55f), (int)(s * 0.9f),\n                      (int)(s * 0.32f), (Color){0, 0, 0, 70});\n\n          // rock: polygon-ish using circles + outlines\n          Color rock = (Color){120, 120, 120, 255};\n          DrawCircleV((Vector2){sp.x, sp.y}, s * 0.55f, rock);\n          DrawCircleV((Vector2){sp.x - s * 0.35f, sp.y + s * 0.05f}, s * 0.40f,\n                      rock);\n          DrawCircleV((Vector2){sp.x + s * 0.35f, sp.y + s * 0.10f}, s * 0.45f,\n                      rock);\n\n          // highlight\n          DrawCircleV((Vector2){sp.x - s * 0.15f, sp.y - s * 0.18f}, s * 0.18f,\n                      (Color){200, 200, 200, 160});\n\n          // outline\n          DrawCircleLines((int)sp.x, (int)sp.y, s * 0.55f,\n                          (Color){0, 0, 0, 120});\n\n          draw_health_bar((Vector2){sp.x, sp.y - s2 * 1.1f}, s * 1.4f,\n                          s * 0.18f, hp01, (Color){180, 180, 180, 255});\n          // cracks (more cracks when low hp)\n          if (r->health > 0) {\n            float hp01 = (float)r->health / 100.0f;\n            int cracks = (hp01 > 0.66f) ? 0 : (hp01 > 0.33f) ? 2 : 4;\n            for (int k = 0; k < cracks; k++) {\n              float a = (float)k / (float)(cracks + 1) * PI;\n              DrawLine((int)(sp.x - cosf(a) * s * 0.30f),\n                       (int)(sp.y - sinf(a) * s * 0.25f),\n                       (int)(sp.x + cosf(a) * s * 0.18f),\n                       (int)(sp.y + sinf(a) * s * 0.22f),\n                       (Color){0, 0, 0, 120});\n            }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"lerp_color","file":"game.c","line_start":4527,"line_end":4535,"snippet":"          if (r->break_flash > 0.0f) {\n            DrawCircleV((Vector2){sp.x, sp.y}, s * 0.35f,\n                        (Color){255, 255, 255,\n                                (unsigned char)(120 * clamp01(r->break_flash *\n                                                              20.0f))});\n          }\n\n        } break;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"mul_color","file":"game.c","line_start":4537,"line_end":4546,"snippet":"          DrawEllipse((int)sp.x, (int)(sp.y + s * 0.55f), (int)(s * 0.9f),\n                      (int)(s * 0.32f), (Color){0, 0, 0, 70});\n\n          // nugget: bright + rim + sparkle\n          Color gold = (Color){240, 210, 70, 255};\n          DrawCircleV((Vector2){sp.x, sp.y}, s * 0.55f, gold);\n          DrawCircleV((Vector2){sp.x - s * 0.28f, sp.y + s * 0.08f}, s * 0.38f,\n                      gold);\n          DrawCircleV((Vector2){sp.x + s * 0.30f, sp.y + s * 0.10f}, s * 0.40f,\n                      gold);"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"lerp_color","file":"game.c","line_start":4545,"line_end":4545,"snippet":"          DrawCircleV((Vector2){sp.x + s * 0.30f, sp.y + s * 0.10f}, s * 0.40f,"},
  {"kind":"fn_def","vis":"PRIVATE","name":"agent_set_facing_from","file":"game.c","line_start":4548,"line_end":4552,"snippet":"          DrawCircleV((Vector2){sp.x - s * 0.12f, sp.y - s * 0.18f}, s * 0.14f,\n                      (Color){255, 255, 255, 160});\n          DrawCircleLines((int)sp.x, (int)sp.y, s * 0.55f,\n                          (Color){0, 0, 0, 140});"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_mobs","file":"game.c","line_start":4554,"line_end":4767,"snippet":"          DrawLine((int)(sp.x + s * 0.55f), (int)(sp.y - s * 0.55f),\n                   (int)(sp.x + s * 0.75f), (int)(sp.y - s * 0.75f), RAYWHITE);\n          DrawLine((int)(sp.x + s * 0.75f), (int)(sp.y - s * 0.55f),\n                   (int)(sp.x + s * 0.55f), (int)(sp.y - s * 0.75f), RAYWHITE);\n\n          draw_health_bar((Vector2){sp.x, sp.y - s2 * 1.1f}, s * 1.4f,\n                          s * 0.18f, hp01, (Color){240, 210, 70, 255});\n          // cracks (more cracks when low hp)\n          if (r->health > 0) {\n            float hp01 = (float)r->health / 100.0f;\n            int cracks = (hp01 > 0.66f) ? 0 : (hp01 > 0.33f) ? 2 : 4;\n            for (int k = 0; k < cracks; k++) {\n              float a = (float)k / (float)(cracks + 1) * PI;\n              DrawLine((int)(sp.x - cosf(a) * s * 0.30f),\n                       (int)(sp.y - sinf(a) * s * 0.25f),\n                       (int)(sp.x + cosf(a) * s * 0.18f),\n                       (int)(sp.y + sinf(a) * s * 0.22f),\n                       (Color){0, 0, 0, 120});\n            }\n          }\n          // break flash overlay\n          if (r->break_flash > 0.0f) {\n            DrawCircleV((Vector2){sp.x, sp.y}, s * 0.35f,\n                        (Color){255, 255, 255,\n                                (unsigned char)(120 * clamp01(r->break_flash *\n                                                              20.0f))});\n          }\n\n        } break;\n\n        case RES_FOOD: {\n          DrawEllipse((int)sp.x, (int)(sp.y + s * 0.55f), (int)(s * 0.9f),\n                      (int)(s * 0.32f), (Color){0, 0, 0, 70});\n\n          // berry/fruit: red body + green leaf\n          Color fruit = (Color){220, 60, 60, 255};\n          DrawCircleV((Vector2){sp.x, sp.y}, s * 0.55f, fruit);\n          DrawCircleV((Vector2){sp.x - s * 0.15f, sp.y - s * 0.15f}, s * 0.18f,\n                      (Color){255, 255, 255, 120});\n          DrawCircleLines((int)sp.x, (int)sp.y, s * 0.55f,\n                          (Color){0, 0, 0, 130});\n\n          // leaf\n          DrawTriangle((Vector2){sp.x, sp.y - s * 0.55f},\n                       (Vector2){sp.x - s * 0.25f, sp.y - s * 0.75f},\n                       (Vector2){sp.x + s * 0.25f, sp.y - s * 0.75f},\n                       (Color){40, 180, 60, 255});\n\n          draw_health_bar((Vector2){sp.x, sp.y - s2 * 1.1f}, s * 1.4f,\n                          s * 0.18f, hp01, (Color){220, 60, 60, 255});\n          // cracks (more cracks when low hp)\n          if (r->health > 0) {\n            float hp01 = (float)r->health / 100.0f;\n            int cracks = (hp01 > 0.66f) ? 0 : (hp01 > 0.33f) ? 2 : 4;\n            for (int k = 0; k < cracks; k++) {\n              float a = (float)k / (float)(cracks + 1) * PI;\n              DrawLine((int)(sp.x - cosf(a) * s * 0.30f),\n                       (int)(sp.y - sinf(a) * s * 0.25f),\n                       (int)(sp.x + cosf(a) * s * 0.18f),\n                       (int)(sp.y + sinf(a) * s * 0.22f),\n                       (Color){0, 0, 0, 120});\n            }\n          }\n          // break flash overlay\n          if (r->break_flash > 0.0f) {\n            DrawCircleV((Vector2){sp.x, sp.y}, s * 0.35f,\n                        (Color){255, 255, 255,\n                                (unsigned char)(120 * clamp01(r->break_flash *\n                                                              20.0f))});\n          }\n\n        } break;\n\n        default:\n          // fallback\n          fprintf(stderr, \"Unknown resource type: %d\\n\", r->type);\n          exit(1);\n          break;\n        }\n      }\n    }\n  }\n}\n\n// small helpers for drawing\nstatic inline Color lerp_color(Color a, Color b, float t) {\n  t = clamp01(t);\n  Color out;\n  out.r = (unsigned char)(a.r + (b.r - a.r) * t);\n  out.g = (unsigned char)(a.g + (b.g - a.g) * t);\n  out.b = (unsigned char)(a.b + (b.b - a.b) * t);\n  out.a = (unsigned char)(a.a + (b.a - a.a) * t);\n  return out;\n}\n\nstatic inline Color mul_color(Color a, Color b, float t) {\n  // multiply blend toward (a*b) by amount t\n  t = clamp01(t);\n  Color m;\n  m.r = (unsigned char)((a.r * b.r) / 255);\n  m.g = (unsigned char)((a.g * b.g) / 255);\n  m.b = (unsigned char)((a.b * b.b) / 255);\n  m.a = a.a;\n  return lerp_color(a, m, t);\n}\n\nstatic inline void agent_set_facing_from(Vector2 v, Agent *a) {\n  float len = Vector2Length(v);\n  if (len > 1e-3f)\n    a->facing = Vector2Scale(v, 1.0f / len);\n}\n\nvoid draw_mobs(void) {\n\n  int pcx = (int)(player.position.x / CHUNK_SIZE);\n  int pcy = (int)(player.position.y / CHUNK_SIZE);\n\n  float tnow = (float)GetTime();\n\n  for (int dx = -6; dx <= 6; dx++) {\n    for (int dy = -6; dy <= 6; dy++) {\n      int cx = pcx + dx;\n      int cy = pcy + dy;\n      Chunk *c = get_chunk(cx, cy);\n\n      // use this chunk's biome as a subtle tint for everything inside it\n      Color biome = biome_colors[c->biome_type];\n\n      for (int i = 0; i < MAX_MOBS; i++) {\n        Mob *m = &c->mobs[i];\n        if (m->health <= 0)\n          continue;\n\n        Vector2 wp = {(float)(cx * CHUNK_SIZE) + m->position.x,\n                      (float)(cy * CHUNK_SIZE) + m->position.y};\n        Vector2 sp = world_to_screen(wp);\n\n        float s = px(0.26f) * MOB_SCALE;\n        float hp01 = (float)m->health / 100.0f;\n\n        // idle bob\n        float bob =\n            sinf(tnow * 6.0f + (float)(i * 13 + m->type * 7)) * (s * 0.05f);\n        sp.y += bob;\n\n        // base mob color by type\n        Color base = mob_colors[m->type];\n\n        // biome tint (subtle)\n        base = mul_color(base, biome, 0.18f);\n\n        // aggro tint (blend toward red while aggro_timer is active)\n        if (m->aggro_timer > 0.0f) {\n          float a01 =\n              clamp01(m->aggro_timer / 3.0f); // 3.0f matches your set value\n          base = lerp_color(base, (Color){220, 60, 60, 255}, 0.35f * a01);\n        }\n\n        // hurt flash (blend toward white while hurt_timer is active)\n        if (m->hurt_timer > 0.0f) {\n          float h01 = clamp01(m->hurt_timer * 6.0f); // quick strong flash\n          base = lerp_color(base, RAYWHITE, h01);\n        }\n\n        // lunge toward player (visual only)\n        if (m->lunge_timer > 0.0f) {\n          Vector2 toP = Vector2Subtract(player.position, wp);\n          float d = Vector2Length(toP);\n          Vector2 dir =\n              (d > 1e-3f) ? Vector2Scale(toP, 1.0f / d) : (Vector2){0, 0};\n          float push = (0.10f + 0.20f * clamp01(m->lunge_timer * 8.0f));\n          sp.x += dir.x * (s * push);\n          sp.y += dir.y * (s * push);\n        }\n\n        // tiny hurt shake\n        if (m->hurt_timer > 0.0f) {\n          float k = clamp01(m->hurt_timer * 10.0f);\n          sp.x += sinf(tnow * 80.0f + (float)i) * (s * 0.02f) * k;\n          sp.y += cosf(tnow * 65.0f + (float)i) * (s * 0.02f) * k;\n        }\n\n        // shadow\n        DrawEllipse((int)sp.x, (int)(sp.y + s * 0.85f), (int)(s * 1.2f),\n                    (int)(s * 0.40f), (Color){0, 0, 0, 80});\n\n        // draw per-type, but using the computed \"base\" tint everywhere\n        switch (m->type) {\n        case MOB_PIG: {\n          // body\n          DrawCircleV((Vector2){sp.x, sp.y}, s * 0.85f, base);\n          DrawCircleLines((int)sp.x, (int)sp.y, s * 0.85f,\n                          (Color){0, 0, 0, 120});\n\n          // snout (slightly darker/lighter from base)\n          Color snout = lerp_color(base, (Color){255, 120, 160, 255}, 0.55f);\n          DrawCircleV((Vector2){sp.x + s * 0.55f, sp.y + s * 0.10f}, s * 0.28f,\n                      snout);\n\n          DrawCircleV((Vector2){sp.x + s * 0.62f, sp.y + s * 0.05f}, s * 0.06f,\n                      (Color){120, 60, 80, 255});\n          DrawCircleV((Vector2){sp.x + s * 0.50f, sp.y + s * 0.05f}, s * 0.06f,\n                      (Color){120, 60, 80, 255});\n\n          // ears\n          Color ear = lerp_color(base, (Color){255, 140, 175, 255}, 0.45f);\n          DrawTriangle((Vector2){sp.x - s * 0.30f, sp.y - s * 0.70f},\n                       (Vector2){sp.x - s * 0.55f, sp.y - s * 0.95f},\n                       (Vector2){sp.x - s * 0.10f, sp.y - s * 0.90f}, ear);\n          DrawTriangle((Vector2){sp.x + s * 0.10f, sp.y - s * 0.70f},\n                       (Vector2){sp.x + s * 0.35f, sp.y - s * 0.95f},\n                       (Vector2){sp.x + s * 0.55f, sp.y - s * 0.85f}, ear);\n\n          // eyes"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_player","file":"game.c","line_start":4769,"line_end":4892,"snippet":"                      BLACK);\n          DrawCircleV((Vector2){sp.x - s * 0.10f, sp.y - s * 0.15f}, s * 0.08f,\n                      BLACK);\n\n          draw_health_bar((Vector2){sp.x, sp.y - s * 1.35f}, s * 1.6f,\n                          s * 0.18f, hp01, (Color){80, 220, 80, 255});\n        } break;\n\n        case MOB_SHEEP: {\n          // wool: keep mostly white but still accept biome tint a bit\n          Color wool = lerp_color((Color){245, 245, 245, 255}, base, 0.18f);\n          DrawCircleV((Vector2){sp.x, sp.y}, s * 0.80f, wool);\n          DrawCircleV((Vector2){sp.x - s * 0.45f, sp.y + s * 0.10f}, s * 0.55f,\n                      wool);\n          DrawCircleV((Vector2){sp.x + s * 0.45f, sp.y + s * 0.10f}, s * 0.55f,\n                      wool);\n          DrawCircleLines((int)sp.x, (int)sp.y, s * 0.80f,\n                          (Color){0, 0, 0, 90});\n\n          // face\n          Color face = (Color){70, 70, 70, 255};\n          face = mul_color(face, biome, 0.10f);\n          if (m->hurt_timer > 0.0f)\n            face = lerp_color(face, RAYWHITE, clamp01(m->hurt_timer * 6.0f));\n\n          DrawCircleV((Vector2){sp.x + s * 0.55f, sp.y + s * 0.20f}, s * 0.35f,\n                      face);\n\n          // eye\n          DrawCircleV((Vector2){sp.x + s * 0.62f, sp.y + s * 0.10f}, s * 0.06f,\n                      RAYWHITE);\n          DrawCircleV((Vector2){sp.x + s * 0.62f, sp.y + s * 0.10f}, s * 0.03f,\n                      BLACK);\n\n          draw_health_bar((Vector2){sp.x, sp.y - s * 1.35f}, s * 1.6f,\n                          s * 0.18f, hp01, (Color){80, 220, 80, 255});\n        } break;\n\n        case MOB_SKELETON: {\n          // bone: slightly tinted by biome + hurt flash already applied via\n          // base\n          Color bone = lerp_color((Color){230, 230, 230, 255}, base, 0.55f);\n\n          // skull\n          DrawCircleV((Vector2){sp.x, sp.y - s * 0.10f}, s * 0.65f, bone);\n          DrawCircleLines((int)sp.x, (int)(sp.y - s * 0.10f), s * 0.65f,\n                          (Color){0, 0, 0, 140});\n\n          // jaw\n          DrawRectangle((int)(sp.x - s * 0.40f), (int)(sp.y + s * 0.25f),\n                        (int)(s * 0.80f), (int)(s * 0.25f), bone);\n          DrawRectangleLines((int)(sp.x - s * 0.40f), (int)(sp.y + s * 0.25f),\n                             (int)(s * 0.80f), (int)(s * 0.25f),\n                             (Color){0, 0, 0, 140});\n\n          // eyes\n          DrawCircleV((Vector2){sp.x - s * 0.20f, sp.y - s * 0.20f}, s * 0.12f,\n                      BLACK);\n          DrawCircleV((Vector2){sp.x + s * 0.20f, sp.y - s * 0.20f}, s * 0.12f,\n                      BLACK);\n\n          // ribs\n          for (int k = 0; k < 4; k++) {\n            float yy = sp.y + s * (0.10f + 0.12f * k);\n            DrawLine((int)(sp.x - s * 0.35f), (int)yy, (int)(sp.x + s * 0.35f),\n                     (int)yy, (Color){0, 0, 0, 110});\n          }\n\n          draw_health_bar((Vector2){sp.x, sp.y - s * 1.35f}, s * 1.6f,\n                          s * 0.18f, hp01, (Color){220, 90, 90, 255});\n        } break;\n\n        case MOB_ZOMBIE: {\n          // body\n          DrawCircleV((Vector2){sp.x, sp.y}, s * 0.85f, base);\n          DrawCircleLines((int)sp.x, (int)sp.y, s * 0.85f,\n                          (Color){0, 0, 0, 140});\n\n          // mouth\n          Color mouth = (Color){120, 50, 50, 255};\n          if (m->hurt_timer > 0.0f)\n            mouth = lerp_color(mouth, RAYWHITE, clamp01(m->hurt_timer * 6.0f));\n          DrawRectangle((int)(sp.x - s * 0.25f), (int)(sp.y + s * 0.15f),\n                        (int)(s * 0.50f), (int)(s * 0.18f), mouth);\n\n          // eyes\n          DrawCircleV((Vector2){sp.x - s * 0.20f, sp.y - s * 0.15f}, s * 0.10f,\n                      RAYWHITE);\n          DrawCircleV((Vector2){sp.x + s * 0.20f, sp.y - s * 0.15f}, s * 0.10f,\n                      RAYWHITE);\n          DrawCircleV((Vector2){sp.x - s * 0.20f, sp.y - s * 0.15f}, s * 0.05f,\n                      BLACK);\n          DrawCircleV((Vector2){sp.x + s * 0.20f, sp.y - s * 0.15f}, s * 0.05f,\n                      BLACK);\n\n          // scar\n          DrawLine((int)(sp.x + s * 0.40f), (int)(sp.y - s * 0.10f),\n                   (int)(sp.x + s * 0.55f), (int)(sp.y + s * 0.05f),\n                   (Color){30, 90, 30, 255});\n\n          draw_health_bar((Vector2){sp.x, sp.y - s * 1.35f}, s * 1.6f,\n                          s * 0.18f, hp01, (Color){220, 90, 90, 255});\n        } break;\n\n        default:\n          break;\n        }\n      }\n    }\n  }\n}\n\nstatic void draw_player(Vector2 pp_screen) {\n  // Body sizing\n  float bodyR = WORLD_SCALE * 0.60f * scale_size;\n  float outlineR = bodyR * 1.02f;\n\n  Color outline = (Color){20, 20, 20, 180};\n  Color body = (Color){255, 220, 120, 255};\n  Color blush = (Color){255, 140, 160, 170};\n  Color eyeW = RAYWHITE;\n  Color eyeB = (Color){35, 35, 35, 255};\n  Color shadow = (Color){0, 0, 0, 70};"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_agent","file":"game.c","line_start":4894,"line_end":5013,"snippet":"  DrawEllipse((int)pp_screen.x, (int)(pp_screen.y + bodyR * 0.85f),\n              (int)(bodyR * 1.35f), (int)(bodyR * 0.45f), shadow);\n\n  // Outline + body\n  DrawCircleV(pp_screen, outlineR, outline);\n  DrawCircleV(pp_screen, bodyR, body);\n\n  // Highlight\n  DrawCircleV(\n      (Vector2){pp_screen.x - bodyR * 0.25f, pp_screen.y - bodyR * 0.25f},\n      bodyR * 0.18f, (Color){255, 255, 255, 120});\n\n  // --- Mouse-aim direction (screen space) ---\n  Vector2 mouse = GetMousePosition();\n  Vector2 aim = Vector2Subtract(mouse, pp_screen);\n  float aimLen = Vector2Length(aim);\n  if (aimLen < 1e-3f)\n    aimLen = 1e-3f;\n  float aimAng = atan2f(aim.y, aim.x);\n\n  // --- Animated hands that orbit and point toward mouse ---\n  float t = (float)GetTime();\n\n  float handR = bodyR * 0.28f;\n  float handArm = bodyR * 0.90f; // distance from center\n\n  // slight breathing wiggle\n  float wiggle = sinf(t * 7.0f) * (bodyR * 0.04f);\n\n  // Perpendicular offset so hands sit \"around\" the aim line\n  Vector2 aimDir = (Vector2){cosf(aimAng), sinf(aimAng)};\n  Vector2 perp = (Vector2){-aimDir.y, aimDir.x};\n\n  // LEFT HAND: EXACTLY on aim direction (this fixes your left hand angle)\n  Vector2 hl = Vector2Add(pp_screen, Vector2Scale(aimDir, handArm + wiggle));\n\n  // RIGHT HAND: slightly behind + offset sideways so you can see both hands\n  Vector2 hr = pp_screen;\n  hr = Vector2Add(hr, Vector2Scale(aimDir, (handArm - bodyR * 0.12f) - wiggle));\n  hr = Vector2Add(hr, Vector2Scale(perp, bodyR * 0.22f));\n\n  // little finger nub pointing toward mouse from each hand\n  float nubR = handR * 0.28f;\n  Vector2 toMouseL = Vector2Subtract(mouse, hl);\n  Vector2 toMouseR = Vector2Subtract(mouse, hr);\n\n  Vector2 dirL = Vector2Normalize(toMouseL);\n  Vector2 dirR = Vector2Normalize(toMouseR);\n\n  if (Vector2Length(toMouseL) < 1e-3f)\n    dirL = aimDir;\n  if (Vector2Length(toMouseR) < 1e-3f)\n    dirR = aimDir;\n\n  Vector2 hl_nub = Vector2Add(hl, Vector2Scale(dirL, handR * 0.65f));\n  Vector2 hr_nub = Vector2Add(hr, Vector2Scale(dirR, handR * 0.65f));\n\n  // draw hands (outline + fill)\n  Color handFill = (Color){255, 210, 110, 255};\n\n  DrawCircleV(hl, handR * 1.02f, outline);\n  DrawCircleV(hl, handR, handFill);\n  DrawCircleV(hl_nub, nubR * 1.02f, outline);\n  DrawCircleV(hl_nub, nubR, handFill);\n\n  DrawCircleV(hr, handR * 1.02f, outline);\n  DrawCircleV(hr, handR, handFill);\n  DrawCircleV(hr_nub, nubR * 1.02f, outline);\n  DrawCircleV(hr_nub, nubR, handFill);\n\n  // Feet\n  float footR = bodyR * 0.26f;\n  Vector2 fl = {pp_screen.x - bodyR * 0.25f, pp_screen.y + bodyR * 0.70f};\n  Vector2 fr = {pp_screen.x + bodyR * 0.25f, pp_screen.y + bodyR * 0.70f};\n\n  DrawCircleV(fl, footR * 1.02f, outline);\n  DrawCircleV(fr, footR * 1.02f, outline);\n  DrawCircleV(fl, footR, (Color){255, 160, 120, 255});\n  DrawCircleV(fr, footR, (Color){255, 160, 120, 255});\n\n  // Face\n  float eyeOffX = bodyR * 0.22f;\n  float eyeOffY = bodyR * 0.12f;\n  float eyeR = bodyR * 0.13f;\n\n  Vector2 eL = {pp_screen.x - eyeOffX, pp_screen.y - eyeOffY};\n  Vector2 eR = {pp_screen.x + eyeOffX, pp_screen.y - eyeOffY};\n\n  DrawCircleV(eL, eyeR * 1.05f, outline);\n  DrawCircleV(eR, eyeR * 1.05f, outline);\n  DrawCircleV(eL, eyeR, eyeW);\n  DrawCircleV(eR, eyeR, eyeW);\n\n  float blink = (sinf(t * 2.5f) > 0.97f) ? 0.35f : 1.0f;\n  float pupR = eyeR * 0.45f;\n  DrawEllipse((int)eL.x, (int)eL.y, (int)(pupR * 1.1f), (int)(pupR * blink),\n              eyeB);\n  DrawEllipse((int)eR.x, (int)eR.y, (int)(pupR * 1.1f), (int)(pupR * blink),\n              eyeB);\n\n  Vector2 mouth = {pp_screen.x, pp_screen.y + bodyR * 0.18f};\n  DrawCircleV(mouth, bodyR * 0.06f, (Color){120, 60, 60, 255});\n\n  Vector2 bl = {pp_screen.x - bodyR * 0.38f, pp_screen.y + bodyR * 0.05f};\n  Vector2 br = {pp_screen.x + bodyR * 0.38f, pp_screen.y + bodyR * 0.05f};\n  DrawCircleV(bl, bodyR * 0.10f, blush);\n  DrawCircleV(br, bodyR * 0.10f, blush);\n\n  g_handL = hl;\n  g_handR = hr;\n}\n\nstatic void draw_agent(const Agent *a, Vector2 sp, Color tribeColor) {\n  float r = WORLD_SCALE * 0.60 * scale_size; // base agent size\n  float t = (float)GetTime();\n\n  Color outline = (Color){0, 0, 0, 140};\n  Color skin = (Color){235, 210, 190, 255};\n  Color cloth = tribeColor;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"init_tribes","file":"game.c","line_start":5016,"line_end":5036,"snippet":"  sp.y += bob;\n\n  // shadow\n  DrawEllipse((int)sp.x, (int)(sp.y + r * 1.15f), (int)(r * 1.5f),\n              (int)(r * 0.45f), (Color){0, 0, 0, 70});\n\n  // body (tunic)\n  DrawCircleV((Vector2){sp.x, sp.y + r * 0.40f}, r * 0.95f, cloth);\n  DrawCircleLines((int)sp.x, (int)(sp.y + r * 0.40f), r * 0.95f, outline);\n\n  // head\n  DrawCircleV((Vector2){sp.x, sp.y - r * 0.25f}, r * 0.85f, skin);\n  DrawCircleLines((int)sp.x, (int)(sp.y - r * 0.25f), r * 0.85f, outline);\n\n  // highlight\n  DrawCircleV((Vector2){sp.x - r * 0.25f, sp.y - r * 0.55f}, r * 0.20f,\n              (Color){255, 255, 255, 120});\n\n  // eyes\n  DrawCircleV((Vector2){sp.x - r * 0.18f, sp.y - r * 0.30f}, r * 0.10f,\n              RAYWHITE);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"init_muze_runtime","file":"game.c","line_start":5038,"line_end":5117,"snippet":"              RAYWHITE);\n  DrawCircleV((Vector2){sp.x - r * 0.18f, sp.y - r * 0.30f}, r * 0.05f, BLACK);\n  DrawCircleV((Vector2){sp.x + r * 0.18f, sp.y - r * 0.30f}, r * 0.05f, BLACK);\n\n  // headband (tribe marker)\n  DrawRectangle((int)(sp.x - r * 0.70f), (int)(sp.y - r * 0.55f),\n                (int)(r * 1.40f), (int)(r * 0.22f), tribeColor);\n  DrawRectangleLines((int)(sp.x - r * 0.70f), (int)(sp.y - r * 0.55f),\n                     (int)(r * 1.40f), (int)(r * 0.22f), outline);\n\n  // tiny tool (points based on a subtle idle direction)\n  // If you later store last action direction, plug it here.\n  float ang = 0.0f;\n  switch (a->last_action) {\n  case ACTION_UP:\n    ang = -PI / 2;\n    break;\n  case ACTION_DOWN:\n    ang = PI / 2;\n    break;\n  case ACTION_LEFT:\n    ang = PI;\n    break;\n  case ACTION_RIGHT:\n    ang = 0.0f;\n    break;\n  case ACTION_ATTACK:\n  case ACTION_HARVEST:\n  case ACTION_FIRE:\n    // small idle wobble for doing stuff\n    ang = sinf(t * 6.0f + (float)a->agent_id) * 0.35f;\n    break;\n  default:\n    ang = sinf(t * 1.5f + (float)a->agent_id) * 0.25f;\n    break;\n  }\n  Vector2 toolDir = {cosf(ang), sinf(ang)};\n  Vector2 toolPos = {sp.x + toolDir.x * (r * 0.95f),\n                     sp.y + toolDir.y * (r * 0.95f)};\n\n  // handle\n  DrawLineEx(sp, toolPos, r * 0.14f, (Color){120, 80, 40, 255});\n  // head (axe/spear-ish)\n  DrawCircleV(toolPos, r * 0.20f, (Color){180, 180, 180, 255});\n  DrawCircleLines((int)toolPos.x, (int)toolPos.y, r * 0.20f, outline);\n\n  // small health/stamina pips\n  float hp01 = clamp01(a->health / 100.0f);\n  float st01 = clamp01(a->stamina / 100.0f);\n  draw_health_bar((Vector2){sp.x, sp.y - r * 1.35f}, r * 1.7f, r * 0.18f, hp01,\n                  (Color){80, 220, 80, 255});\n  draw_health_bar((Vector2){sp.x, sp.y - r * 1.10f}, r * 1.7f, r * 0.18f, st01,\n                  (Color){80, 160, 255, 255});\n\n  // --- intent icon above head ---\n  Vector2 icon = (Vector2){sp.x, sp.y - r * 1.55f};\n  Color ic = (Color){0, 0, 0, 180};\n  DrawCircleV(icon, r * 0.35f, (Color){255, 255, 255, 200});\n  DrawCircleLines((int)icon.x, (int)icon.y, r * 0.35f, ic);\n\n  switch (a->last_action) {\n  case ACTION_ATTACK: {\n    // sword-ish line\n    DrawLineEx((Vector2){icon.x - r * 0.10f, icon.y + r * 0.14f},\n               (Vector2){icon.x + r * 0.14f, icon.y - r * 0.14f}, r * 0.10f,\n               (Color){120, 120, 120, 255});\n    DrawCircleV((Vector2){icon.x + r * 0.16f, icon.y - r * 0.16f}, r * 0.10f,\n                (Color){200, 200, 200, 255});\n  } break;\n\n  case ACTION_HARVEST: {\n    // pickaxe-ish\n    DrawLineEx((Vector2){icon.x - r * 0.16f, icon.y - r * 0.05f},\n               (Vector2){icon.x + r * 0.16f, icon.y + r * 0.12f}, r * 0.10f,\n               (Color){120, 80, 40, 255});\n    DrawCircleV((Vector2){icon.x + r * 0.18f, icon.y + r * 0.14f}, r * 0.10f,\n                (Color){180, 180, 180, 255});\n  } break;\n\n  default: {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"init_agents","file":"game.c","line_start":5119,"line_end":5163,"snippet":"    DrawTriangle((Vector2){icon.x, icon.y - r * 0.16f},\n                 (Vector2){icon.x - r * 0.14f, icon.y + r * 0.12f},\n                 (Vector2){icon.x + r * 0.14f, icon.y + r * 0.12f},\n                 (Color){60, 60, 60, 255});\n  } break;\n  }\n}\n\n/* =======================\n   TRIBES & AGENTS\n======================= */\nvoid init_tribes(void) {\n  Color colors[] = {RED, BLUE, GREEN, ORANGE};\n  float spacing = 80.0f;\n\n  for (int t = 0; t < TRIBE_COUNT; t++) {\n    Tribe *tr = &tribes[t];\n    tr->wood = tr->stone = tr->gold = tr->food = 0;\n    tr->shards = tr->arrows = 0;\n\n    tr->tribe_id = t;\n    tr->color = colors[t % 4];\n    tr->base.position =\n        (Vector2){WORLD_SIZE / 2 + cosf(t * 2 * PI / TRIBE_COUNT) * spacing,\n                  WORLD_SIZE / 2 + sinf(t * 2 * PI / TRIBE_COUNT) * spacing};\n    tr->base.radius = BASE_RADIUS;\n    tr->integrity = 100.0f;\n    g_base_flat_height[t] =\n        terrain_height_raw(tr->base.position.x, tr->base.position.y);\n  }\n  g_tribes_ready = 1;\n}\n\nstatic void init_muze_runtime(void) {\n  if (g_muze_model)\n    return;\n  muze_config_init_defaults(&g_muze_cfg, OBS_DIM, ACTION_COUNT);\n  g_muze_cfg.model.latent_dim = 64;\n  g_muze_cfg.nn.hidden_repr = 128;\n  g_muze_cfg.nn.hidden_dyn = 128;\n  g_muze_cfg.nn.hidden_pred = 128;\n  g_muze_cfg.nn.hidden_vprefix = 128;\n  g_muze_cfg.nn.hidden_reward = 128;\n  g_muze_cfg.nn.action_embed_dim = 64;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"encode_observation","file":"game.c","line_start":5166,"line_end":5479,"snippet":"  g_muze_cfg.mcts.c_puct = 1.25f;\n  g_muze_cfg.mcts.max_depth = 16;\n  g_muze_cfg.mcts.dirichlet_alpha = 0.3f;\n  g_muze_cfg.mcts.dirichlet_eps = 0.25f;\n  g_muze_cfg.mcts.temperature = 1.0f;\n  g_muze_cfg.mcts.discount = 0.997f;\n\n  g_muze_cfg.trainer.batch_size = 64;\n  g_muze_cfg.trainer.train_steps = 50;\n  g_muze_cfg.trainer.min_replay_size = 2048;\n\n  g_muze_cfg.loop.iterations = 0;\n  g_muze_cfg.loop.selfplay_episodes_per_iter = 0;\n  g_muze_cfg.loop.selfplay_disable = 1;\n  g_muze_cfg.loop.train_calls_per_iter = 1;\n  g_muze_cfg.loop.use_reanalyze = 0;\n  g_muze_cfg.loop.eval_interval = 0;\n  g_muze_cfg.loop.checkpoint_interval = 0;\n  g_muze_cfg.loop.selfplay_actor_count = 2;\n  g_muze_cfg.loop.selfplay_use_threads = 1;\n\n  g_muze_model = mu_model_create_nn_with_cfg(&g_muze_cfg.model, &g_muze_cfg.nn);\n  g_muze_rb =\n      rb_create(200000, g_muze_cfg.model.obs_dim, g_muze_cfg.model.action_count,\n                g_muze_cfg.nn.support_size);\n  if (g_muze_cfg.nn.support_size > 1 && g_muze_rb)\n    rb_enable_value_support(g_muze_rb, g_muze_cfg.nn.support_size);\n\n  memset(&g_muze_loop, 0, sizeof(g_muze_loop));\n  g_muze_loop.model = g_muze_model;\n  g_muze_loop.rb = g_muze_rb;\n  g_muze_loop.gr = NULL;\n\n  g_muze_loop.mcts =\n      alloc_and_copy_struct(&g_muze_cfg.mcts, sizeof(g_muze_cfg.mcts));\n  g_muze_loop.selfplay =\n      alloc_and_copy_struct(&g_muze_cfg.selfplay, sizeof(g_muze_cfg.selfplay));\n  g_muze_loop.loop =\n      alloc_and_copy_struct(&g_muze_cfg.loop, sizeof(g_muze_cfg.loop));\n  g_muze_loop.env = muze_env_make_stub();\n  g_muze_loop.use_multi = 1;\n  g_muze_loop.model_mutex = &g_muze_model_mtx;\n  g_muze_loop.rb_mutex = &g_muze_rb_mtx;\n  g_muze_loop.gr_mutex = NULL;\n  g_muze_loop_rng_state = (uint32_t)time(NULL);\n  g_muze_loop.rng.ctx = &g_muze_loop_rng_state;\n  g_muze_loop.rng.rand01 = loop_rng01;\n\n  if (g_vision_id_max == 0) {\n    vision_id_map_init_defaults();\n  }\n\n  if (g_use_obs_transformer && !g_obs_transformer) {\n    g_obs_transformer = TRANSFORMER_init(OBS_TOKEN_DIM, 4, 2);\n    g_obs_token_count = (size_t)OBS_GRID_W * (size_t)OBS_GRID_H;\n    g_obs_token_buf = (long double *)calloc(g_obs_token_count * OBS_TOKEN_DIM,\n                                            sizeof(long double));\n    g_obs_tokens =\n        (long double **)calloc(g_obs_token_count, sizeof(long double *));\n    if (g_obs_token_buf && g_obs_tokens) {\n      for (size_t i = 0; i < g_obs_token_count; i++) {\n        g_obs_tokens[i] = g_obs_token_buf + i * OBS_TOKEN_DIM;\n      }\n    }\n  }\n}\n\nvoid init_agents(void) {\n  init_muze_runtime();\n\n  for (int i = 0; i < MAX_AGENTS; i++) {\n    Agent *a = &agents[i];\n    a->agent_id = i;\n    a->facing = (Vector2){1, 0};\n    a->alive = true;\n    a->health = a->stamina = 100;\n    a->flash_timer = 0;\n    a->age = 0;\n    a->agent_start = i;\n    a->reward_accumulator = 0.0f;\n\n    a->attack_cd = 0.0f;\n    a->harvest_cd = 0.0f;\n    a->fire_cd = 0.0f;\n\n    a->fire_latched = 0;\n    a->fire_latch_timer = 0.0f;\n\n    // Initialize jump fields\n    a->jump_timer = 0.0f;\n    a->jump_velocity = 0.0f;\n\n    a->inv_food = 0;\n    a->inv_arrows = 0;\n    a->inv_shards = 0;\n\n    a->has_axe = a->has_pickaxe = a->has_sword = a->has_armor = a->has_bow =\n        false;\n\n    a->tool_selected = TOOL_HAND;\n    a->last_craft_selected = -1;\n\n    a->last_action = ACTION_COUNT;\n    a->rng_state = (uint32_t)time(NULL) ^ (0x9e3779b9u * (uint32_t)(i + 1));\n\n    Tribe *tr = &tribes[i / AGENT_PER_TRIBE];\n    float ang = randf(0, 2 * PI);\n    float d = randf(2, tr->base.radius - 1);\n    a->position = (Vector2){tr->base.position.x + cosf(ang) * d,\n                            tr->base.position.y + sinf(ang) * d};\n  }\n}\n\n/* =======================\n   OBSERVATION & RL\n======================= */\nvoid encode_observation(Agent *a, Chunk *c, ObsBuffer *obs) {\n  Tribe *tr = &tribes[a->agent_id / AGENT_PER_TRIBE];\n  int cx = (int)(a->position.x / CHUNK_SIZE);\n  int cy = (int)(a->position.y / CHUNK_SIZE);\n  Vector2 chunk_origin =\n      (Vector2){(float)(cx * CHUNK_SIZE), (float)(cy * CHUNK_SIZE)};\n\n  // --- self status ---\n  obs_push(obs, clamp01(a->health / 100.0f));\n  obs_push(obs, clamp01(a->stamina / 100.0f));\n  obs_push(obs, a->facing.x);\n  obs_push(obs, a->facing.y);\n\n  // --- base features ---\n  Vector2 to_base = Vector2Subtract(tr->base.position, a->position);\n  float dbase = Vector2Length(to_base);\n  float base_dir_x = safe_norm(to_base.x, dbase);\n  float base_dir_y = safe_norm(to_base.y, dbase);\n\n  obs_push(obs, clamp01(dbase / 64.0f));\n  obs_push(obs, base_dir_x);\n  obs_push(obs, base_dir_y);\n  obs_push(obs, (dbase < tr->base.radius) ? 1.0f : 0.0f); // in base\n\n  // --- terrain context (3D) ---\n  float h0 =\n      g_use_perlin_ground ? terrain_height(a->position.x, a->position.y) : 0.0f;\n  obs_push(obs, clamp01(h0 / 12.0f));\n  float step = 6.0f;\n  float hx[8];\n  if (g_use_perlin_ground) {\n    hx[0] = terrain_height(a->position.x + step, a->position.y);\n    hx[1] = terrain_height(a->position.x - step, a->position.y);\n    hx[2] = terrain_height(a->position.x, a->position.y + step);\n    hx[3] = terrain_height(a->position.x, a->position.y - step);\n    hx[4] = terrain_height(a->position.x + step, a->position.y + step);\n    hx[5] = terrain_height(a->position.x - step, a->position.y - step);\n    hx[6] = terrain_height(a->position.x + step, a->position.y - step);\n    hx[7] = terrain_height(a->position.x - step, a->position.y + step);\n  } else {\n    for (int i = 0; i < 8; i++)\n      hx[i] = 0.0f;\n  }\n  for (int i = 0; i < 8; i++) {\n    float dh = clampf((hx[i] - h0) / 6.0f, -1.0f, 1.0f);\n    obs_push(obs, dh);\n  }\n\n  // --- chunk density ---\n  obs_push(obs, clamp01((float)c->resource_count / (float)MAX_RESOURCES));\n\n  // --- nearest resource (by type) in VIEW CHUNK ONLY (fast) ---\n  // Features: for each resource type [tree, rock, gold, food]:\n  //   - nearest distance (normalized)\n  //   - nearest direction (x,y) normalized\n  //   - availability bit (1 if found)\n  enum { R_TYPES = 4 };\n  float best_d[R_TYPES];\n  Vector2 best_dir[R_TYPES];\n  int found[R_TYPES];\n\n  for (int t = 0; t < R_TYPES; t++) {\n    best_d[t] = 1e9f;\n    best_dir[t] = (Vector2){0, 0};\n    found[t] = 0;\n  }\n\n  // We need this chunk's world origin\n  // NOTE: c is the chunk agent is currently in, so:\n  for (int i = 0; i < c->resource_count; i++) {\n    Resource *r = &c->resources[i];\n    if (r->health <= 0)\n      continue;\n    int t = (int)r->type;\n    if (t < 0 || t >= R_TYPES)\n      continue;\n\n    // Convert resource local -> world\n    Vector2 r_world = Vector2Add(chunk_origin, r->position);\n\n    Vector2 dvec = Vector2Subtract(r_world, a->position);\n    float d = Vector2Length(dvec);\n\n    if (d < best_d[t]) {\n      best_d[t] = d;\n      best_dir[t] = dvec;\n      found[t] = 1;\n    }\n  }\n\n  for (int t = 0; t < R_TYPES; t++) {\n    if (!found[t]) {\n      obs_push(obs, 1.0f); // distance \"far\"\n      obs_push(obs, 0.0f); // dir x\n      obs_push(obs, 0.0f); // dir y\n      obs_push(obs, 0.0f); // found bit\n    } else {\n      float d = best_d[t];\n      Vector2 v = best_dir[t];\n      obs_push(obs,\n               clamp01(d / 32.0f)); // normalize to something reasonable\n      obs_push(obs, safe_norm(v.x, d));\n      obs_push(obs, safe_norm(v.y, d));\n      obs_push(obs, 1.0f);\n    }\n  }\n\n  // --- nearest mob (any type) in this chunk ---\n  float best_mob_d = 1e9f;\n  Vector2 best_mob_dir = (Vector2){0, 0};\n  int mob_found = 0;\n  int mob_type = 0;\n\n  for (int i = 0; i < MAX_MOBS; i++) {\n    Mob *m = &c->mobs[i];\n    if (m->health <= 0)\n      continue;\n\n    Vector2 m_world = Vector2Add(chunk_origin, m->position);\n    Vector2 dvec = Vector2Subtract(m_world, a->position);\n    float d = Vector2Length(dvec);\n\n    if (d < best_mob_d) {\n      best_mob_d = d;\n      best_mob_dir = dvec;\n      mob_found = 1;\n      mob_type = (int)m->type;\n    }\n  }\n\n  if (!mob_found) {\n    obs_push(obs, 1.0f);\n    obs_push(obs, 0.0f);\n    obs_push(obs, 0.0f);\n    obs_push(obs, 0.0f);\n  } else {\n    obs_push(obs, clamp01(best_mob_d / 32.0f));\n    obs_push(obs, safe_norm(best_mob_dir.x, best_mob_d));\n    obs_push(obs, safe_norm(best_mob_dir.y, best_mob_d));\n    obs_push(obs, (float)mob_type / 3.0f); // 0..3 -> 0..1\n  }\n\n  // --- nearest HOSTILE mob in this chunk ---\n  float best_h_d = 1e9f;\n  Vector2 best_h_dir = (Vector2){0, 0};\n  int hostile_found = 0;\n\n  // --- nearest PASSIVE mob in this chunk ---\n  float best_p_d = 1e9f;\n  Vector2 best_p_dir = (Vector2){0, 0};\n  int passive_found = 0;\n\n  int hostile_count_near = 0; // within 6 units\n  int passive_count_near = 0;\n\n  for (int i = 0; i < MAX_MOBS; i++) {\n    Mob *m = &c->mobs[i];\n    if (m->health <= 0)\n      continue;\n\n    Vector2 m_world = Vector2Add(chunk_origin, m->position);\n    Vector2 dvec = Vector2Subtract(m_world, a->position);\n    float d = Vector2Length(dvec);\n\n    int hostile = mob_is_hostile(m->type);\n\n    if (d < 6.0f) {\n      if (hostile)\n        hostile_count_near++;\n      else\n        passive_count_near++;\n    }\n\n    if (hostile) {\n      if (d < best_h_d) {\n        best_h_d = d;\n        best_h_dir = dvec;\n        hostile_found = 1;\n      }\n    } else {\n      if (d < best_p_d) {\n        best_p_d = d;\n        best_p_dir = dvec;\n        passive_found = 1;\n      }\n    }\n  }\n\n  // hostile features\n  if (!hostile_found) {\n    obs_push(obs, 1.0f);\n    obs_push(obs, 0.0f);\n    obs_push(obs, 0.0f);\n    obs_push(obs, 0.0f);\n  } else {\n    obs_push(obs, clamp01(best_h_d / 32.0f));\n    obs_push(obs, safe_norm(best_h_dir.x, best_h_d));\n    obs_push(obs, safe_norm(best_h_dir.y, best_h_d));"},
  {"kind":"fn_def","vis":"PRIVATE","name":"update_agent","file":"game.c","line_start":5509,"line_end":5746,"snippet":"  if (!same_chunk) {\n    obs_push(obs, 1.0f); // far\n    obs_push(obs, 0.0f);\n    obs_push(obs, 0.0f);\n  } else {\n    obs_push(obs, clamp01(dP / 32.0f));\n    obs_push(obs, safe_norm(toP.x, dP));\n    obs_push(obs, safe_norm(toP.y, dP));\n  }\n\n  // facing (so forward-actions make sense)\n  obs_push(obs, a->facing.x);\n  obs_push(obs, a->facing.y);\n\n  // ----------------------------\n  // INVENTORY / TOOLS (compact)\n  // ----------------------------\n  float in_base01 = (dbase < tr->base.radius) ? 1.0f : 0.0f;\n\n  // inv open: for agents, \"inventory/crafting context is open\" == in base\n  obs_push(obs, in_base01);\n\n  // available tools for use (owned)\n  obs_push(obs, a->has_axe ? 1.0f : 0.0f);\n  obs_push(obs, a->has_pickaxe ? 1.0f : 0.0f);\n  obs_push(obs, a->has_sword ? 1.0f : 0.0f);\n  obs_push(obs, a->has_armor ? 1.0f : 0.0f);\n  obs_push(obs, a->has_bow ? 1.0f : 0.0f);\n\n  // selected tool one-hot across TOOL_COUNT\n  for (int i = 0; i < TOOL_COUNT; i++) {\n    obs_push(obs, (a->tool_selected == i) ? 1.0f : 0.0f);\n  }\n\n  // provide selected tool as a single continuous scalar (helps learning)\n  obs_push(obs, (float)a->tool_selected / (float)(TOOL_COUNT - 1));\n\n  // ----------------------------\n  // EXTRA CONTEXT (small, helps policy)\n  // ----------------------------\n\n  // day/night (helps survival & raid behavior)\n  obs_push(obs, is_night_cached ? 1.0f : 0.0f);\n\n  // time of day as sin/cos (smooth cyclical signal)\n  float ang = time_of_day * 2.0f * PI;\n  obs_push(obs, sinf(ang));\n  obs_push(obs, cosf(ang));\n\n  // base integrity (per tribe)\n  obs_push(obs, clamp01(tr->integrity / 100.0f));\n\n  // tribe resources snapshot (normalize softly to avoid huge values\n  // dominating)\n  obs_push(obs, clamp01((float)tr->wood / 30.0f));\n  obs_push(obs, clamp01((float)tr->stone / 30.0f));\n  obs_push(obs, clamp01((float)tr->gold / 30.0f));\n  obs_push(obs, clamp01((float)tr->food / 30.0f));\n  obs_push(obs, clamp01((float)tr->shards / 30.0f));\n  obs_push(obs, clamp01((float)tr->arrows / 60.0f));\n\n  // agent personal inventory (important for eat/fire decisions)\n  obs_push(obs, clamp01((float)a->inv_food / 10.0f));\n  obs_push(obs, clamp01((float)a->inv_shards / 10.0f));\n  obs_push(obs, clamp01((float)a->inv_arrows / 20.0f));\n\n  // cooldown fractions (0=ready, 1=on cooldown)\n  obs_push(obs, clamp01(a->attack_cd / agent_attack_cooldown()));\n  obs_push(obs, clamp01(a->harvest_cd / agent_harvest_cooldown()));\n  obs_push(obs, clamp01(a->fire_cd / agent_fire_cooldown()));\n\n  if (g_use_obs_transformer && g_obs_transformer && g_obs_tokens &&\n      g_obs_token_count > 0) {\n    // Temporarily disable transformer to isolate memory corruption\n    for (int i = 0; i < OBS_EMBED_DIM; i++)\n      obs_push(obs, 0.0f);\n  } else {\n    for (int i = 0; i < OBS_EMBED_DIM; i++)\n      obs_push(obs, 0.0f);\n  }\n\n  // bias\n  obs_push(obs, 1.0f);\n\n  // final: enforce fixed-size vector\n  obs_finalize_fixed(obs, OBS_DIM);\n}\n\nstatic int agent_face_nearest_mob_in_chunk(Agent *a, Chunk *c, int cx, int cy,\n                                           float maxRange) {\n  Vector2 origin =\n      (Vector2){(float)(cx * CHUNK_SIZE), (float)(cy * CHUNK_SIZE)};\n  float bestD = 1e9f;\n  Vector2 bestDir = {0};\n\n  for (int i = 0; i < MAX_MOBS; i++) {\n    Mob *m = &c->mobs[i];\n    if (m->health <= 0)\n      continue;\n\n    Vector2 mw = Vector2Add(origin, m->position);\n    Vector2 dv = Vector2Subtract(mw, a->position);\n    float d = Vector2Length(dv);\n    if (d < bestD && d <= maxRange) {\n      bestD = d;\n      bestDir = dv;\n    }\n  }\n\n  if (bestD >= 1e8f)\n    return 0;\n  agent_set_facing_from(bestDir, a);\n  return 1;\n}\n\n/* =======================\n   AGENT UPDATE\n======================= */\nvoid update_agent(Agent *a) {\n  if (!a || !a->alive)\n    return;\n\n  float dt = g_dt;\n  if (dt <= 0.0f)\n    dt = 1.0f / 60.0f;\n\n  Tribe *tr = &tribes[a->agent_id / AGENT_PER_TRIBE];\n\n  // --- timers ---\n  if (a->attack_cd > 0.0f)\n    a->attack_cd -= dt;\n  if (a->harvest_cd > 0.0f)\n    a->harvest_cd -= dt;\n  if (a->fire_cd > 0.0f)\n    a->fire_cd -= dt;\n  if (a->flash_timer > 0.0f)\n    a->flash_timer -= dt;\n  if (a->jump_timer > 0.0f)\n    a->jump_timer -= dt;\n  if (a->fire_latch_timer > 0.0f) {\n    a->fire_latch_timer -= dt;\n    if (a->fire_latch_timer <= 0.0f) {\n      a->fire_latch_timer = 0.0f;\n      a->fire_latched = 0;\n    }\n  }\n\n  // --- passive environment dynamics (NOT policy overrides) ---\n  float dBase = Vector2Distance(a->position, tr->base.position);\n  bool in_base = (dBase < tr->base.radius + 0.35f);\n\n  if (in_base) {\n    a->health = fminf(100.0f, a->health + 10.0f * dt);\n    a->stamina = fminf(100.0f, a->stamina + 24.0f * dt);\n  } else {\n    a->stamina = fminf(100.0f, a->stamina + (STAMINA_REGEN_RATE * 0.55f) * dt);\n  }\n\n  // --- build observation ---\n  int cx = (int)(a->position.x / CHUNK_SIZE);\n  int cy = (int)(a->position.y / CHUNK_SIZE);\n  Chunk *c = get_chunk(cx, cy);\n\n  ObsBuffer obs;\n  obs_init(&obs);\n\n  pthread_rwlock_rdlock(&c->lock);\n  encode_observation(a, c, &obs);\n  pthread_rwlock_unlock(&c->lock);\n\n  // --- MuZero chooses action ---\n  float pi[ACTION_COUNT];\n  int action = 0;\n  int have_mcts = 0;\n  for (int i = 0; i < ACTION_COUNT; i++)\n    pi[i] = 1.0f / (float)ACTION_COUNT;\n\n  if (pthread_mutex_trylock(&g_muze_model_mtx) == 0 && g_muze_model) {\n    MCTSRng rng = {.ctx = a, .rand01 = agent_rng01};\n    MCTSParams mp;\n    memcpy(&mp, &g_muze_cfg.mcts, sizeof(mp));\n    MCTSResult mr = mcts_run(g_muze_model, obs.data, &mp, &rng);\n    pthread_mutex_unlock(&g_muze_model_mtx);\n    for (int i = 0; i < ACTION_COUNT; i++)\n      pi[i] = mr.pi[i];\n    action = sample_action(pi, ACTION_COUNT, agent_rng01(a));\n    mcts_result_free(&mr);\n    have_mcts = 1;\n  }\n\n  if (!have_mcts) {\n    action = rand() % ACTION_COUNT;\n  }\n\n  a->last_action = action;\n\n  // tool selection is \"sticky\" but reacts to actions\n  if (action == ACTION_ATTACK) {\n    a->tool_selected = a->has_sword ? TOOL_SWORD : TOOL_HAND;\n  } else if (action == ACTION_HARVEST) {\n    if (a->has_pickaxe)\n      a->tool_selected = TOOL_PICKAXE;\n    else if (a->has_axe)\n      a->tool_selected = TOOL_AXE;\n    else\n      a->tool_selected = TOOL_HAND;\n  } else if (action == ACTION_FIRE) {\n    a->tool_selected = (a->has_bow ? TOOL_BOW : TOOL_HAND);\n  }\n  if (action == ACTION_FIRE) {\n    a->fire_latched = 1;\n    a->fire_latch_timer = AGENT_FIRE_LATCH_TIME;\n  }\n\n  // --- execute ---\n  float reward = 0.0f;\n\n  Vector2 moveDir = {0, 0};\n  switch (action) {\n  case ACTION_UP:\n    moveDir = (Vector2){0, -1};\n    break;\n  case ACTION_DOWN:\n    moveDir = (Vector2){0, 1};\n    break;\n  case ACTION_LEFT:\n    moveDir = (Vector2){-1, 0};\n    break;\n  case ACTION_RIGHT:\n    moveDir = (Vector2){1, 0};\n    break;\n\n  case ACTION_ATTACK:\n    // No targeting assist. Attack in facing direction.\n    agent_try_attack_forward(a, tr, &reward);\n    break;\n\n  case ACTION_HARVEST:"},
  {"kind":"fn_def","vis":"PRIVATE","name":"nearest_base_idx","file":"game.c","line_start":5782,"line_end":5801,"snippet":"      a->stamina -= 15.0f;\n      reward += 0.05f; // Small reward for jumping\n\n      // Bonus reward for strategic jumping (when near obstacles or enemies)\n      Vector2 agent_pos = a->position;\n      if (is_near_obstacle_or_target(agent_pos, 5.0f)) {\n        reward += 0.02f; // Bonus for strategic jumping\n      }\n    }\n    break;\n\n  default:\n    // If they do nothing, you can optionally punish \"doing nothing\"\n    // reward += -0.002f;\n    break;\n  }\n\n  // --- continuous fire: if latched, keep attempting to fire as soon as CD\n  if (a->fire_latched) {\n    if (action != ACTION_FIRE) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"update_mob_ai","file":"game.c","line_start":5812,"line_end":6024,"snippet":"  // Movement\n  agent_try_move(a, moveDir);\n\n  // Facing updates only when moved\n  if (moveDir.x != 0.0f || moveDir.y != 0.0f) {\n    agent_set_facing_from(moveDir, a);\n    if (moveDir.x != 0.0f || moveDir.y != 0.0f)\n      reward += R_WANDER_PENALTY;\n  }\n\n#if AGENT_FIRE_CANCEL_ON_MOVE\n  if (moveDir.x != 0.0f || moveDir.y != 0.0f) {\n    a->fire_latched = 0;\n    a->fire_latch_timer = 0.0f;\n  }\n#endif\n\n  // --- survival shaping ---\n  if (a->health <= 0.0f) {\n    a->health = 0.0f;\n    a->alive = false;\n    reward += R_DEATH;\n  } else {\n    reward += R_SURVIVE_PER_TICK;\n  }\n\n  int done_flag = a->alive ? 0 : 1;\n\n  // --- push replay sample ---\n  if (g_muze_rb) {\n    ObsBuffer next_obs;\n    obs_init(&next_obs);\n    int ncx = (int)(a->position.x / CHUNK_SIZE);\n    int ncy = (int)(a->position.y / CHUNK_SIZE);\n    Chunk *nc = get_chunk(ncx, ncy);\n    pthread_rwlock_rdlock(&nc->lock);\n    encode_observation(a, nc, &next_obs);\n    pthread_rwlock_unlock(&nc->lock);\n\n    pthread_mutex_lock(&g_muze_rb_mtx);\n    size_t idx = rb_push_full(g_muze_rb, obs.data, pi, &reward, action, &reward,\n                              next_obs.data, done_flag);\n    rb_set_value_prefix(g_muze_rb, idx, reward);\n    pthread_mutex_unlock(&g_muze_rb_mtx);\n\n    obs_free(&next_obs);\n  }\n\n  obs_free(&obs);\n\n  a->reward_accumulator += reward;\n  a->age++;\n}\n\n// ------------------------------------------------------------\n// Nearest agent lookup (WORLD space) in a given chunk\n// ------------------------------------------------------------\n// ------------------------------------------------------------\n// Nearest agent finder (same chunk only)\n// ------------------------------------------------------------\nstatic Agent *nearest_agent_in_chunk(int cx, int cy, Vector2 mob_world_pos,\n                                     float *outDist) {\n  Agent *best = NULL;\n  float bestD = 1e9f;\n\n  for (int i = 0; i < MAX_AGENTS; i++) {\n    Agent *a = &agents[i];\n    if (!a->alive)\n      continue;\n\n    int acx = (int)(a->position.x / CHUNK_SIZE);\n    int acy = (int)(a->position.y / CHUNK_SIZE);\n    if (acx != cx || acy != cy)\n      continue;\n\n    float d = Vector2Distance(mob_world_pos, a->position);\n    if (d < bestD) {\n      bestD = d;\n      best = a;\n    }\n  }\n\n  if (outDist)\n    *outDist = bestD;\n  return best;\n}\n\n// Small helper: nearest base (pos + index)\nstatic int nearest_base_idx(Vector2 wp, Vector2 *outPos, float *outDist) {\n  int bestI = 0;\n  float bestD = 1e9f;\n  Vector2 bestP = tribes[0].base.position;\n\n  for (int t = 0; t < TRIBE_COUNT; t++) {\n    float d = Vector2Distance(wp, tribes[t].base.position);\n    if (d < bestD) {\n      bestD = d;\n      bestI = t;\n      bestP = tribes[t].base.position;\n    }\n  }\n\n  if (outPos)\n    *outPos = bestP;\n  if (outDist)\n    *outDist = bestD;\n  return bestI;\n}\n\n// ------------------------------------------------------------\n// Mob AI (rewrite)\n//  - passive: wander, flee player/agents if close or recently hit\n//  (aggro_timer)\n//  - hostile: chase nearest player/agent in SAME chunk; otherwise drift to\n//  nearest base\n//  - hostile attacks: player/agent if in range, else base if close\n//  - keeps mobs chunk-local (no cross-chunk migration)\n// ------------------------------------------------------------\nstatic void update_mob_ai(Mob *m, Vector2 chunk_origin, float dt) {\n  if (!m || m->health <= 0)\n    return;\n\n  // ---- timers ----\n  if (m->ai_timer > 0.0f)\n    m->ai_timer -= dt;\n  if (m->aggro_timer > 0.0f)\n    m->aggro_timer -= dt;\n  if (m->attack_cd > 0.0f)\n    m->attack_cd -= dt;\n  if (m->hurt_timer > 0.0f)\n    m->hurt_timer -= dt;\n  if (m->lunge_timer > 0.0f)\n    m->lunge_timer -= dt;\n\n  // ---- world pos ----\n  Vector2 mw = Vector2Add(chunk_origin, m->position);\n\n  int mcx = (int)(mw.x / CHUNK_SIZE);\n  int mcy = (int)(mw.y / CHUNK_SIZE);\n\n  // player chunk check (cheap)\n  int pcx = (int)(player.position.x / CHUNK_SIZE);\n  int pcy = (int)(player.position.y / CHUNK_SIZE);\n  bool player_same_chunk = (pcx == mcx && pcy == mcy);\n\n  // hostile?\n  bool hostile = (m->type == MOB_ZOMBIE || m->type == MOB_SKELETON);\n\n  // ---- wander direction refresh ----\n  if (m->ai_timer <= 0.0f) {\n    m->ai_timer = randf(0.35f, 1.25f);\n    float ang = randf(0.0f, 2.0f * PI);\n    m->vel = (Vector2){cosf(ang), sinf(ang)};\n  }\n\n  // ---- find nearest base ----\n  Vector2 basePos = {0};\n  float dBase = 0.0f;\n  int baseIdx = nearest_base_idx(mw, &basePos, &dBase);\n\n  Vector2 toBase = Vector2Subtract(basePos, mw);\n  float baseLen = Vector2Length(toBase);\n  Vector2 dirBase = (baseLen > 1e-3f) ? Vector2Scale(toBase, 1.0f / baseLen)\n                                      : (Vector2){0, 0};\n\n  // ---- find nearest agent in this chunk (hostiles care) ----\n  float dA = 1e9f;\n  Agent *targetA = nearest_agent_in_chunk(mcx, mcy, mw, &dA);\n\n  // ---- compute player vector ----\n  Vector2 toP = Vector2Subtract(player.position, mw);\n  float dP = Vector2Length(toP);\n  Vector2 dirP = (dP > 1e-3f) ? Vector2Scale(toP, 1.0f / dP) : (Vector2){0, 0};\n\n  // ---- decide target (hostiles) ----\n  bool player_targetable = player_same_chunk && (dP <= MOB_AGGRO_RANGE);\n  bool agent_targetable = (targetA != NULL) && (dA <= MOB_AGGRO_RANGE);\n\n  // choose nearer of (player, agent) if both exist\n  int target_kind = 0; // 0 none, 1 player, 2 agent, 3 base\n  Vector2 targetPos = mw;\n  float targetDist = 1e9f;\n  Vector2 targetDir = (Vector2){0, 0};\n\n  if (hostile) {\n    if (player_targetable && (!agent_targetable || dP <= dA)) {\n      target_kind = 1;\n      targetPos = player.position;\n      targetDist = dP;\n      targetDir = dirP;\n    } else if (agent_targetable) {\n      target_kind = 2;\n      targetPos = targetA->position;\n      targetDist = dA;\n\n      Vector2 toA = Vector2Subtract(targetA->position, mw);\n      float al = Vector2Length(toA);\n      targetDir = (al > 1e-3f) ? Vector2Scale(toA, 1.0f / al) : (Vector2){0, 0};\n    } else {\n      // nobody in chunk -> pressure base (especially at night)\n      target_kind = 3;\n      targetPos = basePos;\n      targetDist = dBase;\n      targetDir = dirBase;\n    }\n  }\n\n  // ---- speed + steering ----\n  float speed = MOB_SPEED_PASSIVE;\n\n  if (!hostile) {\n    // Passive: flee if player/agent close OR recently hit (aggro_timer)\n    bool scared = (m->aggro_timer > 0.0f);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_crafting_ui","file":"game.c","line_start":6026,"line_end":6051,"snippet":"    // if player close in same chunk, scared\n    if (player_same_chunk && dP < 4.0f)\n      scared = true;\n\n    // also flee nearest agent if close (helps agents feel real)\n    if (targetA && dA < 4.0f)\n      scared = true;\n\n    if (scared) {\n      speed = MOB_SPEED_SCARED;\n\n      // flee from the closer threat (player vs agent)\n      Vector2 fleeDir = {0};\n      if (player_same_chunk && (!targetA || dP <= dA)) {\n        fleeDir = Vector2Scale(dirP, -1.0f);\n      } else if (targetA) {\n        Vector2 toA = Vector2Subtract(targetA->position, mw);\n        float al = Vector2Length(toA);\n        Vector2 dirA =\n            (al > 1e-3f) ? Vector2Scale(toA, 1.0f / al) : (Vector2){0, 0};\n        fleeDir = Vector2Scale(dirA, -1.0f);\n      } else {\n        // no known threat direction, just keep wander vel\n        fleeDir = m->vel;\n      }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"spawn_player_in_base","file":"game.c","line_start":6054,"line_end":6061,"snippet":"      speed = MOB_SPEED_PASSIVE;\n      // keep wander vel\n    }\n  } else {\n    // Hostile: chase/pressure\n    speed = MOB_SPEED_HOSTILE;\n\n    // if targeting base but it's daytime, chill a bit"},
  {"kind":"fn_def","vis":"PRIVATE","name":"init_player","file":"game.c","line_start":6063,"line_end":6073,"snippet":"      speed *= 0.65f;\n\n    // strong steering toward target\n    if (target_kind != 0) {\n      m->vel = targetDir;\n    }\n  }\n\n  // normalize vel if needed\n  float vlen = Vector2Length(m->vel);\n  if (vlen > 1e-3f)"},
  {"kind":"fn_def","vis":"PRIVATE","name":"update_player","file":"game.c","line_start":6075,"line_end":6333,"snippet":"\n  // ---- attacks (hostiles only) ----\n  if (hostile) {\n    // attack player/agent if in range\n    if (target_kind == 1 && player_same_chunk &&\n        targetDist <= MOB_ATTACK_RANGE) {\n      if (m->attack_cd <= 0.0f) {\n        m->attack_cd = 0.80f;\n        m->lunge_timer = 0.12f;\n\n        player.health -= (float)PLAYER_TAKEN_DAMAGE;\n        player_hurt_timer = 0.16f;\n        cam_shake = fmaxf(cam_shake, 0.10f);\n      }\n    } else if (target_kind == 2 && targetA && targetDist <= MOB_ATTACK_RANGE) {\n      if (m->attack_cd <= 0.0f) {\n        m->attack_cd = 0.85f;\n        m->lunge_timer = 0.12f;\n\n        targetA->health -= (float)AGENT_TAKEN_DAMAGE;\n        targetA->flash_timer = 0.16f;\n        cam_shake = fmaxf(cam_shake, 0.08f);\n\n        // keep them aggro after hitting\n        m->aggro_timer = fmaxf(m->aggro_timer, 2.0f);\n      }\n    } else if (target_kind == 3) {\n      // base pressure if close\n      Tribe *tr = &tribes[baseIdx];\n      float reach = tr->base.radius + 1.05f;\n      if (dBase <= reach && m->attack_cd <= 0.0f) {\n        m->attack_cd = 1.10f;\n        m->lunge_timer = 0.10f;\n\n        tr->integrity = fmaxf(0.0f, tr->integrity - 2.25f);\n        cam_shake = fmaxf(cam_shake, 0.06f);\n      }\n    }\n  }\n\n  // ---- move (chunk-local; avoid crossing chunks) ----\n  Vector2 step = Vector2Scale(m->vel, speed * dt);\n  Vector2 nextW = Vector2Add(mw, step);\n\n  // collision test against nearby generated things (simple)\n  if (world_pos_blocked_nearby(mcx, mcy, nextW, mob_radius_world(m->type), mcx,\n                               mcy)) {\n    // bounce: flip direction and try a smaller step\n    m->vel = Vector2Scale(m->vel, -1.0f);\n    step = Vector2Scale(m->vel, speed * dt * 0.35f);\n    nextW = Vector2Add(mw, step);\n  }\n\n  // convert to local position and clamp in chunk\n  Vector2 nextLocal = Vector2Subtract(nextW, chunk_origin);\n\n  // if trying to leave the chunk, bounce back inward\n  if (nextLocal.x < 0.25f || nextLocal.x > (float)CHUNK_SIZE - 0.25f) {\n    m->vel.x = -m->vel.x;\n    nextLocal.x = clampf(nextLocal.x, 0.25f, (float)CHUNK_SIZE - 0.25f);\n  }\n  if (nextLocal.y < 0.25f || nextLocal.y > (float)CHUNK_SIZE - 0.25f) {\n    m->vel.y = -m->vel.y;\n    nextLocal.y = clampf(nextLocal.y, 0.25f, (float)CHUNK_SIZE - 0.25f);\n  }\n\n  m->position = nextLocal;\n}\n\nstatic void draw_crafting_ui(void) {\n  if (!crafting_open)\n    return;\n\n  int x = 14, y = 260, w = 360, h = 28 + recipe_count * 22;\n  // OpenGL equivalent of DrawRectangle - temporarily disabled\n  // glBegin(GL_QUADS);\n  // glColor4f(0.0f, 0.0f, 0.0f, 120.0f/255.0f);\n  // glVertex2f(x, y);\n  // glVertex2f(x + w, y);\n  // glVertex2f(x + w, y + h);\n  // glVertex2f(x, y + h);\n  // glEnd();\n  draw_rectangle_outline_opengl(x, y, w, h, (Color){0, 0, 0, 220});\n  DrawText(\"Crafting (TAB)\", x + 10, y + 6, 18, RAYWHITE);\n\n  for (int i = 0; i < recipe_count; i++) {\n    Recipe *r = &recipes[i];\n    Color c = can_afford(r) ? RAYWHITE : (Color){180, 180, 180, 255};\n\n    DrawText(TextFormat(\"%d) %s  [W%d S%d G%d F%d]%s\", i + 1, r->name, r->wood,\n                        r->stone, r->gold, r->food,\n                        (r->unlock_flag && *r->unlock_flag) ? \" (OWNED)\" : \"\"),\n             x + 10, y + 30 + i * 20, 16, c);\n  }\n}\n\n/* =======================\n   PLAYER\n======================= */\nstatic Vector2 spawn_player_in_base(void) {\n  if (TRIBE_COUNT > 0) {\n    Tribe *tr = &tribes[0];\n    float d = fmaxf(0.75f, tr->base.radius * 0.25f);\n    return (Vector2){tr->base.position.x + d, tr->base.position.y};\n  }\n  return (Vector2){WORLD_SIZE / 2, WORLD_SIZE / 2};\n}\n\nvoid init_player(void) {\n  player.position = spawn_player_in_base();\n  player.facing = (Vector2){0, 0};\n  player.health = 100;\n  player.stamina = 100;\n  g_player_y_offset = 0.0f;\n  g_player_vy = 0.0f;\n  g_player_on_ground = 1;\n  g_player_yaw = 0.0f;\n  g_player_yaw_target = 0.0f;\n}\n\nvoid update_player(void) {\n  float dt = GetFrameTime();\n  if (dt <= 0.0f)\n    dt = 1.0f / 60.0f;\n\n  // --- cooldown timers ---\n  if (player_harvest_cd > 0.0f)\n    player_harvest_cd -= dt;\n  if (player_attack_cd > 0.0f)\n    player_attack_cd -= dt;\n  if (player_fire_cd > 0.0f)\n    player_fire_cd -= dt;\n  if (player_hurt_timer > 0.0f)\n    player_hurt_timer -= dt;\n\n  // --- stamina regen (player) ---\n  // tweak as you like:\n  player.stamina = fminf(100.0f, player.stamina + STAMINA_REGEN_RATE * dt);\n\n  // --- movement ---\n  if (g_use_3d) {\n    Vector2 md = GetMouseDelta();\n    float sens = 0.0045f;\n\n    // If mouse is locked but delta is 0, try manual position tracking\n    if (g_mouse_locked && (md.x == 0 && md.y == 0)) {\n      static Vector2 last_mouse_pos = {0};\n      Vector2 current_pos = GetMousePosition();\n      if (last_mouse_pos.x != 0 && last_mouse_pos.y != 0) {\n        md.x = current_pos.x - last_mouse_pos.x;\n        md.y = current_pos.y - last_mouse_pos.y;\n        // Reset mouse to center\n        int mw = GetScreenWidth();\n        int mh = GetScreenHeight();\n        if (mw > 0 && mh > 0) {\n          SetMousePosition(mw / 2, mh / 2);\n        }\n      }\n      last_mouse_pos = GetMousePosition();\n    }\n\n    g_player_yaw += md.x * sens;\n    g_player_yaw = wrap_pi(g_player_yaw);\n    g_player_yaw_target = g_player_yaw;\n    g_player_pitch += -md.y * sens;\n    g_player_pitch = clampf(g_player_pitch, -1.2f, 1.2f);\n  }\n\n  float speed = 0.6f;\n  int sprinting = g_use_3d && bind_down(BIND_SPRINT) && player.stamina > 1.0f;\n  if (sprinting) {\n    speed *= 1.8f;\n  }\n  float move = speed;\n\n  Vector2 fwd = (Vector2){sinf(g_player_yaw), -cosf(g_player_yaw)};\n  Vector2 right = (Vector2){cosf(g_player_yaw), sinf(g_player_yaw)};\n  Vector2 wish = (Vector2){0, 0};\n\n  if (bind_down(BIND_MOVE_FORWARD))\n    wish = Vector2Add(wish, fwd);\n  if (bind_down(BIND_MOVE_BACK))\n    wish = Vector2Subtract(wish, fwd);\n  if (bind_down(BIND_MOVE_RIGHT))\n    wish = Vector2Add(wish, right);\n  if (bind_down(BIND_MOVE_LEFT))\n    wish = Vector2Subtract(wish, right);\n\n  bool moving = (fabsf(wish.x) > 0.001f || fabsf(wish.y) > 0.001f);\n  if (moving) {\n    wish = Vector2Normalize(wish);\n    player.position.x += wish.x * move;\n    player.position.y += wish.y * move;\n  }\n\n  player.facing.x = fwd.x;\n  player.facing.y = fwd.y;\n\n  if (g_use_3d) {\n    float world_span = (float)(WORLD_SIZE * CHUNK_SIZE);\n    player.position.x = clampf(player.position.x, 0.0f, world_span);\n    player.position.y = clampf(player.position.y, 0.0f, world_span);\n  }\n\n  resolve_player_collisions();\n  // --- zoom controls ---\n  if (IsKeyDown(KEY_EQUAL))\n    target_world_scale += 60.0f * dt;\n  if (IsKeyDown(KEY_MINUS))\n    target_world_scale -= 60.0f * dt;\n  target_world_scale = clampf(target_world_scale, 0.0f, 100.0f);\n\n  // optional: tiny stamina drain while moving\n  if (moving) {\n    float drain = STAMINA_DRAIN_RATE;\n    if (sprinting)\n      drain *= 3.0f;\n    player.stamina = fmaxf(0.0f, player.stamina - drain * dt);\n  }\n\n  // Enhanced jump mechanics with variable height and better physics\n  if (g_use_3d) {\n    // Variable jump height - hold longer for higher jump\n    static int jump_held = 0;\n    static float jump_charge_time = 0.0f;\n    const float MAX_JUMP_CHARGE = 0.3f; // Max charge time for highest jump\n    const float MIN_JUMP_SPEED = PLAYER_JUMP_SPEED * 0.6f; // Minimum jump speed\n    const float MAX_JUMP_SPEED = PLAYER_JUMP_SPEED * 1.2f; // Maximum jump speed\n\n    // Check for jump initiation\n    if ((IsKeyPressed_SDL_SPACE || IsKeyPressed_SDL_F) &&\n        g_player_on_ground && player.stamina >= 10.0f) {\n      jump_held = 1;\n      jump_charge_time = 0.0f;\n      g_player_vy = MIN_JUMP_SPEED; // Start with minimum jump\n      g_player_on_ground = 0;\n      player.stamina -= 10.0f; // Initial stamina cost\n    }\n\n    // Continue charging jump while button is held (but only for a short time)\n    if (jump_held && (IsKeyDown_SDL_SPACE || IsKeyDown_SDL_F) &&\n        jump_charge_time < MAX_JUMP_CHARGE) {\n      jump_charge_time += dt;\n      float charge_ratio = jump_charge_time / MAX_JUMP_CHARGE;\n      g_player_vy = lerp(MIN_JUMP_SPEED, MAX_JUMP_SPEED, charge_ratio);\n\n      // Additional stamina cost for higher jumps\n      if (jump_charge_time > 0.1f) {\n        player.stamina -= 5.0f * dt; // Continuous stamina drain while charging\n      }\n    }\n\n    // Release jump button - stop charging\n    if (!(IsKeyDown(KEY_SPACE) || IsKeyDown(KEY_F))) {\n      jump_held = 0;\n    }\n\n    // Apply gravity with better physics\n    g_player_vy -= PLAYER_GRAVITY * dt;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"update_visible_world","file":"game.c","line_start":6335,"line_end":6479,"snippet":"    // Add air resistance for more realistic falling\n    if (g_player_vy < 0) {   // Falling\n      g_player_vy *= 0.995f; // Slight air resistance\n    }\n\n    g_player_y_offset += g_player_vy * dt;\n\n    // Landing detection with small forgiveness\n    if (g_player_y_offset <= -0.1f) {\n      g_player_y_offset = 0.0f;\n      g_player_vy = 0.0f;\n      g_player_on_ground = 1;\n      jump_held = 0;\n      jump_charge_time = 0.0f;\n\n      // Small landing recovery - brief stamina regeneration\n      if (player.stamina < 100.0f) {\n        player.stamina = fminf(100.0f, player.stamina + 2.0f);\n      }\n    }\n  }\n\n  // --- crafting toggle ---\n  if (IsKeyPressed_SDL_TAB) {\n    crafting_open = !crafting_open;\n  }\n\n  // --- crafting input (1..9) only when crafting menu is open ---\n  if (crafting_open) {\n    // TODO: Replace with SDL input handling\n    /*\n    for (int i = 0; i < recipe_count && i < 9; i++) {\n      bool pressed = IsKeyPressed((KeyboardKey)(KEY_ONE + i));\n      pressed = pressed || IsKeyPressed((KeyboardKey)(KEY_KP_1 + i));\n      if (pressed)\n        craft(&recipes[i]);\n    }\n    */\n  }\n\n  // =========================\n  // CONTINUOUS HOLD ACTIONS\n  // =========================\n\n  // (A) Continuous melee attack (hold LEFT mouse or attack keybind)\n  if (IsMouseButtonDown(MOUSE_BUTTON_LEFT) || bind_down(BIND_ATTACK)) {\n    int cx = (int)(player.position.x / CHUNK_SIZE);\n    int cy = (int)(player.position.y / CHUNK_SIZE);\n    Chunk *c = get_chunk(cx, cy);\n\n    // player_try_attack_mob_in_chunk modifies mobs -> take write lock\n    pthread_rwlock_wrlock(&c->lock);\n    player_try_attack_forward(player.facing);\n    pthread_rwlock_unlock(&c->lock);\n  }\n\n  // (B) Continuous harvest/mine (hold RIGHT mouse or harvest keybind)\n  if (IsMouseButtonDown(MOUSE_BUTTON_RIGHT) || bind_down(BIND_HARVEST)) {\n    int cx = (int)(player.position.x / CHUNK_SIZE);\n    int cy = (int)(player.position.y / CHUNK_SIZE);\n    Chunk *c = get_chunk(cx, cy);\n\n    // player_try_harvest_resource_in_chunk modifies resources -> write lock\n    pthread_rwlock_wrlock(&c->lock);\n    player_try_harvest_forward(player.facing);\n    pthread_rwlock_unlock(&c->lock);\n  }\n\n  // =========================\n  // BOW CHARGE + RELEASE (F)\n  // =========================\n  // Hold F to charge, release F to fire (if enough charge).\n  if (has_bow) {\n    if (bind_down(BIND_FIRE)) {\n      bow_charging = 1;\n      bow_charge01 += dt / BOW_CHARGE_TIME;\n      bow_charge01 = clamp01(bow_charge01);\n    }\n\n    // Release to fire (continuous-ready through player_fire_cd)\n    if (bow_charging && bind_released(BIND_FIRE)) {\n      bow_charging = 0;\n\n      if (player_fire_cd <= 0.0f && inv_arrows > 0 &&\n          bow_charge01 >= BOW_CHARGE_MIN01) {\n        // aim from player -> mouse in WORLD space\n        Vector2 mouse = GetMousePosition();\n        // Use current screen dimensions, not cached ones\n        int current_w = GetScreenWidth();\n        int current_h = GetScreenHeight();\n        Vector2 mouse_world = {\n            (mouse.x - current_w * 0.5f) / WORLD_SCALE + camera_pos.x,\n            (mouse.y - current_h * 0.5f) / WORLD_SCALE + camera_pos.y};\n\n        Vector2 dir = Vector2Subtract(mouse_world, player.position);\n        if (Vector2Length(dir) < 1e-3f)\n          dir = (Vector2){1, 0};\n        dir = Vector2Normalize(dir);\n\n        // consume ammo + set cooldown\n        inv_arrows--;\n        player_fire_cd = PLAYER_FIRE_COOLDOWN;\n\n        // Add damage number for arrow shot\n        if (damage_number_count < MAX_DAMAGE_NUMBERS) {\n          damage_numbers[damage_number_count].pos = player.position;\n          damage_numbers[damage_number_count].value = 10.0f; // Arrow damage\n          damage_numbers[damage_number_count].timer = 2.0f;\n          damage_numbers[damage_number_count].color =\n              (Color){255, 255, 100, 255};\n          damage_number_count++;\n        }\n\n        // uses your existing charged fire helper\n        player_fire_bow_charged(dir, bow_charge01);\n      }\n\n      // reset charge after release regardless\n      bow_charge01 = 0.0f;\n    }\n  } else {\n    // if you don't have bow, ensure charge is off\n    bow_charging = 0;\n    bow_charge01 = 0.0f;\n  }\n}\n\nstatic void update_visible_world(float dt) {\n  int pcx = (int)(player.position.x / CHUNK_SIZE);\n  int pcy = (int)(player.position.y / CHUNK_SIZE);\n\n  for (int dx = -6; dx <= 6; dx++) {\n    for (int dy = -6; dy <= 6; dy++) {\n      int cx = pcx + dx;\n      int cy = pcy + dy;\n      Chunk *c = get_chunk(cx, cy);\n\n      pthread_rwlock_wrlock(&c->lock);\n\n      Vector2 chunk_origin =\n          (Vector2){(float)(cx * CHUNK_SIZE), (float)(cy * CHUNK_SIZE)};\n\n      // resources animation decay\n      for (int i = 0; i < c->resource_count; i++) {\n        Resource *r = &c->resources[i];"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_hover_label","file":"game.c","line_start":6481,"line_end":6552,"snippet":"          r->hit_timer -= dt;\n        if (r->break_flash > 0)\n          r->break_flash -= dt;\n      }\n\n      // mobs\n      despawn_hostiles_if_day(c);\n      try_spawn_mobs_in_chunk(c, cx, cy, dt);\n\n      // mobs AI\n      for (int i = 0; i < MAX_MOBS; i++) {\n        Mob *m = &c->mobs[i];\n        if (m->health <= 0)\n          continue;\n        update_mob_ai(m, chunk_origin, dt);\n      }\n      pthread_rwlock_unlock(&c->lock);\n    }\n  }\n\n  // Update damage numbers\n  for (int i = 0; i < damage_number_count; i++) {\n    damage_numbers[i].timer -= dt;\n    // Move damage numbers upward and fade out\n    damage_numbers[i].pos.y -= dt * 30.0f; // Float upward\n  }\n\n  // Remove expired damage numbers\n  for (int i = 0; i < damage_number_count; i++) {\n    if (damage_numbers[i].timer <= 0.0f) {\n      // Shift remaining numbers down\n      for (int j = i; j < damage_number_count - 1; j++) {\n        damage_numbers[j] = damage_numbers[j + 1];\n      }\n      damage_number_count--;\n      i--; // Check the same index again\n    } else {\n      break;\n    }\n  }\n  // OpenGL equivalent of DrawRectangle\n  glBegin(GL_QUADS);\n  glColor4f(0.0f, 0.0f, 0.0f, 110.0f/255.0f);\n  glVertex2f(14, 14);\n  glVertex2f(14 + 280, 14);\n  glVertex2f(14 + 280, 14 + 128);\n  glVertex2f(14, 14 + 128);\n  glEnd();\n  draw_rectangle_outline_opengl(14, 14, 280, 128, (Color){0, 0, 0, 200});\n\n  // bars\n  float hp01 = clamp01(player.health / 100.0f);\n  float st01 = clamp01(player.stamina / 100.0f);\n\n  DrawText(\"Player\", 24, 20, 18, RAYWHITE);\n  DrawText(TextFormat(\"HP: %d\", (int)player.health), 24, 44, 16, RAYWHITE);  // bars\n  DrawText(TextFormat(\"ST: %d\", (int)player.stamina), 24, 64, 16, RAYWHITE);\n  // bar visuals\n  // OpenGL equivalent of DrawRectangle - background\n  glBegin(GL_QUADS);\n  glColor4f(0.0f, 0.0f, 0.0f, 140.0f/255.0f);\n  glVertex2f(120, 46);\n  glVertex2f(120 + 160, 46);\n  glVertex2f(120 + 160, 46 + 12);\n  glVertex2f(120, 46 + 12);\n  glEnd();\n  // OpenGL equivalent of DrawRectangle - hp fill\n  glBegin(GL_QUADS);\n  glColor4f(80.0f/255.0f, 220.0f/255.0f, 80.0f/255.0f, 255.0f/255.0f);\n  glVertex2f(120, 46);\n  glVertex2f(120 + (int)(160 * hp01), 46);\n  glVertex2f(120 + (int)(160 * hp01), 46 + 12);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_minimap","file":"game.c","line_start":6554,"line_end":6623,"snippet":"  glEnd();\n  draw_rectangle_outline_opengl(120, 46, 160, 12, (Color){0, 0, 0, 200});\n  // OpenGL equivalent of DrawRectangle - stamina background\n  glBegin(GL_QUADS);\n  glColor4f(0.0f, 0.0f, 0.0f, 140.0f/255.0f);\n  glVertex2f(120, 66);\n  glVertex2f(120 + 160, 66);\n  glVertex2f(120 + 160, 66 + 12);\n  glVertex2f(120, 66 + 12);\n  glEnd();\n  // OpenGL equivalent of DrawRectangle - stamina fill\n  glBegin(GL_QUADS);\n  glColor4f(80.0f/255.0f, 160.0f/255.0f, 255.0f/255.0f, 255.0f/255.0f);\n  glVertex2f(120, 66);\n  glVertex2f(120 + (int)(160 * st01), 66);\n  glVertex2f(120 + (int)(160 * st01), 66 + 12);\n  glVertex2f(120, 66 + 12);\n  glEnd();\n  draw_rectangle_outline_opengl(120, 66, 160, 12, (Color){0, 0, 0, 200});\n\n  // inventory\n  DrawText(TextFormat(\"Wood: %d  Stone: %d\", inv_wood, inv_stone), 24, 90, 16,\n           RAYWHITE);\n  DrawText(TextFormat(\"Gold: %d  Food: %d\", inv_gold, inv_food), 24, 110, 16,\n           RAYWHITE);\n\n  DrawText(TextFormat(\"Shards: %d  Arrows: %d\", inv_shards, inv_arrows), 24,\n           130, 16, RAYWHITE);\n\n  // base integrity\n  int y0 = 150;\n  for (int t = 0; t < TRIBE_COUNT; t++) {\n    float v = clamp01(tribes[t].integrity / 100.0f);\n    DrawText(TextFormat(\"Base %d\", t), 24, y0 + t * 22, 16, tribes[t].color);\n    // OpenGL equivalent of DrawRectangle - base background\n    glBegin(GL_QUADS);\n    glColor4f(0.0f, 0.0f, 0.0f, 140.0f/255.0f);\n    glVertex2f(90, y0 + 4 + t * 22);\n    glVertex2f(90 + 140, y0 + 4 + t * 22);\n    glVertex2f(90 + 140, y0 + 4 + t * 22 + 10);\n    glVertex2f(90, y0 + 4 + t * 22 + 10);\n    glEnd();\n    // OpenGL equivalent of DrawRectangle - base fill\n    glBegin(GL_QUADS);\n    glColor4f(tribes[t].color.r/255.0f, tribes[t].color.g/255.0f, tribes[t].color.b/255.0f, tribes[t].color.a/255.0f);\n    glVertex2f(90, y0 + 4 + t * 22);\n    glVertex2f(90 + (int)(140 * v), y0 + 4 + t * 22);\n    glVertex2f(90 + (int)(140 * v), y0 + 4 + t * 22 + 10);\n    glVertex2f(90, y0 + 4 + t * 22 + 10);\n    glEnd();\n    draw_rectangle_outline_opengl(90, y0 + 4 + t * 22, 140, 10, (Color){0, 0, 0, 200});\n  }\n}\n\nstatic void draw_hover_label(void) {\n  int hp = -1;\n  Vector2 focus_pos = {0};\n  float focus_radius = 0;\n  bool has_focus = false;\n\n  // find nearest in current chunk within a small radius\n  int cx = (int)(player.position.x / CHUNK_SIZE);\n  int cy = (int)(player.position.y / CHUNK_SIZE);\n  Chunk *c = get_chunk(cx, cy);\n\n  const char *label = NULL;\n  float bestD = 1e9f;\n\n  // resources\n  for (int i = 0; i < c->resource_count; i++) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_hurt_vignette","file":"game.c","line_start":6625,"line_end":6631,"snippet":"    if (r->health <= 0)\n      continue;\n    Vector2 rw = (Vector2){cx * CHUNK_SIZE + r->position.x,\n                           cy * CHUNK_SIZE + r->position.y};\n    float d = Vector2Distance(player.position, rw);\n    if (d < 2.2f && d < bestD) {\n      bestD = d;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"is_dir_path","file":"game.c","line_start":6633,"line_end":6638,"snippet":"      hp = r->health;\n      focus_pos = world_to_screen(rw);\n      focus_radius = 12.0f;\n      has_focus = true;\n    }\n  }"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"S_ISDIR","file":"game.c","line_start":6637,"line_end":6637,"snippet":"    }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"is_file_path","file":"game.c","line_start":6640,"line_end":6645,"snippet":"  // mobs (prefer mobs if close)\n  for (int i = 0; i < MAX_MOBS; i++) {\n    Mob *m = &c->mobs[i];\n    if (m->health <= 0)\n      continue;\n    Vector2 mw = (Vector2){cx * CHUNK_SIZE + m->position.x,"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"S_ISREG","file":"game.c","line_start":6644,"line_end":6644,"snippet":"      continue;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"world_dir_has_save","file":"game.c","line_start":6648,"line_end":6652,"snippet":"    if (d < 2.6f && d < bestD) {\n      bestD = d;\n      label = mob_name(m->type);\n      hp = m->health;\n      focus_pos = world_to_screen(mw);"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"is_file_path","file":"game.c","line_start":6651,"line_end":6651,"snippet":"      hp = m->health;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"ensure_save_root","file":"game.c","line_start":6654,"line_end":6661,"snippet":"      has_focus = true;\n    }\n  }\n\n  // Draw focus box around the targeted object\n  if (has_focus) {\n    draw_rectangle_outline_opengl((int)(focus_pos.x - focus_radius),\n                       (int)(focus_pos.y - focus_radius),"},
  {"kind":"fn_def","vis":"PRIVATE","name":"world_list_refresh","file":"game.c","line_start":6663,"line_end":6711,"snippet":"                       (Color){255, 255, 0, 180}); // Yellow focus box\n  }\n\n  if (label) {\n    Vector2 mp = GetMousePosition();\n    DrawRectangle((int)mp.x + 14, (int)mp.y + 10, 160, 22,\n                  (Color){0, 0, 0, 140});\n    draw_rectangle_outline_opengl((int)mp.x + 14, (int)mp.y + 10, 160, 22,\n                       (Color){0, 0, 0, 220});\n    if (hp >= 0) {\n      DrawText(TextFormat(\"%s (%d)\", label, hp), (int)mp.x + 22, (int)mp.y + 13,\n               16, RAYWHITE);\n    } else {\n      DrawText(label, (int)mp.x + 22, (int)mp.y + 13, 16, RAYWHITE);\n    }\n  }\n}\n\nstatic void draw_minimap(void) {\n  int x = 310, y = 14; // top row, to the right of your panel\n  int size = 160;\n\n  DrawRectangle(x, y, size, size, (Color){0, 0, 0, 110});\n  draw_rectangle_outline_opengl(x, y, size, size, (Color){0, 0, 0, 220});\n\n  // sample area around player (world units)\n  float radius = 28.0f;\n  int cells = 40; // 40x40 grid\n  float cell = (float)size / (float)cells;\n\n  for (int gy = 0; gy < cells; gy++) {\n    for (int gx = 0; gx < cells; gx++) {\n      float nx = ((float)gx / (float)(cells - 1)) * 2.0f - 1.0f;\n      float ny = ((float)gy / (float)(cells - 1)) * 2.0f - 1.0f;\n\n      Vector2 wp = (Vector2){player.position.x + nx * radius,\n                             player.position.y + ny * radius};\n\n      int cx = (int)(wp.x / CHUNK_SIZE);\n      int cy = (int)(wp.y / CHUNK_SIZE);\n      Chunk *c = get_chunk(cx, cy);\n\n      Color bc = Fade(biome_colors[c->biome_type], 0.85f);\n      DrawRectangle((int)(x + gx * cell), (int)(y + gy * cell),\n                    (int)ceilf(cell), (int)ceilf(cell), bc);\n    }\n  }\n\n  // bases"},
  {"kind":"fn_def","vis":"PRIVATE","name":"world_list_ensure_valid","file":"game.c","line_start":6713,"line_end":6727,"snippet":"    Vector2 d = Vector2Subtract(tribes[t].base.position, player.position);\n    if (fabsf(d.x) > radius || fabsf(d.y) > radius)\n      continue;\n    float pxm = (d.x / (radius * 2.0f) + 0.5f) * size;\n    float pym = (d.y / (radius * 2.0f) + 0.5f) * size;\n    DrawCircle((int)(x + pxm), (int)(y + pym), 3, tribes[t].color);\n  }\n\n  // mobs (nearby)\n  int pcx = (int)(player.position.x / CHUNK_SIZE);\n  int pcy = (int)(player.position.y / CHUNK_SIZE);\n  for (int dx = -2; dx <= 2; dx++) {\n    for (int dy = -2; dy <= 2; dy++) {\n      int cx = pcx + dx;\n      int cy = pcy + dy;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"delete_dir_recursive","file":"game.c","line_start":6732,"line_end":6773,"snippet":"        Mob *m = &c->mobs[i];\n        if (m->health <= 0)\n          continue;\n        Vector2 mw = Vector2Add(origin, m->position);\n        Vector2 d = Vector2Subtract(mw, player.position);\n        if (fabsf(d.x) > radius || fabsf(d.y) > radius)\n          continue;\n\n        float pxm = (d.x / (radius * 2.0f) + 0.5f) * size;\n        float pym = (d.y / (radius * 2.0f) + 0.5f) * size;\n        DrawPixel((int)(x + pxm), (int)(y + pym), (Color){240, 80, 80, 255});\n      }\n    }\n  }\n\n  // player dot\n  DrawCircle(x + size / 2, y + size / 2, 3, RAYWHITE);\n  DrawCircleLines(x + size / 2, y + size / 2, 3, (Color){0, 0, 0, 200});\n}\n\nstatic void draw_hurt_vignette(void) {\n  if (player_hurt_timer <= 0.0f)\n    return;\n  float t = clamp01(player_hurt_timer / 0.18f);\n  unsigned char a = (unsigned char)(120 * t);\n  DrawRectangle(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, (Color){120, 0, 0, a});\n}\n\nstatic int is_dir_path(const char *path) {\n  struct stat st;\n  if (stat(path, &st) != 0)\n    return 0;\n  return S_ISDIR(st.st_mode);\n}\n\nstatic int is_file_path(const char *path) {\n  struct stat st;\n  if (stat(path, &st) != 0)\n    return 0;\n  return S_ISREG(st.st_mode);\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"delete_world_by_name","file":"game.c","line_start":6775,"line_end":6779,"snippet":"static int world_dir_has_save(const char *world_name) {\n  char p[256];\n  make_save_file_path(p, sizeof(p), world_name);\n  return is_file_path(p);\n}"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"delete_dir_recursive","file":"game.c","line_start":6778,"line_end":6778,"snippet":"  return is_file_path(p);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_pause_overlay","file":"game.c","line_start":6781,"line_end":6788,"snippet":"static void ensure_save_root(void) {\n  struct stat st = {0};\n  if (stat(SAVE_ROOT, &st) == -1) {\n    if (mkdir(SAVE_ROOT, 0755) != 0 && errno != EEXIST) {\n      fprintf(stderr, \"mkdir(%s) failed: %s\\n\", SAVE_ROOT, strerror(errno));\n    }\n  }\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"ui_button","file":"game.c","line_start":6791,"line_end":6812,"snippet":"  ensure_save_root();\n\n  wl->count = 0;\n  wl->selected = -1;\n  wl->scroll = 0;\n\n  DIR *d = opendir(SAVE_ROOT);\n  if (!d)\n    return;\n\n  struct dirent *e;\n  while ((e = readdir(d)) != NULL) {\n    if (e->d_name[0] == '.')\n      continue;\n\n    char full[256];\n    snprintf(full, sizeof(full), \"%s/%s\", SAVE_ROOT, e->d_name);\n\n    if (!is_dir_path(full))\n      continue;\n\n    // If you want *every* folder listed, comment this out."},
  {"kind":"fn_def","vis":"PRIVATE","name":"do_pause_menu","file":"game.c","line_start":6854,"line_end":6884,"snippet":"}\n\n// =======================\n// DELETE WORLD (rm -r saves/<world>)\n// =======================\nstatic int delete_dir_recursive(const char *path) {\n  DIR *d = opendir(path);\n  if (!d) {\n    // If it doesn't exist, treat as success-ish\n    return (errno == ENOENT) ? 1 : 0;\n  }\n\n  struct dirent *e;\n  while ((e = readdir(d)) != NULL) {\n    if (!strcmp(e->d_name, \".\") || !strcmp(e->d_name, \"..\"))\n      continue;\n\n    char child[512];\n    snprintf(child, sizeof(child), \"%s/%s\", path, e->d_name);\n\n    struct stat st;\n    if (stat(child, &st) != 0)\n      continue;\n\n    if (S_ISDIR(st.st_mode)) {\n      if (!delete_dir_recursive(child)) {\n        closedir(d);\n        return 0;\n      }\n      if (rmdir(child) != 0) {\n        closedir(d);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"save_current_world_session","file":"game.c","line_start":6886,"line_end":6891,"snippet":"      }\n    } else {\n      if (remove(child) != 0) {\n        closedir(d);\n        return 0;\n      }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"do_world_select_screen","file":"game.c","line_start":6893,"line_end":7024,"snippet":"  }\n\n  closedir(d);\n  // remove the top directory\n  if (rmdir(path) != 0)\n    return 0;\n  return 1;\n}\n\nstatic int delete_world_by_name(const char *world_name) {\n  char world_dir[256];\n  make_world_path(world_dir, sizeof(world_dir), world_name);\n  return delete_dir_recursive(world_dir);\n}\n\nstatic void draw_pause_overlay(void) {\n  DrawRectangle(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, (Color){0, 0, 0, 160});\n  const char *title = \"PAUSED\";\n  int fs = 52;\n  int tw = MeasureText(title, fs);\n  DrawText(title, (SCREEN_WIDTH - tw) / 2, (int)(SCREEN_HEIGHT * 0.18f), fs,\n           RAYWHITE);\n}\n\n// tiny button helper\nstatic int ui_button(Rectangle r, const char *text) {\n  // Hardcoded mouse detection - check if mouse is over button and left button\n  // is pressed\n  Vector2 m = GetMousePosition();\n  int hot = CheckCollisionPointRec(m, r);\n  int clicked = hot && IsMouseButtonPressed(MOUSE_BUTTON_LEFT);\n\n  // Scale font size based on button height\n  int font_size = (int)(r.height * 0.4f); // 40% of button height\n  if (font_size < 12)\n    font_size = 12; // Minimum font size\n  if (font_size > 32)\n    font_size = 32; // Maximum font size\n\n  Color bg = hot ? (Color){70, 70, 90, 255} : (Color){50, 50, 70, 255};\n  DrawRectangleRounded(r, 0.25f, 8, bg);\n  DrawRectangleRoundedLines(r, 0.25f, 8, (Color){0, 0, 0, 160});\n  int tw = MeasureText(text, font_size);\n  DrawText(text, (int)(r.x + (r.width - tw) / 2),\n           (int)(r.y + (r.height - font_size) / 2), font_size, RAYWHITE);\n  return clicked;\n}\n\nstatic void ui_textbox(Rectangle r, char *buf, int cap, int *active,\n                       int digits_only) {\n  Vector2 m = GetMousePosition();\n  int hot = CheckCollisionPointRec(m, r);\n  if (hot && IsMouseButtonPressed(MOUSE_LEFT_BUTTON))\n    *active = 1;\n  if (!hot && IsMouseButtonPressed(MOUSE_LEFT_BUTTON))\n    *active = 0;\n\n  Color bg = *active ? (Color){35, 35, 45, 255} : (Color){25, 25, 35, 255};\n  DrawRectangleRounded(r, 0.2f, 8, bg);\n  DrawRectangleRoundedLines(r, 0.2f, 8, (Color){0, 0, 0, 170});\n\n  // input\n  if (*active) {\n    int key = GetCharPressed();\n    while (key > 0) {\n      int len = (int)strlen(buf);\n      if (key == 32 || (key >= 33 && key <= 126)) {\n        if (digits_only && !(key >= '0' && key <= '9')) {\n          key = GetCharPressed();\n          continue;\n        }\n        if (len < cap - 1) {\n          buf[len] = (char)key;\n          buf[len + 1] = 0;\n        }\n      }\n      key = GetCharPressed();\n    }\n    if (IsKeyPressed(KEY_BACKSPACE)) {\n      int len = (int)strlen(buf);\n      if (len > 0)\n        buf[len - 1] = 0;\n    }\n  }\n\n  DrawText(buf, (int)r.x + 10, (int)r.y + 10, 20, RAYWHITE);\n}\n\nstatic void do_pause_menu(void) {\n  draw_pause_overlay();\n\n  float cx = SCREEN_WIDTH * 0.5f;\n  float y = SCREEN_HEIGHT * 0.35f;\n\n  Rectangle rResume = {cx - 140, y + 0, 280, 54};\n  Rectangle rSave = {cx - 140, y + 70, 280, 54};\n  Rectangle rExit = {cx - 140, y + 140, 280, 54};\n\n  if (ui_button(rResume, \"Resume (ESC)\")) {\n    g_state = STATE_PLAYING;\n  }\n\n  if (ui_button(rSave, \"Save World\")) {\n    save_world_to_disk(g_world_name);\n    save_models_to_disk(g_world_name);\n  }\n\n  if (ui_button(rExit, \"Exit to World Select\")) {\n    // Optional: save before leaving\n    save_world_to_disk(g_world_name);\n    save_models_to_disk(g_world_name);\n\n    world_list_refresh(&g_world_list);\n    g_state = STATE_WORLD_SELECT;\n  }\n\n  DrawText(\"Tip: ESC toggles pause\", (int)(cx - 160), (int)(y + 220), 18,\n           RAYWHITE);\n}\n\nstatic void save_current_world_session(void) {\n  if (g_world_name[0] == '\\0')\n    return;\n  save_world_to_disk(g_world_name);\n  save_models_to_disk(g_world_name);\n}\n\nstatic void do_world_select_screen(void) {\n  // Refresh list on first entry or when empty\n  static int initialized = 0;\n  if (!initialized) {\n    world_list_refresh(&g_world_list);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"run_agent_jobs","file":"game.c","line_start":7028,"line_end":7040,"snippet":"  world_list_ensure_valid(&g_world_list);\n\n  DrawRectangle(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, (Color){18, 18, 28, 255});\n  DrawText(\"Select World\", 40, 30, 44, RAYWHITE);\n\n  Rectangle listBox = {40, 100, 520, (float)SCREEN_HEIGHT - 180};\n  DrawRectangleRounded(listBox, 0.12f, 8, (Color){25, 25, 40, 255});\n  DrawRectangleRoundedLines(listBox, 0.12f, 8, (Color){0, 0, 0, 160});\n\n  int itemH = 44;\n  int visible = (int)(listBox.height / itemH);\n  if (visible < 1)\n    visible = 1;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"start_workers","file":"game.c","line_start":7085,"line_end":7096,"snippet":"\n    DrawText(g_world_list.names[idx], (int)(row.x + 12), (int)(row.y + 10), 22,\n             RAYWHITE);\n\n    if (hot && IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {\n      g_world_list.selected = idx;\n    }\n  }\n\n  Rectangle rPlay = {600, 140, 260, 54};\n  Rectangle rDelete = {600, 210, 260, 54};\n  Rectangle rCreate = {600, 280, 260, 54};"},
  {"kind":"fn_def","vis":"PRIVATE","name":"stop_workers","file":"game.c","line_start":7098,"line_end":7107,"snippet":"\n  int hasSelection = (g_world_list.selected >= 0 &&\n                      g_world_list.selected < g_world_list.count);\n\n  if (ui_button(rPlay, hasSelection ? \"Play Selected\" : \"Play (no world)\")) {\n    if (hasSelection) {\n      snprintf(g_world_name, sizeof(g_world_name), \"%s\",\n               g_world_list.names[g_world_list.selected]);\n\n      // load"},
  {"kind":"fn_def","vis":"PRIVATE","name":"grass_enqueue_job","file":"game.c","line_start":7126,"line_end":7135,"snippet":"      world_list_refresh(&g_world_list);\n      world_list_ensure_valid(&g_world_list);\n    }\n  }\n\n  if (ui_button(rCreate, \"Create New World\")) {\n    // go to your create UI\n    g_state = STATE_WORLD_CREATE;\n  }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"grass_dequeue_job","file":"game.c","line_start":7137,"line_end":7150,"snippet":"    g_state = STATE_TITLE;\n  }\n\n  // Enter to play\n  if (hasSelection && IsKeyPressed(KEY_ENTER)) {\n    snprintf(g_world_name, sizeof(g_world_name), \"%s\",\n             g_world_list.names[g_world_list.selected]);\n    if (!load_world_from_disk(g_world_name)) {\n      world_reset(g_world_seed);\n      save_world_to_disk(g_world_name);\n    }\n    g_state = STATE_PLAYING;\n    ensure_agents_ready_on_enter();\n  }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"build_grass_for_chunk","file":"game.c","line_start":7152,"line_end":7219,"snippet":"\n/* =======================\n   THREAD\n\n * ======================= */\n\nstatic void run_agent_jobs(void) {\n  pthread_mutex_lock(&job_mtx);\n  job_next_agent = 0;\n  job_done_workers = 0;\n  job_active = 1;\n\n  pthread_cond_broadcast(&job_cv);\n\n  while (job_active) {\n    pthread_cond_wait(&done_cv, &job_mtx);\n  }\n  pthread_mutex_unlock(&job_mtx);\n}\n\nstatic void *agent_worker(void *arg) {\n  (void)arg;\n\n  for (;;) {\n    // Wait for a job batch to become active (or quit)\n    pthread_mutex_lock(&job_mtx);\n    while (!job_active && !job_quit) {\n      pthread_cond_wait(&job_cv, &job_mtx);\n    }\n    if (job_quit) {\n      pthread_mutex_unlock(&job_mtx);\n      break;\n    }\n    pthread_mutex_unlock(&job_mtx);\n\n    // Work loop: grab next agent index atomically under mutex\n    for (;;) {\n      int idx;\n\n      pthread_mutex_lock(&job_mtx);\n      idx = job_next_agent++;\n      pthread_mutex_unlock(&job_mtx);\n\n      if (idx >= MAX_AGENTS)\n        break;\n\n      update_agent(&agents[idx]);\n    }\n\n    // Signal completion for this worker\n    pthread_mutex_lock(&job_mtx);\n    job_done_workers++;\n\n    if (job_done_workers >= WORKER_COUNT) {\n      job_active = 0;                // batch finished\n      pthread_cond_signal(&done_cv); // wake main thread\n    }\n    pthread_mutex_unlock(&job_mtx);\n  }\n\n  return NULL;\n}\n\nstatic void start_workers(void) {\n  pthread_mutex_lock(&job_mtx);\n  job_quit = 0;\n  job_active = 0;\n  job_next_agent = 0;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"start_grass_worker","file":"game.c","line_start":7230,"line_end":7238,"snippet":"  job_quit = 1;\n  pthread_cond_broadcast(&job_cv);\n  pthread_mutex_unlock(&job_mtx);\n\n  for (int i = 0; i < WORKER_COUNT; i++) {\n    pthread_join(workers[i], NULL);\n  }\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"stop_grass_worker","file":"game.c","line_start":7240,"line_end":7249,"snippet":"typedef struct {\n  int cx;\n  int cy;\n} GrassJob;\n\n#define GRASS_JOB_CAP (WORLD_SIZE * WORLD_SIZE)\n\nstatic pthread_t g_grass_thread;\nstatic pthread_mutex_t g_grass_mtx = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t g_grass_cv = PTHREAD_COND_INITIALIZER;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"mesh_destroy","file":"game.c","line_start":7267,"line_end":7283,"snippet":"static int grass_dequeue_job(GrassJob *out) {\n  pthread_mutex_lock(&g_grass_mtx);\n  while (g_grass_head == g_grass_tail && !g_grass_quit) {\n    pthread_cond_wait(&g_grass_cv, &g_grass_mtx);\n  }\n  if (g_grass_quit) {\n    pthread_mutex_unlock(&g_grass_mtx);\n    return 0;\n  }\n  *out = g_grass_jobs[g_grass_head];\n  g_grass_head = (g_grass_head + 1) % GRASS_JOB_CAP;\n  pthread_mutex_unlock(&g_grass_mtx);\n  return 1;\n}\n\nstatic void build_grass_for_chunk(int cx, int cy) {\n  float world_span = (float)(WORLD_SIZE * CHUNK_SIZE);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vec3_add","file":"game.c","line_start":7380,"line_end":7382,"snippet":"\n// ------------------- 3D RENDERER (minimal) -------------------\ntypedef struct {"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"vec3","file":"game.c","line_start":7381,"line_end":7381,"snippet":"// ------------------- 3D RENDERER (minimal) -------------------"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vec3_sub","file":"game.c","line_start":7383,"line_end":7385,"snippet":"  float x, y, z;\n} Vec3;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"vec3","file":"game.c","line_start":7384,"line_end":7384,"snippet":"} Vec3;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vec3_scale","file":"game.c","line_start":7386,"line_end":7388,"snippet":"typedef struct {\n  float m[16];\n} Mat4;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"vec3","file":"game.c","line_start":7387,"line_end":7387,"snippet":"  float m[16];"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vec3_len","file":"game.c","line_start":7389,"line_end":7391,"snippet":"\ntypedef struct {\n  GLuint vao;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"sqrtf","file":"game.c","line_start":7390,"line_end":7390,"snippet":"typedef struct {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vec3_dot","file":"game.c","line_start":7392,"line_end":7394,"snippet":"  GLuint vbo;\n  GLuint ebo;\n  int index_count;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vec3_norm","file":"game.c","line_start":7395,"line_end":7400,"snippet":"} GameMesh;\n\nstatic void mesh_destroy(GameMesh *m) {\n  if (!m)\n    return;\n  if (m->ebo) {"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"vec3","file":"game.c","line_start":7398,"line_end":7398,"snippet":"  if (!m)"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"vec3_scale","file":"game.c","line_start":7399,"line_end":7399,"snippet":"    return;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vec3_cross","file":"game.c","line_start":7401,"line_end":7404,"snippet":"    glDeleteBuffers(1, &m->ebo);\n    m->ebo = 0;\n  }\n  if (m->vbo) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"hash2d","file":"game.c","line_start":7407,"line_end":7412,"snippet":"  }\n  if (m->vao) {\n    glDeleteVertexArrays(1, &m->vao);\n    m->vao = 0;\n  }\n  m->index_count = 0;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"value_noise","file":"game.c","line_start":7418,"line_end":7435,"snippet":"static GLint g_u_color = -1;\nstatic GLint g_u_light = -1;\nstatic GLint g_u_use_tex = -1;\nstatic GLint g_u_tex = -1;\nstatic GLint g_u_tex_scale = -1;\nstatic GLuint g_ground_tex = 0;\nstatic GameMesh g_mesh_ground = {0};\nstatic GameMesh g_mesh_ground_tile = {0};\nstatic GameMesh g_mesh_ground_perlin = {0};\nstatic GameMesh g_mesh_grass = {0};\nstatic int g_mesh_grass_loaded = 0;\nstatic GameMesh g_mesh_cube = {0};\nstatic GameMesh g_mesh_sphere = {0};\nstatic GameMesh g_mesh_cylinder = {0};\nstatic GLuint g_ui_shader = 0;\nstatic GLuint g_ui_vao = 0;\nstatic GLuint g_ui_vbo = 0;\nstatic GLuint g_ui_white_tex = 0;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"lerp_f","file":"game.c","line_start":7434,"line_end":7434,"snippet":"static GLuint g_ui_vbo = 0;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"terrain_height_raw","file":"game.c","line_start":7437,"line_end":7447,"snippet":"static GLint g_ui_u_color = -1;\nstatic GLint g_ui_u_tex = -1;\nstatic TTF_Font *g_ui_font = NULL;\ntypedef struct {\n  int size;\n  TTF_Font *font;\n} UiFontEntry;\n\nstatic UiFontEntry g_ui_fonts[8] = {0};\n\ntypedef struct {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"terrain_height","file":"game.c","line_start":7449,"line_end":7474,"snippet":"  Color color;\n  GLuint tex;\n  int w;\n  int h;\n} UiTextCache;\n\nstatic UiTextCache g_hud_hp = {\"\", {0}, 0, 0, 0};\nstatic UiTextCache g_hud_st = {\"\", {0}, 0, 0, 0};\nstatic UiTextCache g_ui_cache_player = {\"\", {0}, 0, 0, 0};\nstatic UiTextCache g_ui_cache_hp = {\"\", {0}, 0, 0, 0};\nstatic UiTextCache g_ui_cache_st = {\"\", {0}, 0, 0, 0};\nstatic UiTextCache g_ui_cache_wood = {\"\", {0}, 0, 0, 0};\nstatic UiTextCache g_ui_cache_gold = {\"\", {0}, 0, 0, 0};\nstatic UiTextCache g_ui_cache_shards = {\"\", {0}, 0, 0, 0};\nstatic UiTextCache g_ui_cache_base[TRIBE_COUNT];\nstatic UiTextCache g_ui_cache_minimap_title = {\"\", {0}, 0, 0, 0};\nstatic UiTextCache g_ui_cache_minimap_mobs = {\"\", {0}, 0, 0, 0};\nstatic UiTextCache g_ui_cache_daynight = {\"\", {0}, 0, 0, 0};\nstatic UiTextCache g_ui_cache_time = {\"\", {0}, 0, 0, 0};\nstatic double g_ui_cache_last_update = 0.0;\nstatic int g_ui_cache_last_zoomed = -1;\nstatic GLuint g_minimap_tex = 0;\nstatic int g_minimap_tex_cells = 0;\nstatic int g_minimap_tex_zoomed = -1;\nstatic double g_minimap_tex_last = 0.0;\nstatic int g_minimap_zoomed = 0;"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"lerp_f","file":"game.c","line_start":7469,"line_end":7469,"snippet":"static int g_ui_cache_last_zoomed = -1;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"vec3_rotate_y","file":"game.c","line_start":7476,"line_end":7480,"snippet":"static GameMesh g_mesh_mobs[MOB_COUNT] = {0};\nstatic GameMesh g_mesh_resources[RES_COUNT] = {0};\nstatic GameMesh g_mesh_base = {0};\nstatic int g_mesh_player_loaded = 0;\nstatic int g_mesh_mob_loaded[MOB_COUNT] = {0};"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"vec3","file":"game.c","line_start":7479,"line_end":7479,"snippet":"static int g_mesh_player_loaded = 0;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"mat4_identity","file":"game.c","line_start":7482,"line_end":7486,"snippet":"static int g_mesh_base_loaded = 0;\nstatic int g_mesh_ground_tile_loaded = 0;\nstatic int g_mesh_ground_perlin_ready = 0;\nstatic int g_use_perlin_ground = 1;\nstatic int g_ground_step = 8;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"mat4_mul","file":"game.c","line_start":7488,"line_end":7499,"snippet":"// Performance optimization variables\nstatic float g_last_frame_time = 0.0f;\nstatic int g_frame_count = 0;\nstatic float g_fps_update_time = 0.0f;\nstatic float g_current_fps = 60.0f;\nstatic const float TARGET_FPS = 60.0f;\nstatic const float MIN_FRAME_TIME = 1.0f / TARGET_FPS;\n\n#define ASSET_PLAYER_GLB \"Assets/Player.glb\"\n#define ASSET_PIG_GLB \"Assets/Pig.glb\"\n#define ASSET_SHEEP_GLB \"Assets/Sheep.glb\"\n#define ASSET_SKELETON_GLB \"Assets/Skeleton.glb\""},
  {"kind":"fn_def","vis":"PRIVATE","name":"mat4_translate","file":"game.c","line_start":7501,"line_end":7507,"snippet":"#define ASSET_TREE_GLB \"Assets/Tree.glb\"\n#define ASSET_ROCK_GLB \"Assets/Rock.glb\"\n#define ASSET_GOLD_GLB \"Assets/Gold.glb\"\n#define ASSET_FOOD_GLB \"Assets/Food.glb\"\n#define ASSET_TERRAIN_GLB \"Assets/terrain_tile.glb\"\n#define ASSET_BASE_GLB \"Assets/Base.glb\"\n#define ASSET_GRASS_GLB \"Assets/grass.glb\""},
  {"kind":"fn_def","vis":"PRIVATE","name":"mat4_scale","file":"game.c","line_start":7509,"line_end":7515,"snippet":"static Vec3 vec3(float x, float y, float z) { return (Vec3){x, y, z}; }\nstatic Vec3 vec3_add(Vec3 a, Vec3 b) {\n  return vec3(a.x + b.x, a.y + b.y, a.z + b.z);\n}\nstatic Vec3 vec3_sub(Vec3 a, Vec3 b) {\n  return vec3(a.x - b.x, a.y - b.y, a.z - b.z);\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"mat4_rotate_y","file":"game.c","line_start":7517,"line_end":7526,"snippet":"  return vec3(a.x * s, a.y * s, a.z * s);\n}\nstatic float vec3_len(Vec3 a) {\n  return sqrtf(a.x * a.x + a.y * a.y + a.z * a.z);\n}\nstatic float vec3_dot(Vec3 a, Vec3 b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\nstatic Vec3 vec3_norm(Vec3 a) {\n  float l = vec3_len(a);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"mat4_rotate_x","file":"game.c","line_start":7528,"line_end":7537,"snippet":"    return vec3(0, 0, 0);\n  return vec3_scale(a, 1.0f / l);\n}\nstatic Vec3 vec3_cross(Vec3 a, Vec3 b) {\n  return vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z,\n              a.x * b.y - a.y * b.x);\n}\n\n// ------------------- Perlin-ish terrain -------------------\nstatic float hash2d(int x, int y) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"mat4_perspective","file":"game.c","line_start":7539,"line_end":7549,"snippet":"  n = (n ^ (n >> 13)) * 1274126177;\n  n = n ^ (n >> 16);\n  return (n & 0x7fffffff) / 2147483647.0f;\n}\n\nstatic float lerp_f(float a, float b, float t) { return a + (b - a) * t; }\n\nstatic float fade(float t) { return t * t * (3.0f - 2.0f * t); }\n\nstatic float value_noise(float x, float y) {\n  int x0 = (int)floorf(x);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"mat4_lookat","file":"game.c","line_start":7551,"line_end":7569,"snippet":"  int x1 = x0 + 1;\n  int y1 = y0 + 1;\n\n  float sx = fade(x - (float)x0);\n  float sy = fade(y - (float)y0);\n\n  float n00 = hash2d(x0, y0);\n  float n10 = hash2d(x1, y0);\n  float n01 = hash2d(x0, y1);\n  float n11 = hash2d(x1, y1);\n\n  float ix0 = lerp_f(n00, n10, sx);\n  float ix1 = lerp_f(n01, n11, sx);\n  return lerp_f(ix0, ix1, sy);\n}\n\nstatic float terrain_height_raw(float x, float z) {\n  float base_scale = 0.03125f;\n  float n = value_noise(x * base_scale, z * base_scale);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"compile_shader","file":"game.c","line_start":7571,"line_end":7583,"snippet":"  if (hill < 0.0f) {\n    return 0.0f;\n  }\n  hill = clamp01(hill);\n  // Broader, gentle hills on a flat plane.\n  return hill * hill * 12.0f;\n}\n\nstatic float terrain_height(float x, float z) {\n  float h = terrain_height_raw(x, z);\n  if (!g_tribes_ready) {\n    return h;\n  }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"make_program","file":"game.c","line_start":7585,"line_end":7595,"snippet":"  // Flatten terrain around bases so they sit flush and the area is walkable.\n  for (int t = 0; t < TRIBE_COUNT; t++) {\n    Vector2 bp = tribes[t].base.position;\n    float dx = x - bp.x;\n    float dz = z - bp.y;\n    float dist = sqrtf(dx * dx + dz * dz);\n    float inner = tribes[t].base.radius * 1.4f;\n    float outer = tribes[t].base.radius * 2.4f;\n    float base_h = g_base_flat_height[t];\n    if (dist <= inner) {\n      return base_h;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"hash_u32","file":"game.c","line_start":7597,"line_end":7604,"snippet":"    if (dist < outer) {\n      float t01 = (dist - inner) / (outer - inner);\n      return lerp_f(base_h, h, t01);\n    }\n  }\n\n  return h;\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"hash2f","file":"game.c","line_start":7606,"line_end":7610,"snippet":"static Vec3 vec3_rotate_y(Vec3 v, float a) {\n  float c = cosf(a);\n  float s = sinf(a);\n  return vec3(v.x * c + v.z * s, v.y, -v.x * s + v.z * c);\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"create_ground_texture","file":"game.c","line_start":7612,"line_end":7661,"snippet":"static Mat4 mat4_identity(void) {\n  Mat4 m = {0};\n  m.m[0] = m.m[5] = m.m[10] = m.m[15] = 1.0f;\n  return m;\n}\n\nstatic Mat4 mat4_mul(Mat4 a, Mat4 b) {\n  Mat4 r = {0};\n  for (int col = 0; col < 4; col++) {\n    for (int row = 0; row < 4; row++) {\n      r.m[col * 4 + row] = a.m[0 * 4 + row] * b.m[col * 4 + 0] +\n                           a.m[1 * 4 + row] * b.m[col * 4 + 1] +\n                           a.m[2 * 4 + row] * b.m[col * 4 + 2] +\n                           a.m[3 * 4 + row] * b.m[col * 4 + 3];\n    }\n  }\n  return r;\n}\n\nstatic Mat4 mat4_translate(Vec3 t) {\n  Mat4 m = mat4_identity();\n  m.m[12] = t.x;\n  m.m[13] = t.y;\n  m.m[14] = t.z;\n  return m;\n}\n\nstatic Mat4 mat4_scale(Vec3 s) {\n  Mat4 m = mat4_identity();\n  m.m[0] = s.x;\n  m.m[5] = s.y;\n  m.m[10] = s.z;\n  return m;\n}\n\nstatic Mat4 mat4_rotate_y(float a) {\n  Mat4 m = mat4_identity();\n  float c = cosf(a);\n  float s = sinf(a);\n  m.m[0] = c;\n  m.m[2] = s;\n  m.m[8] = -s;\n  m.m[10] = c;\n  return m;\n}\n\nstatic Mat4 mat4_rotate_x(float a) {\n  Mat4 m = mat4_identity();\n  float c = cosf(a);\n  float s = sinf(a);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"apply_graphics_quality","file":"game.c","line_start":7678,"line_end":7741,"snippet":"  return m;\n}\n\nstatic Mat4 mat4_lookat(Vec3 eye, Vec3 center, Vec3 up) {\n  Vec3 f = vec3_norm(vec3_sub(center, eye));\n  Vec3 s = vec3_norm(vec3_cross(f, up));\n  Vec3 u = vec3_cross(s, f);\n  Mat4 m = mat4_identity();\n  m.m[0] = s.x;\n  m.m[4] = s.y;\n  m.m[8] = s.z;\n  m.m[1] = u.x;\n  m.m[5] = u.y;\n  m.m[9] = u.z;\n  m.m[2] = -f.x;\n  m.m[6] = -f.y;\n  m.m[10] = -f.z;\n  m.m[12] = -vec3_dot(s, eye);\n  m.m[13] = -vec3_dot(u, eye);\n  m.m[14] = vec3_dot(f, eye);\n  return m;\n}\n\nstatic GLuint compile_shader(GLenum type, const char *src) {\n  GLuint s = glCreateShader(type);\n  glShaderSource(s, 1, &src, NULL);\n  glCompileShader(s);\n  GLint ok = 0;\n  glGetShaderiv(s, GL_COMPILE_STATUS, &ok);\n  if (!ok) {\n    char log[1024];\n    glGetShaderInfoLog(s, sizeof(log), NULL, log);\n    fprintf(stderr, \"GL shader compile error: %s\\n\", log);\n  }\n  return s;\n}\n\nstatic GLuint make_program(const char *vs, const char *fs) {\n  GLuint v = compile_shader(GL_VERTEX_SHADER, vs);\n  GLuint f = compile_shader(GL_FRAGMENT_SHADER, fs);\n  GLuint p = glCreateProgram();\n  glAttachShader(p, v);\n  glAttachShader(p, f);\n  glLinkProgram(p);\n  glDeleteShader(v);\n  glDeleteShader(f);\n  return p;\n}\n\nstatic unsigned int hash_u32(unsigned int x) {\n  x ^= x >> 16;\n  x *= 0x7feb352dU;\n  x ^= x >> 15;\n  x *= 0x846ca68bU;\n  x ^= x >> 16;\n  return x;\n}\n\nstatic float hash2f(int x, int y) {\n  unsigned int h =\n      hash_u32((unsigned int)x * 374761393U + (unsigned int)y * 668265263U);\n  return (float)(h & 0x00ffffffU) / (float)0x01000000U;\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"apply_graphics_custom_runtime","file":"game.c","line_start":7743,"line_end":7745,"snippet":"  if (size <= 0)\n    size = 256;\n  unsigned char *pixels = (unsigned char *)malloc((size_t)size * size * 3);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"normalize_vec3_f","file":"game.c","line_start":7768,"line_end":7780,"snippet":"      g = g * (1.0f - dirt) + dg * dirt;\n      b = b * (1.0f - dirt) + db * dirt;\n\n      int idx = (y * size + x) * 3;\n      pixels[idx + 0] = (unsigned char)fminf(fmaxf(r, 0.0f), 1.0f) * 255;\n      pixels[idx + 1] = (unsigned char)fminf(fmaxf(g, 0.0f), 1.0f) * 255;\n      pixels[idx + 2] = (unsigned char)fminf(fmaxf(b, 0.0f), 1.0f) * 255;\n    }\n  }\n\n  GLuint tex = 0;\n  glGenTextures(1, &tex);\n  glBindTexture(GL_TEXTURE_2D, tex);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"load_glb_mesh","file":"game.c","line_start":7822,"line_end":7940,"snippet":"    g_grass_stride_far = 14;\n    g_grass_max_chunk_near = 120;\n    g_grass_max_chunk_mid = 80;\n    g_grass_max_chunk_far = 40;\n    g_minimap_cells_normal = 24;\n    g_minimap_cells_zoom = 32;\n    break;\n  case GFX_MED:\n    g_enable_ground_tex = 1;\n    g_ground_tex_scale = 0.07f;\n    want_grass = 1;\n    g_ground_step = 12;\n    g_grass_stride_near = 3;\n    g_grass_stride_mid = 6;\n    g_grass_stride_far = 10;\n    g_grass_max_chunk_near = 420;\n    g_grass_max_chunk_mid = 220;\n    g_grass_max_chunk_far = 120;\n    g_minimap_cells_normal = 32;\n    g_minimap_cells_zoom = 44;\n    break;\n  case GFX_HIGH:\n  default:\n    g_enable_ground_tex = 1;\n    g_ground_tex_scale = 0.06f;\n    want_grass = 1;\n    g_ground_step = 8;\n    g_grass_stride_near = GRASS_STRIDE_NEAR;\n    g_grass_stride_mid = GRASS_STRIDE_MID;\n    g_grass_stride_far = GRASS_STRIDE_FAR;\n    g_grass_max_chunk_near = GRASS_MAX_CHUNK_NEAR;\n    g_grass_max_chunk_mid = GRASS_MAX_CHUNK_MID;\n    g_grass_max_chunk_far = GRASS_MAX_CHUNK_FAR;\n    g_minimap_cells_normal = 40;\n    g_minimap_cells_zoom = 56;\n    break;\n  }\n\n  if (g_use_perlin_ground) {\n    rebuild_ground_perlin_mesh();\n  }\n\n  if (want_grass && !g_enable_grass) {\n    g_enable_grass = 1;\n    start_grass_worker();\n  } else if (!want_grass && g_enable_grass) {\n    g_enable_grass = 0;\n    stop_grass_worker();\n  }\n}\n\nstatic void apply_graphics_custom_runtime(void) {\n  // Grass worker is handled separately in main initialization\n}\n\nstatic void mesh_init(GameMesh *m, const float *verts, int vcount,\n                      const unsigned int *indices, int icount) {\n  glGenVertexArrays(1, &m->vao);\n  glGenBuffers(1, &m->vbo);\n  glGenBuffers(1, &m->ebo);\n  glBindVertexArray(m->vao);\n  glBindBuffer(GL_ARRAY_BUFFER, m->vbo);\n  glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vcount * 6, verts,\n               GL_STATIC_DRAW);\n  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m->ebo);\n  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(unsigned int) * icount, indices,\n               GL_STATIC_DRAW);\n  glEnableVertexAttribArray(0);\n  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 6, (void *)0);\n  glEnableVertexAttribArray(1);\n  glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 6,\n                        (void *)(sizeof(float) * 3));\n  glBindVertexArray(0);\n  m->index_count = icount;\n}\n\nstatic void normalize_vec3_f(float *x, float *y, float *z) {\n  float len = sqrtf((*x) * (*x) + (*y) * (*y) + (*z) * (*z));\n  if (len <= 1e-6f) {\n    *x = 0.0f;\n    *y = 1.0f;\n    *z = 0.0f;\n    return;\n  }\n  float inv = 1.0f / len;\n  *x *= inv;\n  *y *= inv;\n  *z *= inv;\n}\n\nstatic void compute_normals_from_indices(const float *positions, float *normals,\n                                         int vcount,\n                                         const unsigned int *indices,\n                                         int icount) {\n  for (int i = 0; i < vcount * 3; i++) {\n    normals[i] = 0.0f;\n  }\n  for (int i = 0; i + 2 < icount; i += 3) {\n    unsigned int ia = indices[i + 0];\n    unsigned int ib = indices[i + 1];\n    unsigned int ic = indices[i + 2];\n    if (ia >= (unsigned int)vcount || ib >= (unsigned int)vcount ||\n        ic >= (unsigned int)vcount) {\n      continue;\n    }\n    Vec3 a = vec3(positions[ia * 3 + 0], positions[ia * 3 + 1],\n                  positions[ia * 3 + 2]);\n    Vec3 b = vec3(positions[ib * 3 + 0], positions[ib * 3 + 1],\n                  positions[ib * 3 + 2]);\n    Vec3 c = vec3(positions[ic * 3 + 0], positions[ic * 3 + 1],\n                  positions[ic * 3 + 2]);\n    Vec3 e1 = vec3_sub(b, a);\n    Vec3 e2 = vec3_sub(c, a);\n    Vec3 n = vec3_cross(e1, e2);\n    normals[ia * 3 + 0] += n.x;\n    normals[ia * 3 + 1] += n.y;\n    normals[ia * 3 + 2] += n.z;\n    normals[ib * 3 + 0] += n.x;\n    normals[ib * 3 + 1] += n.y;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"build_ground_mesh","file":"game.c","line_start":7942,"line_end":7949,"snippet":"    normals[ic * 3 + 0] += n.x;\n    normals[ic * 3 + 1] += n.y;\n    normals[ic * 3 + 2] += n.z;\n  }\n  for (int i = 0; i < vcount; i++) {\n    normalize_vec3_f(&normals[i * 3 + 0], &normals[i * 3 + 1],\n                     &normals[i * 3 + 2]);\n  }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"build_ground_perlin_mesh","file":"game.c","line_start":7951,"line_end":8019,"snippet":"\nstatic int load_glb_mesh(const char *path, GameMesh *out) {\n  cgltf_options options = {0};\n  cgltf_data *data = NULL;\n  cgltf_result res = cgltf_parse_file(&options, path, &data);\n  if (res != cgltf_result_success) {\n    fprintf(stderr, \"glb load failed: %s\\n\", path);\n    return 0;\n  }\n  res = cgltf_load_buffers(&options, data, path);\n  if (res != cgltf_result_success) {\n    fprintf(stderr, \"glb buffers failed: %s\\n\", path);\n    cgltf_free(data);\n    return 0;\n  }\n  if (data->meshes_count == 0 || data->meshes[0].primitives_count == 0) {\n    fprintf(stderr, \"glb has no meshes: %s\\n\", path);\n    cgltf_free(data);\n    return 0;\n  }\n\n  cgltf_primitive *prim = &data->meshes[0].primitives[0];\n  if (prim->type != cgltf_primitive_type_triangles) {\n    fprintf(stderr, \"glb primitive not triangles: %s\\n\", path);\n    cgltf_free(data);\n    return 0;\n  }\n\n  cgltf_accessor *pos_acc = NULL;\n  cgltf_accessor *norm_acc = NULL;\n  for (cgltf_size i = 0; i < prim->attributes_count; i++) {\n    cgltf_attribute *attr = &prim->attributes[i];\n    if (attr->type == cgltf_attribute_type_position) {\n      pos_acc = attr->data;\n    } else if (attr->type == cgltf_attribute_type_normal) {\n      norm_acc = attr->data;\n    }\n  }\n  if (!pos_acc) {\n    fprintf(stderr, \"glb missing positions: %s\\n\", path);\n    cgltf_free(data);\n    return 0;\n  }\n\n  int vcount = (int)pos_acc->count;\n  float *positions = (float *)malloc(sizeof(float) * vcount * 3);\n  float *normals = (float *)calloc((size_t)vcount * 3, sizeof(float));\n  if (!positions || !normals) {\n    fprintf(stderr, \"glb oom: %s\\n\", path);\n    free(positions);\n    free(normals);\n    cgltf_free(data);\n    return 0;\n  }\n  cgltf_accessor_unpack_floats(pos_acc, positions, (cgltf_size)vcount * 3);\n  if (norm_acc) {\n    cgltf_accessor_unpack_floats(norm_acc, normals, (cgltf_size)vcount * 3);\n  }\n\n  unsigned int *indices = NULL;\n  int icount = 0;\n  if (prim->indices) {\n    icount = (int)prim->indices->count;\n    indices = (unsigned int *)malloc(sizeof(unsigned int) * icount);\n    if (!indices) {\n      fprintf(stderr, \"glb oom indices: %s\\n\", path);\n      free(positions);\n      free(normals);\n      cgltf_free(data);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"rebuild_ground_perlin_mesh","file":"game.c","line_start":8021,"line_end":8027,"snippet":"    }\n    for (int i = 0; i < icount; i++) {\n      indices[i] = (unsigned int)cgltf_accessor_read_index(prim->indices, i);\n    }\n  } else {\n    icount = vcount;\n    indices = (unsigned int *)malloc(sizeof(unsigned int) * icount);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"build_grass_mesh","file":"game.c","line_start":8029,"line_end":8041,"snippet":"      fprintf(stderr, \"glb oom indices: %s\\n\", path);\n      free(positions);\n      free(normals);\n      cgltf_free(data);\n      return 0;\n    }\n    for (int i = 0; i < icount; i++) {\n      indices[i] = (unsigned int)i;\n    }\n  }\n\n  if (!norm_acc) {\n    compute_normals_from_indices(positions, normals, vcount, indices, icount);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"build_sphere_mesh","file":"game.c","line_start":8043,"line_end":8087,"snippet":"\n  float *verts = (float *)malloc(sizeof(float) * vcount * 6);\n  if (!verts) {\n    fprintf(stderr, \"glb oom verts: %s\\n\", path);\n    free(positions);\n    free(normals);\n    free(indices);\n    cgltf_free(data);\n    return 0;\n  }\n  for (int i = 0; i < vcount; i++) {\n    verts[i * 6 + 0] = positions[i * 3 + 0];\n    verts[i * 6 + 1] = positions[i * 3 + 1];\n    verts[i * 6 + 2] = positions[i * 3 + 2];\n    verts[i * 6 + 3] = normals[i * 3 + 0];\n    verts[i * 6 + 4] = normals[i * 3 + 1];\n    verts[i * 6 + 5] = normals[i * 3 + 2];\n  }\n\n  mesh_init(out, verts, vcount, indices, icount);\n\n  free(verts);\n  free(positions);\n  free(normals);\n  free(indices);\n  cgltf_free(data);\n  return 1;\n}\n\nstatic void build_ground_mesh(void) {\n  float verts[] = {\n      -0.5f, 0.0f, -0.5f, 0, 1, 0, 0.5f,  0.0f, -0.5f, 0, 1, 0,\n      0.5f,  0.0f, 0.5f,  0, 1, 0, -0.5f, 0.0f, 0.5f,  0, 1, 0,\n  };\n  unsigned int idx[] = {0, 1, 2, 0, 2, 3};\n  mesh_init(&g_mesh_ground, verts, 4, idx, 6);\n}\n\nstatic void build_ground_perlin_mesh(void) {\n  int world_span = WORLD_SIZE * CHUNK_SIZE;\n  int step = g_ground_step; // world units between vertices\n  int res = world_span / step;\n  int vcount = (res + 1) * (res + 1);\n  int icount = res * res * 6;\n  float *verts = (float *)malloc(sizeof(float) * vcount * 6);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"build_cylinder_mesh","file":"game.c","line_start":8089,"line_end":8187,"snippet":"  if (!verts || !idx) {\n    free(verts);\n    free(idx);\n    return;\n  }\n\n  int vi = 0;\n  for (int z = 0; z <= res; z++) {\n    for (int x = 0; x <= res; x++) {\n      float fx = (float)(x * step);\n      float fz = (float)(z * step);\n      float h = terrain_height(fx, fz);\n      verts[vi * 6 + 0] = fx;\n      verts[vi * 6 + 1] = h;\n      verts[vi * 6 + 2] = fz;\n      verts[vi * 6 + 3] = 0.0f;\n      verts[vi * 6 + 4] = 1.0f;\n      verts[vi * 6 + 5] = 0.0f;\n      vi++;\n    }\n  }\n\n  int ii = 0;\n  for (int z = 0; z < res; z++) {\n    for (int x = 0; x < res; x++) {\n      unsigned int i0 = (unsigned int)(z * (res + 1) + x);\n      unsigned int i1 = i0 + 1;\n      unsigned int i2 = i0 + (unsigned int)(res + 1);\n      unsigned int i3 = i2 + 1;\n      idx[ii++] = i0;\n      idx[ii++] = i2;\n      idx[ii++] = i1;\n      idx[ii++] = i1;\n      idx[ii++] = i2;\n      idx[ii++] = i3;\n    }\n  }\n\n  float *pos = (float *)malloc(sizeof(float) * vcount * 3);\n  float *nrm = (float *)malloc(sizeof(float) * vcount * 3);\n  if (pos && nrm) {\n    for (int i = 0; i < vcount; i++) {\n      pos[i * 3 + 0] = verts[i * 6 + 0];\n      pos[i * 3 + 1] = verts[i * 6 + 1];\n      pos[i * 3 + 2] = verts[i * 6 + 2];\n    }\n    compute_normals_from_indices(pos, nrm, vcount, idx, icount);\n    for (int i = 0; i < vcount; i++) {\n      verts[i * 6 + 3] = nrm[i * 3 + 0];\n      verts[i * 6 + 4] = nrm[i * 3 + 1];\n      verts[i * 6 + 5] = nrm[i * 3 + 2];\n    }\n  }\n  free(pos);\n  free(nrm);\n\n  mesh_init(&g_mesh_ground_perlin, verts, vcount, idx, icount);\n  free(verts);\n  free(idx);\n  g_mesh_ground_perlin_ready = 1;\n}\n\nstatic void rebuild_ground_perlin_mesh(void) {\n  if (g_mesh_ground_perlin_ready) {\n    mesh_destroy(&g_mesh_ground_perlin);\n    g_mesh_ground_perlin_ready = 0;\n  }\n  build_ground_perlin_mesh();\n}\n\nstatic void build_grass_mesh(void) {\n  float w = 0.035f;\n  float h = 1.1f;\n  float bend = 0.16f;\n  float verts[] = {\n      -w,       0.0f, 0.0f,     0, 1, 0, w,         0.0f, 0.0f,      0, 1, 0,\n      w + bend, h,    0.0f,     0, 1, 0, -w + bend, h,    0.0f,      0, 1, 0,\n      0.0f,     0.0f, -w,       0, 1, 0, 0.0f,      0.0f, w,         0, 1, 0,\n      0.0f,     h,    w + bend, 0, 1, 0, 0.0f,      h,    -w + bend, 0, 1, 0,\n  };\n  unsigned int idx[] = {0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7};\n  mesh_init(&g_mesh_grass, verts, 8, idx, 12);\n}\n\nstatic void build_sphere_mesh(int stacks, int slices) {\n  int vcount = (stacks + 1) * (slices + 1);\n  int icount = stacks * slices * 6;\n  float *verts = malloc(sizeof(float) * vcount * 6);\n  unsigned int *idx = malloc(sizeof(unsigned int) * icount);\n  if (!verts || !idx) {\n    free(verts);\n    free(idx);\n    return;\n  }\n  int vi = 0;\n  for (int i = 0; i <= stacks; i++) {\n    float v = (float)i / (float)stacks;\n    float phi = v * PI;\n    for (int j = 0; j <= slices; j++) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"init_ui_gl","file":"game.c","line_start":8214,"line_end":8265,"snippet":"  mesh_init(&g_mesh_sphere, verts, vcount, idx, icount);\n  free(verts);\n  free(idx);\n}\n\nstatic void build_cylinder_mesh(int slices) {\n  int vcount = (slices + 1) * 2 + (slices + 1) * 2 + 2;\n  int icount = slices * 6 + slices * 3 * 2;\n  float *verts = malloc(sizeof(float) * vcount * 6);\n  unsigned int *idx = malloc(sizeof(unsigned int) * icount);\n  if (!verts || !idx) {\n    free(verts);\n    free(idx);\n    return;\n  }\n  int vi = 0;\n  for (int i = 0; i <= slices; i++) {\n    float t = (float)i / (float)slices * PI * 2.0f;\n    float x = cosf(t);\n    float z = sinf(t);\n    verts[vi++] = x;\n    verts[vi++] = -0.5f;\n    verts[vi++] = z;\n    verts[vi++] = x;\n    verts[vi++] = 0.0f;\n    verts[vi++] = z;\n    verts[vi++] = x;\n    verts[vi++] = 0.5f;\n    verts[vi++] = z;\n    verts[vi++] = x;\n    verts[vi++] = 0.0f;\n    verts[vi++] = z;\n  }\n  int base_top = (slices + 1) * 2;\n  for (int i = 0; i <= slices; i++) {\n    float t = (float)i / (float)slices * PI * 2.0f;\n    float x = cosf(t);\n    float z = sinf(t);\n    verts[vi++] = x;\n    verts[vi++] = 0.5f;\n    verts[vi++] = z;\n    verts[vi++] = 0.0f;\n    verts[vi++] = 1.0f;\n    verts[vi++] = 0.0f;\n  }\n  int base_bottom = base_top + (slices + 1);\n  for (int i = 0; i <= slices; i++) {\n    float t = (float)i / (float)slices * PI * 2.0f;\n    float x = cosf(t);\n    float z = sinf(t);\n    verts[vi++] = x;\n    verts[vi++] = -0.5f;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"ui_measure_text_size","file":"game.c","line_start":8289,"line_end":8301,"snippet":"    int d = a + 3;\n    idx[ii++] = a;\n    idx[ii++] = b;\n    idx[ii++] = c;\n    idx[ii++] = b;\n    idx[ii++] = d;\n    idx[ii++] = c;\n  }\n  for (int i = 0; i < slices; i++) {\n    int a = base_top + i;\n    int b = base_top + i + 1;\n    int center = base_bottom + (slices + 1) * 2;\n    idx[ii++] = center;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"ui_draw_rect","file":"game.c","line_start":8370,"line_end":8372,"snippet":"  g_ui_u_tex = glGetUniformLocation(g_ui_shader, \"uTex\");\n\n  glGenVertexArrays(1, &g_ui_vao);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"ui_draw_text","file":"game.c","line_start":8374,"line_end":8405,"snippet":"  glBindVertexArray(g_ui_vao);\n  glBindBuffer(GL_ARRAY_BUFFER, g_ui_vbo);\n  glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 6 * 4, NULL, GL_DYNAMIC_DRAW);\n  glEnableVertexAttribArray(0);\n  glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 4, (void *)0);\n  glEnableVertexAttribArray(1);\n  glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 4,\n                        (void *)(sizeof(float) * 2));\n  glBindVertexArray(0);\n\n  glGenTextures(1, &g_ui_white_tex);\n  glBindTexture(GL_TEXTURE_2D, g_ui_white_tex);\n  unsigned int white = 0xffffffff;\n  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE,\n               &white);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n  g_ui_font = TTF_OpenFont(ui_font_path(), 18);\n  glEnable(GL_BLEND);\n  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n}\n\nstatic TTF_Font *ui_get_font(int size) {\n  if (size <= 0)\n    size = 18;\n  for (int i = 0; i < (int)(sizeof(g_ui_fonts) / sizeof(g_ui_fonts[0])); i++) {\n    if (g_ui_fonts[i].font && g_ui_fonts[i].size == size) {\n      return g_ui_fonts[i].font;\n    }\n  }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"ui_text_cache_clear","file":"game.c","line_start":8407,"line_end":8418,"snippet":"    if (!g_ui_fonts[i].font) {\n      g_ui_fonts[i].font = TTF_OpenFont(ui_font_path(), size);\n      g_ui_fonts[i].size = size;\n      return g_ui_fonts[i].font;\n    }\n  }\n\n  return g_ui_fonts[0].font\n             ? g_ui_fonts[0].font\n             : (g_ui_font ? g_ui_font : TTF_OpenFont(ui_font_path(), size));\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"ui_draw_text_cached","file":"game.c","line_start":8461,"line_end":8465,"snippet":"  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n  SDL_DestroySurface(rgba);\n\n  ui_draw_quad(x, y, (float)tw, (float)th, tex, WHITE);\n  glDeleteTextures(1, &tex);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"ui_button_gl","file":"game.c","line_start":8467,"line_end":8496,"snippet":"\nstatic void ui_draw_quad(float x, float y, float w, float h, GLuint tex,\n                         Color color) {\n  init_ui_gl();\n  int sw = GetScreenWidth();\n  int sh = GetScreenHeight();\n  if (sw <= 0 || sh <= 0)\n    return;\n  float verts[] = {\n      x, y, 0.0f, 0.0f, x + w, y,     1.0f, 0.0f, x + w, y + h, 1.0f, 1.0f,\n      x, y, 0.0f, 0.0f, x + w, y + h, 1.0f, 1.0f, x,     y + h, 0.0f, 1.0f,\n  };\n\n  glDisable(GL_DEPTH_TEST);\n  glEnable(GL_BLEND);\n  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\n  glUseProgram(g_ui_shader);\n  glUniform2f(g_ui_u_screen, (float)sw, (float)sh);\n  glUniform4f(g_ui_u_color, color.r / 255.0f, color.g / 255.0f,\n              color.b / 255.0f, color.a / 255.0f);\n  glActiveTexture(GL_TEXTURE0);\n  glBindTexture(GL_TEXTURE_2D, tex);\n  glUniform1i(g_ui_u_tex, 0);\n  glBindVertexArray(g_ui_vao);\n  glBindBuffer(GL_ARRAY_BUFFER, g_ui_vbo);\n  glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(verts), verts);\n  glDrawArrays(GL_TRIANGLES, 0, 6);\n  glBindVertexArray(0);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_crosshair_2d","file":"game.c","line_start":8542,"line_end":8554,"snippet":"    cache->tex = 0;\n  }\n  cache->text[0] = '\\0';\n  cache->w = 0;\n  cache->h = 0;\n  cache->color = (Color){0, 0, 0, 0};\n}\n\nstatic void ui_text_cache_update(UiTextCache *cache, const char *text,\n                                 Color color) {\n  if (!cache || !text || !text[0])\n    return;\n  init_ui_gl();"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_crosshair_3d","file":"game.c","line_start":8556,"line_end":8581,"snippet":"    return;\n\n  if (strcmp(cache->text, text) == 0 &&\n      memcmp(&cache->color, &color, sizeof(Color)) == 0 && cache->tex) {\n    return;\n  }\n\n  ui_text_cache_clear(cache);\n\n  SDL_Color c = {color.r, color.g, color.b, color.a};\n  size_t len = strlen(text);\n  SDL_Surface *surf = TTF_RenderText_Blended(g_ui_font, text, len, c);\n  if (!surf)\n    return;\n  SDL_Surface *rgba = SDL_ConvertSurface(surf, SDL_PIXELFORMAT_RGBA32);\n  SDL_DestroySurface(surf);\n  if (!rgba)\n    return;\n\n  cache->w = rgba->w;\n  cache->h = rgba->h;\n\n  glGenTextures(1, &cache->tex);\n  glBindTexture(GL_TEXTURE_2D, cache->tex);\n  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, cache->w, cache->h, 0, GL_RGBA,\n               GL_UNSIGNED_BYTE, rgba->pixels);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"poll_any_key_pressed","file":"game.c","line_start":8583,"line_end":8599,"snippet":"  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n  SDL_DestroySurface(rgba);\n\n  strncpy(cache->text, text, sizeof(cache->text) - 1);\n  cache->text[sizeof(cache->text) - 1] = '\\0';\n  cache->color = color;\n}\n\nstatic void ui_draw_text_cached(float x, float y, UiTextCache *cache) {\n  if (!cache || !cache->tex || cache->w <= 0 || cache->h <= 0)\n    return;\n  ui_draw_quad(x, y, (float)cache->w, (float)cache->h, cache->tex, WHITE);\n}\n\nstatic int ui_button_gl(Rectangle r, const char *text, int font_size) {\n  Vector2 m = GetMousePosition();\n  int hot = CheckCollisionPointRec(m, r);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_pause_menu_3d","file":"game.c","line_start":8601,"line_end":8638,"snippet":"\n  // Manual click detection: track when mouse goes from up to down\n  g_manual_click = 0;\n  if (down && !g_last_mouse_down) {\n    g_manual_click = 1;\n  }\n  g_last_mouse_down = down;\n\n  int clicked = hot && g_manual_click;\n\n  Color bg = hot ? (Color){70, 70, 90, 220} : (Color){50, 50, 70, 200};\n  ui_draw_rect(r.x, r.y, r.width, r.height, bg);\n  ui_draw_rect(r.x, r.y, r.width, 1.0f, (Color){0, 0, 0, 160});\n  ui_draw_rect(r.x, r.y + r.height - 1.0f, r.width, 1.0f,\n               (Color){0, 0, 0, 160});\n  ui_draw_rect(r.x, r.y, 1.0f, r.height, (Color){0, 0, 0, 160});\n  ui_draw_rect(r.x + r.width - 1.0f, r.y, 1.0f, r.height,\n               (Color){0, 0, 0, 160});\n\n  int tw = ui_measure_text_size(text, font_size);\n  float tx = r.x + (r.width - (float)tw) * 0.5f;\n  float ty = r.y + (r.height - (float)font_size) * 0.5f;\n  ui_draw_text_size(tx, ty, text, font_size, RAYWHITE);\n\n  return clicked;\n}\n\nstatic void ui_textbox_gl(Rectangle r, char *buf, int cap, int *active,\n                          int digits_only) {\n  Vector2 m = GetMousePosition();\n  int hot = CheckCollisionPointRec(m, r);\n  if (hot && IsMouseButtonPressed(MOUSE_LEFT_BUTTON))\n    *active = 1;\n  if (!hot && IsMouseButtonPressed(MOUSE_LEFT_BUTTON))\n    *active = 0;\n\n  Color bg = *active ? (Color){35, 35, 45, 220} : (Color){25, 25, 35, 210};\n  ui_draw_rect(r.x, r.y, r.width, r.height, bg);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_ai_training_menu_3d","file":"game.c","line_start":8640,"line_end":8682,"snippet":"  ui_draw_rect(r.x, r.y + r.height - 1.0f, r.width, 1.0f,\n               (Color){0, 0, 0, 170});\n  ui_draw_rect(r.x, r.y, 1.0f, r.height, (Color){0, 0, 0, 170});\n  ui_draw_rect(r.x + r.width - 1.0f, r.y, 1.0f, r.height,\n               (Color){0, 0, 0, 170});\n\n  if (*active) {\n    int key = GetCharPressed();\n    while (key > 0) {\n      int len = (int)strlen(buf);\n      if (key == 32 || (key >= 33 && key <= 126)) {\n        if (digits_only && !(key >= '0' && key <= '9')) {\n          key = GetCharPressed();\n          continue;\n        }\n        if (len < cap - 1) {\n          buf[len] = (char)key;\n          buf[len + 1] = 0;\n        }\n      }\n      key = GetCharPressed();\n    }\n    if (IsKeyPressed(KEY_BACKSPACE)) {\n      int len = (int)strlen(buf);\n      if (len > 0)\n        buf[len - 1] = 0;\n    }\n  }\n\n  ui_draw_text_size(r.x + 10, r.y + 10, buf, 20, RAYWHITE);\n}\n\nstatic void draw_crosshair_2d(void) {\n  Vector2 m = GetMousePosition();\n  DrawCircleLines((int)m.x, (int)m.y, 10, (Color){0, 0, 0, 200});\n  DrawLine((int)m.x - 14, (int)m.y, (int)m.x + 14, (int)m.y,\n           (Color){0, 0, 0, 200});\n  DrawLine((int)m.x, (int)m.y - 14, (int)m.x, (int)m.y + 14,\n           (Color){0, 0, 0, 200});\n  DrawCircleLines((int)m.x, (int)m.y, 8, (Color){240, 240, 240, 220});\n  DrawLine((int)m.x - 10, (int)m.y, (int)m.x + 10, (int)m.y,\n           (Color){240, 240, 240, 220});\n  DrawLine((int)m.x, (int)m.y - 10, (int)m.x, (int)m.y + 10,"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_hud_3d","file":"game.c","line_start":8684,"line_end":8716,"snippet":"}\n\nstatic void draw_crosshair_3d(void) {\n  // Test with minimap-style approach\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_CULL_FACE);\n\n  // Draw test crosshair using UI drawing functions\n  int w = GetScreenWidth();\n  int h = GetScreenHeight();\n  if (w <= 0 || h <= 0) {\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_CULL_FACE);\n    return;\n  }\n\n  float cx = w * 0.5f;\n  float cy = h * 0.5f;\n\n  // Draw a simple crosshair\n  ui_draw_rect(cx - 15.0f, cy - 2.0f, 30.0f, 4.0f, BLACK);\n  ui_draw_rect(cx - 2.0f, cy - 15.0f, 4.0f, 30.0f, BLACK);\n  ui_draw_rect(cx - 12.0f, cy - 1.0f, 24.0f, 2.0f, WHITE);\n  ui_draw_rect(cx - 1.0f, cy - 12.0f, 2.0f, 24.0f, WHITE);\n\n  glEnable(GL_DEPTH_TEST);\n  glEnable(GL_CULL_FACE);\n}\n\nstatic KeyboardKey poll_any_key_pressed(void) {\n  KeyboardKey keys[] = {\n      KEY_A,     KEY_B,      KEY_C,         KEY_D,          KEY_E,     KEY_F,\n      KEY_G,     KEY_H,      KEY_I,         KEY_J,          KEY_K,     KEY_L,"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_daynight_overlay_3d","file":"game.c","line_start":8718,"line_end":8739,"snippet":"      KEY_S,     KEY_T,      KEY_U,         KEY_V,          KEY_W,     KEY_X,\n      KEY_Y,     KEY_Z,      KEY_ONE,       KEY_TWO,        KEY_THREE, KEY_FOUR,\n      KEY_FIVE,  KEY_SIX,    KEY_SEVEN,     KEY_EIGHT,      KEY_NINE,  KEY_ZERO,\n      KEY_UP,    KEY_DOWN,   KEY_LEFT,      KEY_RIGHT,      KEY_SPACE, KEY_TAB,\n      KEY_ENTER, KEY_ESCAPE, KEY_BACKSPACE, KEY_LEFT_SHIFT, KEY_F5,    KEY_F6,\n      KEY_F7};\n  for (size_t i = 0; i < sizeof(keys) / sizeof(keys[0]); i++) {\n    if (IsKeyPressed(keys[i]))\n      return keys[i];\n  }\n  return KEY_NULL;\n}\n\nstatic void draw_pause_menu_3d(void) {\n  int w = GetScreenWidth();\n  int h = GetScreenHeight();\n  if (w <= 0 || h <= 0)\n    return;\n\n  glDisable(GL_DEPTH_TEST);\n  ui_draw_rect(0, 0, (float)w, (float)h, (Color){0, 0, 0, 140});\n  ui_draw_text(w * 0.5f - 60, h * 0.25f, \"PAUSED\", RAYWHITE);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_hurt_vignette_3d","file":"game.c","line_start":8741,"line_end":8748,"snippet":"  ui_draw_text(w * 0.5f - 140, h * 0.48f, \"2) Keybinds\", RAYWHITE);\n  ui_draw_text(w * 0.5f - 140, h * 0.56f, \"3) Graphics\", RAYWHITE);\n  ui_draw_text(w * 0.5f - 140, h * 0.64f, \"4) AI Training\", RAYWHITE);\n  ui_draw_text(w * 0.5f - 140, h * 0.72f, \"5) Back to Title\", RAYWHITE);\n  ui_draw_text(w * 0.5f - 140, h * 0.80f, \"6) Save\", RAYWHITE);\n  ui_draw_text(w * 0.5f - 140, h * 0.88f, \"Q) Quit Game\", RAYWHITE);\n  ui_draw_text(w * 0.5f - 140, h * 0.96f,\n               TextFormat(\"F7) Graphics: %s\", gfx_quality_label(g_gfx_quality)),"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_minimap_3d","file":"game.c","line_start":8750,"line_end":8844,"snippet":"  glEnable(GL_DEPTH_TEST);\n\n  if (IsKeyPressed(KEY_TWO)) {\n    g_pause_page = 1;\n  } else if (IsKeyPressed(KEY_THREE)) {\n    g_pause_page = 3;\n    g_rebind_index = -1;\n  } else if (IsKeyPressed(KEY_FOUR)) {\n    g_pause_page = 4; // AI Training page\n  } else if (IsKeyPressed(KEY_FIVE)) {\n    g_state = STATE_TITLE;\n    g_pause_page = 0;\n    g_rebind_index = -1;\n  } else if (IsKeyPressed(KEY_SIX)) {\n    save_current_world_session();\n  } else if (IsKeyPressed(KEY_Q)) {\n    g_should_quit = true;\n  }\n}\n\nstatic void draw_ai_training_menu_3d(void) {\n  int w = GetScreenWidth();\n  int h = GetScreenHeight();\n  if (w <= 0 || h <= 0)\n    return;\n\n  glDisable(GL_DEPTH_TEST);\n  ui_draw_rect(0, 0, (float)w, (float)h, (Color){0, 0, 0, 140});\n  ui_draw_text(w * 0.5f - 80, h * 0.25f, \"AI TRAINING\", RAYWHITE);\n  ui_draw_text(w * 0.5f - 160, h * 0.40f, \"1) Start AI vs AI\", RAYWHITE);\n  ui_draw_text(w * 0.5f - 160, h * 0.48f, \"2) Training Settings\", RAYWHITE);\n  ui_draw_text(w * 0.5f - 160, h * 0.56f, \"3) View Statistics\", RAYWHITE);\n  ui_draw_text(w * 0.5f - 160, h * 0.64f, \"4) Save Models\", RAYWHITE);\n  ui_draw_text(w * 0.5f - 160, h * 0.72f, \"5) Toggle Spectator Mode\", RAYWHITE);\n  ui_draw_text(w * 0.5f - 160, h * 0.80f, \"ESC) Back to Pause\", RAYWHITE);\n\n  // Display training status\n  if (g_ai_training_active) {\n    ui_draw_text(w * 0.5f - 100, h * 0.85f, \"TRAINING ACTIVE\", GREEN);\n    ui_draw_text(w * 0.5f - 140, h * 0.92f,\n                 TextFormat(\"Episode: %d | Steps: %d\", g_ai_episode_count,\n                            g_ai_step_count),\n                 RAYWHITE);\n  } else {\n    ui_draw_text(w * 0.5f - 80, h * 0.85f, \"TRAINING INACTIVE\", GRAY);\n  }\n\n  glEnable(GL_DEPTH_TEST);\n\n  if (IsKeyPressed(KEY_ONE)) {\n    start_ai_vs_ai_training();\n  } else if (IsKeyPressed(KEY_TWO)) {\n    g_pause_page = 5; // Training settings page\n  } else if (IsKeyPressed(KEY_THREE)) {\n    g_pause_page = 6; // Statistics page\n  } else if (IsKeyPressed(KEY_FOUR)) {\n    save_ai_models();\n  } else if (IsKeyPressed(KEY_FIVE)) {\n    toggle_spectator_mode();\n  } else if (IsKeyPressed(KEY_ESCAPE)) {\n    g_pause_page = 0;\n  }\n}\n\nstatic void draw_hud_3d(void) {\n  int w = GetScreenWidth();\n  int h = GetScreenHeight();\n  if (w <= 0 || h <= 0)\n    return;\n\n  init_ui_gl();\n  char line[64];\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_CULL_FACE);\n  float panel_x = 14.0f;\n  float panel_y = 12.0f;\n  float panel_w = 170.0f;\n  float panel_h = 58.0f;\n  ui_draw_rect(panel_x, panel_y, panel_w, panel_h, (Color){0, 0, 0, 120});\n  float hp01 = clamp01(player.health / 100.0f);\n  float st01 = clamp01(player.stamina / 100.0f);\n  ui_draw_rect(panel_x + 8.0f, panel_y + 26.0f, 140.0f * hp01, 8.0f,\n               (Color){220, 80, 80, 220});\n  ui_draw_rect(panel_x + 8.0f, panel_y + 44.0f, 140.0f * st01, 8.0f,\n               (Color){120, 180, 255, 220});\n  snprintf(line, sizeof(line), \"HP: %d\", (int)player.health);\n  ui_text_cache_update(&g_hud_hp, line, RAYWHITE);\n  ui_draw_text_cached(20, 20, &g_hud_hp);\n  snprintf(line, sizeof(line), \"ST: %d\", (int)player.stamina);\n  ui_text_cache_update(&g_hud_st, line, (Color){200, 220, 255, 255});\n  ui_draw_text_cached(20, 42, &g_hud_st);\n  ui_draw_text_size(20, 64,\n                    TextFormat(\"GFX: %s\", gfx_quality_label(g_gfx_quality)), 16,\n                    (Color){210, 210, 210, 220});\n  glEnable(GL_CULL_FACE);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_ui_3d_full","file":"game.c","line_start":8846,"line_end":8919,"snippet":"}\n\nstatic void draw_daynight_overlay_3d(void) {\n  float t = time_of_day;\n  float midnight_dist = fabsf(t - 0.0f);\n  midnight_dist = fminf(midnight_dist, fabsf(t - 1.0f));\n  float noon_dist = fabsf(t - 0.5f);\n\n  float night01 = clamp01((0.5f - noon_dist) * 2.0f);\n  night01 = 1.0f - night01;\n\n  unsigned char a = (unsigned char)(150 * night01);\n  ui_draw_rect(0, 0, (float)GetScreenWidth(), (float)GetScreenHeight(),\n               (Color){10, 20, 40, a});\n  double now = GetTime();\n  if (now - g_ui_cache_last_update > 0.25) {\n    ui_text_cache_update(&g_ui_cache_daynight,\n                         is_night_cached ? \"Night\" : \"Day\", RAYWHITE);\n    ui_text_cache_update(&g_ui_cache_time,\n                         TextFormat(\"Time: %0.2f\", time_of_day), RAYWHITE);\n  }\n  ui_draw_text_cached(20, 210, &g_ui_cache_daynight);\n  ui_draw_text_cached(20, 235, &g_ui_cache_time);\n}\n\nstatic void draw_hurt_vignette_3d(void) {\n  if (player_hurt_timer <= 0.0f)\n    return;\n  float t = clamp01(player_hurt_timer / 0.18f);\n  unsigned char a = (unsigned char)(120 * t);\n  ui_draw_rect(0, 0, (float)GetScreenWidth(), (float)GetScreenHeight(),\n               (Color){220, 80, 80, a});\n}\n\nstatic void draw_minimap_3d(void) {\n  int size = g_minimap_zoomed ? 240 : 160;\n  int x = 310;\n  int y = 14;\n  float radius = g_minimap_zoomed ? 18.0f : 28.0f;\n  int cells = g_minimap_zoomed ? g_minimap_cells_zoom : g_minimap_cells_normal;\n  float cell = (float)size / (float)cells;\n\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_CULL_FACE);\n  ui_draw_rect((float)x, (float)y, (float)size, (float)size,\n               (Color){0, 0, 0, 110});\n  ui_draw_rect((float)x, (float)y, (float)size, (float)size,\n               (Color){0, 0, 0, 220});\n\n  double now = GetTime();\n  int need_tex_update = !g_minimap_tex || g_minimap_tex_cells != cells ||\n                        g_minimap_tex_zoomed != g_minimap_zoomed ||\n                        (now - g_minimap_tex_last) > 0.25;\n  if (need_tex_update) {\n    if (!g_minimap_tex || g_minimap_tex_cells != cells) {\n      if (g_minimap_tex) {\n        glDeleteTextures(1, &g_minimap_tex);\n        g_minimap_tex = 0;\n      }\n      glGenTextures(1, &g_minimap_tex);\n      glBindTexture(GL_TEXTURE_2D, g_minimap_tex);\n      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, cells, cells, 0, GL_RGBA,\n                   GL_UNSIGNED_BYTE, NULL);\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n      g_minimap_tex_cells = cells;\n    }\n\n    unsigned char *pixels = (unsigned char *)malloc((size_t)cells * cells * 4);\n    if (pixels) {\n      for (int gy = 0; gy < cells; gy++) {\n        for (int gx = 0; gx < cells; gx++) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_profiler_3d","file":"game.c","line_start":8921,"line_end":8956,"snippet":"          float ny = ((float)gy / (float)(cells - 1)) * 2.0f - 1.0f;\n          Vector2 wp = (Vector2){player.position.x + nx * radius,\n                                 player.position.y + ny * radius};\n          int cx = (int)(wp.x / CHUNK_SIZE);\n          int cy = (int)(wp.y / CHUNK_SIZE);\n          Chunk *c = get_chunk(cx, cy);\n          Color bc = c ? Fade(biome_colors[c->biome_type], 0.85f)\n                       : (Color){0, 0, 0, 255};\n          int idx = (gy * cells + gx) * 4;\n          pixels[idx + 0] = bc.r;\n          pixels[idx + 1] = bc.g;\n          pixels[idx + 2] = bc.b;\n          pixels[idx + 3] = 255;\n        }\n      }\n      glBindTexture(GL_TEXTURE_2D, g_minimap_tex);\n      glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, cells, cells, GL_RGBA,\n                      GL_UNSIGNED_BYTE, pixels);\n      free(pixels);\n    }\n    g_minimap_tex_last = now;\n    g_minimap_tex_zoomed = g_minimap_zoomed;\n  }\n\n  if (g_minimap_tex) {\n    ui_draw_quad((float)x, (float)y, (float)size, (float)size, g_minimap_tex,\n                 WHITE);\n  }\n\n  // draw player position indicator\n  Vector2 minimap_center = (Vector2){x + size / 2, y + size / 2};\n  Vector2 d = Vector2Subtract(\n      player.position,\n      (Vector2){(WORLD_SIZE * CHUNK_SIZE) / 2, (WORLD_SIZE * CHUNK_SIZE) / 2});\n  float pxm = (d.x / (radius * 2.0f) + 0.5f) * size;\n  float pym = (d.y / (radius * 2.0f) + 0.5f) * size;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_hover_label_3d","file":"game.c","line_start":8958,"line_end":9040,"snippet":"\n  // draw tribe bases\n  for (int t = 0; t < TRIBE_COUNT; t++) {\n    Vector2 base_pos = tribes[t].base.position;\n    Vector2 base_d =\n        Vector2Subtract(base_pos, (Vector2){(WORLD_SIZE * CHUNK_SIZE) / 2,\n                                            (WORLD_SIZE * CHUNK_SIZE) / 2});\n    float bx = (base_d.x / (radius * 2.0f) + 0.5f) * size;\n    float by = (base_d.y / (radius * 2.0f) + 0.5f) * size;\n    ui_draw_rect(x + bx - 2.0f, y + by - 2.0f, 4.0f, 4.0f, tribes[t].color);\n  }\n\n  ui_draw_rect(x + size / 2 - 2.0f, y + size / 2 - 2.0f, 4.0f, 4.0f, RAYWHITE);\n\n  glEnable(GL_DEPTH_TEST);\n  glEnable(GL_CULL_FACE);\n}\n\nstatic void draw_ui_3d_full(void) {\n  // Use the same OpenGL state management as the working minimap\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_CULL_FACE);\n\n  float panel_x = 14.0f;\n  float panel_y = 12.0f;\n  float panel_w = 280.0f;\n  float panel_h = 170.0f;\n\n  double now = GetTime();\n  if (now - g_ui_cache_last_update > 0.25) {\n    ui_text_cache_update(&g_ui_cache_player, \"Player\", RAYWHITE);\n    ui_text_cache_update(&g_ui_cache_hp,\n                         TextFormat(\"HP: %d\", (int)player.health), RAYWHITE);\n    ui_text_cache_update(&g_ui_cache_st,\n                         TextFormat(\"ST: %d\", (int)player.stamina), RAYWHITE);\n    ui_text_cache_update(&g_ui_cache_wood,\n                         TextFormat(\"Wood: %d  Stone: %d\", inv_wood, inv_stone),\n                         RAYWHITE);\n    ui_text_cache_update(&g_ui_cache_gold,\n                         TextFormat(\"Gold: %d  Food: %d\", inv_gold, inv_food),\n                         RAYWHITE);\n    ui_text_cache_update(\n        &g_ui_cache_shards,\n        TextFormat(\"Shards: %d  Arrows: %d\", inv_shards, inv_arrows), RAYWHITE);\n    for (int t = 0; t < TRIBE_COUNT; t++) {\n      ui_text_cache_update(&g_ui_cache_base[t], TextFormat(\"Base %d\", t),\n                           tribes[t].color);\n    }\n    g_ui_cache_last_update = now;\n  }\n\n  // Draw main HUD panel\n  ui_draw_rect(panel_x, panel_y, panel_w, panel_h, (Color){0, 0, 0, 110});\n  ui_draw_rect(panel_x, panel_y, panel_w, 1.0f, (Color){0, 0, 0, 200});\n  ui_draw_rect(panel_x, panel_y + panel_h - 1.0f, panel_w, 1.0f,\n               (Color){0, 0, 0, 200});\n  ui_draw_rect(panel_x, panel_y, 1.0f, panel_h, (Color){0, 0, 0, 200});\n  ui_draw_rect(panel_x + panel_w - 1.0f, panel_y, 1.0f, panel_h,\n               (Color){0, 0, 0, 200});\n\n  float hp01 = clamp01(player.health / 100.0f);\n  float st01 = clamp01(player.stamina / 100.0f);\n\n  ui_draw_text_cached(panel_x + 10, panel_y + 6, &g_ui_cache_player);\n  ui_draw_text_cached(panel_x + 10, panel_y + 30, &g_ui_cache_hp);\n  ui_draw_text_cached(panel_x + 10, panel_y + 50, &g_ui_cache_st);\n\n  // Health bar (moved below stats)\n  ui_draw_rect(panel_x + 10, panel_y + 75, 160.0f, 12.0f,\n               (Color){0, 0, 0, 140});\n  ui_draw_rect(panel_x + 10, panel_y + 75, 160.0f * hp01, 12.0f,\n               (Color){80, 220, 80, 255});\n\n  // Stamina bar (moved below health bar)\n  ui_draw_rect(panel_x + 10, panel_y + 92, 160.0f, 12.0f,\n               (Color){0, 0, 0, 140});\n  ui_draw_rect(panel_x + 10, panel_y + 92, 160.0f * st01, 12.0f,\n               (Color){220, 220, 80, 255});\n\n  ui_draw_text_cached(panel_x + 10, panel_y + 112, &g_ui_cache_wood);\n  ui_draw_text_cached(panel_x + 10, panel_y + 128, &g_ui_cache_gold);\n  ui_draw_text_cached(panel_x + 10, panel_y + 144, &g_ui_cache_shards);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_crafting_ui_3d","file":"game.c","line_start":9042,"line_end":9071,"snippet":"  for (int t = 0; t < TRIBE_COUNT; t++) {\n    ui_draw_text_cached(panel_x + 150, panel_y + 112 + t * 20,\n                        &g_ui_cache_base[t]);\n  }\n\n  glEnable(GL_DEPTH_TEST);\n  glEnable(GL_CULL_FACE);\n}\n\nstatic void draw_profiler_3d(void) {\n  int w = GetScreenWidth();\n  if (w <= 0)\n    return;\n\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_CULL_FACE);\n\n  float x = (float)(w - 280);\n  float y = 14.0f;\n  float bw = 260.0f;\n  float bh = 120.0f;\n  ui_draw_rect(x, y, bw, bh, (Color){0, 0, 0, 140});\n  ui_draw_rect(x, y, bw, 1.0f, (Color){0, 0, 0, 220});\n  ui_draw_rect(x, y + bh - 1.0f, bw, 1.0f, (Color){0, 0, 0, 220});\n  ui_draw_text_size(x + 8, y + 6, \"Profiler (F7)\", 16, RAYWHITE);\n\n  ui_draw_text_size(x + 8, y + 28,\n                    TextFormat(\"Frame: %.2f ms\", g_prof_total_ms), 16,\n                    RAYWHITE);\n  ui_draw_text_size(x + 8, y + 46,"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_simple_letter","file":"game.c","line_start":9074,"line_end":9207,"snippet":"  ui_draw_text_size(x + 8, y + 62,\n                    TextFormat(\"Render: %.2f ms\", g_prof_render_ms), 14,\n                    (Color){210, 210, 210, 220});\n  ui_draw_text_size(x + 8, y + 78, TextFormat(\"UI: %.2f ms\", g_prof_ui_ms), 14,\n                    (Color){210, 210, 210, 220});\n  ui_draw_text_size(\n      x + 8, y + 96,\n      TextFormat(\"Draws: %d  Tris: %d\", g_prof_draw_calls, g_prof_triangles),\n      14, (Color){200, 200, 200, 220});\n\n  glEnable(GL_CULL_FACE);\n  glEnable(GL_DEPTH_TEST);\n}\n\nstatic void draw_hover_label_3d(void) {\n  // Disable 3D rendering state for 2D UI drawing\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_CULL_FACE);\n\n  int hp = -1;\n  int cx = (int)(player.position.x / CHUNK_SIZE);\n  int cy = (int)(player.position.y / CHUNK_SIZE);\n  Chunk *c = get_chunk(cx, cy);\n\n  const char *label = NULL;\n  if (c) {\n    float best_d = 3.5f;\n    pthread_rwlock_rdlock(&c->lock);\n    for (int i = 0; i < c->resource_count; i++) {\n      Resource *r = &c->resources[i];\n      if (r->health <= 0)\n        continue;\n      Vector2 d = Vector2Subtract(r->position, player.position);\n      float dist = Vector2Length(d);\n      if (dist < best_d) {\n        best_d = dist;\n        label = res_name(r->type);\n        hp = r->health;\n      }\n    }\n    for (int i = 0; i < MAX_MOBS; i++) {\n      Mob *m = &c->mobs[i];\n      if (m->health <= 0)\n        continue;\n      Vector2 d = Vector2Subtract(m->position, player.position);\n      float dist = Vector2Length(d);\n      if (dist < best_d) {\n        best_d = dist;\n        label = mob_name(m->type);\n        hp = m->health;\n      }\n    }\n    pthread_rwlock_unlock(&c->lock);\n  }\n\n  if (label) {\n    char line[80];\n    if (hp > 0)\n      snprintf(line, sizeof(line), \"%s (%d)\", label, hp);\n    else\n      snprintf(line, sizeof(line), \"%s\", label);\n    Vector2 mouse = GetMousePosition();\n\n    // Position label above cursor with offset\n    float label_x = mouse.x + 20.0f;\n    float label_y = mouse.y - 40.0f;\n\n    // Draw background with better visibility\n    ui_draw_rect(label_x - 8, label_y - 8, 180, 28, (Color){0, 0, 0, 180});\n    ui_draw_rect(label_x - 6, label_y - 6, 176, 24, (Color){0, 0, 0, 120});\n\n    // Draw text\n    ui_draw_text_size(label_x, label_y + 5, line, 18, RAYWHITE);\n\n    // Draw health bar if entity has health\n    if (hp > 0) {\n      float hp_percent = (float)hp / 100.0f;\n      float bar_width = 160.0f;\n      float bar_height = 8.0f;\n      float bar_y = label_y + 25.0f;\n\n      // Health bar background\n      ui_draw_rect(label_x - 8, bar_y - 4, bar_width, bar_height,\n                   (Color){0, 0, 0, 180});\n\n      // Health bar fill (green to red gradient)\n      Color health_color =\n          hp > 50 ? (Color){80, 220, 80, 255} : (Color){220, 80, 80, 255};\n      ui_draw_rect(label_x - 8, bar_y - 4, bar_width * hp_percent, bar_height,\n                   health_color);\n    }\n  }\n\n  // Re-enable 3D rendering state\n  glEnable(GL_DEPTH_TEST);\n  glEnable(GL_CULL_FACE);\n}\n\nstatic void draw_crafting_ui_3d(void) {\n  if (!crafting_open)\n    return;\n  float x = 20.0f;\n  float y = 260.0f;\n  float w = 360.0f;\n  float h = 180.0f;\n  ui_draw_rect(x, y, w, h, (Color){0, 0, 0, 120});\n  ui_draw_rect(x, y, w, 1.0f, (Color){0, 0, 0, 220});\n  ui_draw_rect(x, y + h - 1.0f, w, 1.0f, (Color){0, 0, 0, 220});\n  ui_draw_rect(x, y, 1.0f, h, (Color){0, 0, 0, 220});\n  ui_draw_rect(x + w - 1.0f, y, 1.0f, h, (Color){0, 0, 0, 220});\n  ui_draw_text_size(x + 10, y + 6, \"Crafting (TAB)\", 18, RAYWHITE);\n\n  float ty = y + 32.0f;\n  for (int i = 0; i < recipe_count; i++) {\n    Recipe *r = &recipes[i];\n    if (!r->name)\n      continue;\n    ui_draw_text_size(\n        x + 10, ty,\n        TextFormat(\"%d) %s  [W%d S%d G%d F%d]%s\", i + 1, r->name, r->wood,\n                   r->stone, r->gold, r->food,\n                   (r->unlock_flag && *r->unlock_flag) ? \" (OWNED)\" : \"\"),\n        16, RAYWHITE);\n    ty += 22.0f;\n    if (ty > y + h - 20.0f)\n      break;\n  }\n}\n\n// Simple function to draw individual letter shapes\nstatic void draw_simple_letter(char letter, int x, int y, int width, int height) {\n  switch(letter) {\n    case 'S':\n      // Draw S shape as connected lines"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_title_screen_3d","file":"game.c","line_start":9209,"line_end":9450,"snippet":"      glVertex2f(x + width - 2, y + 2);\n      glVertex2f(x + 2, y + 2);\n      glVertex2f(x + 2, y + height/2);\n      glVertex2f(x + width - 2, y + height/2);\n      glVertex2f(x + width - 2, y + height - 2);\n      glVertex2f(x + 2, y + height - 2);\n      glEnd();\n      break;\n    case 'T':\n      // Draw T shape\n      glBegin(GL_LINES);\n      glVertex2f(x + 2, y + 2);\n      glVertex2f(x + width - 2, y + 2);\n      glVertex2f(x + width/2, y + 2);\n      glVertex2f(x + width/2, y + height - 2);\n      glEnd();\n      break;\n    case 'A':\n      // Draw A shape\n      glBegin(GL_LINES);\n      glVertex2f(x + width/2, y + 2);\n      glVertex2f(x + 2, y + height - 2);\n      glVertex2f(x + width/2, y + 2);\n      glVertex2f(x + width - 2, y + height - 2);\n      glVertex2f(x + 2, y + height/2);\n      glVertex2f(x + width - 2, y + height/2);\n      glEnd();\n      break;\n    case 'R':\n      // Draw R shape\n      glBegin(GL_LINE_STRIP);\n      glVertex2f(x + 2, y + height - 2);\n      glVertex2f(x + 2, y + 2);\n      glVertex2f(x + width - 2, y + 2);\n      glVertex2f(x + width - 2, y + height/2);\n      glVertex2f(x + 2, y + height/2);\n      glEnd();\n      glBegin(GL_LINES);\n      glVertex2f(x + width - 2, y + height/2);\n      glVertex2f(x + width - 2, y + height - 2);\n      glEnd();\n      break;\n    case 'C':\n      // Draw C shape\n      glBegin(GL_LINE_STRIP);\n      glVertex2f(x + width - 2, y + 2);\n      glVertex2f(x + 2, y + 2);\n      glVertex2f(x + 2, y + height - 2);\n      glVertex2f(x + width - 2, y + height - 2);\n      glEnd();\n      break;\n    case 'E':\n      // Draw E shape\n      glBegin(GL_LINES);\n      glVertex2f(x + 2, y + height - 2);\n      glVertex2f(x + 2, y + 2);\n      glVertex2f(x + 2, y + 2);\n      glVertex2f(x + width - 2, y + 2);\n      glVertex2f(x + 2, y + height/2);\n      glVertex2f(x + width - 4, y + height/2);\n      glVertex2f(x + 2, y + height - 2);\n      glVertex2f(x + width - 2, y + height - 2);\n      glEnd();\n      break;\n    case 'U':\n      // Draw U shape\n      glBegin(GL_LINE_STRIP);\n      glVertex2f(x + 2, y + 2);\n      glVertex2f(x + 2, y + height - 2);\n      glVertex2f(x + width - 2, y + height - 2);\n      glVertex2f(x + width - 2, y + 2);\n      glEnd();\n      break;\n    case 'I':\n      // Draw I shape\n      glBegin(GL_LINES);\n      glVertex2f(x + 2, y + 2);\n      glVertex2f(x + width - 2, y + 2);\n      glVertex2f(x + width/2, y + 2);\n      glVertex2f(x + width/2, y + height - 2);\n      glVertex2f(x + 2, y + height - 2);\n      glVertex2f(x + width - 2, y + height - 2);\n      glEnd();\n      break;\n    case 'Q':\n      // Draw Q shape\n      glBegin(GL_LINE_STRIP);\n      glVertex2f(x + width - 2, y + 2);\n      glVertex2f(x + 2, y + 2);\n      glVertex2f(x + 2, y + height - 2);\n      glVertex2f(x + width - 2, y + height - 2);\n      glEnd();\n      glBegin(GL_LINES);\n      glVertex2f(x + width/2, y + height/2);\n      glVertex2f(x + width - 2, y + height - 2);\n      glEnd();\n      break;\n    case 'M':\n      // Draw M shape\n      glBegin(GL_LINE_STRIP);\n      glVertex2f(x + 2, y + height - 2);\n      glVertex2f(x + 2, y + 2);\n      glVertex2f(x + width/2, y + height/2);\n      glVertex2f(x + width - 2, y + 2);\n      glVertex2f(x + width - 2, y + height - 2);\n      glEnd();\n      break;\n    case 'F':\n      // Draw F shape\n      glBegin(GL_LINES);\n      glVertex2f(x + 2, y + height - 2);\n      glVertex2f(x + 2, y + 2);\n      glVertex2f(x + 2, y + 2);\n      glVertex2f(x + width - 2, y + 2);\n      glVertex2f(x + 2, y + height/2);\n      glVertex2f(x + width - 4, y + height/2);\n      glEnd();\n      break;\n    default:\n      // Draw rectangle for unknown letters\n      glBegin(GL_LINE_LOOP);\n      glVertex2f(x, y);\n      glVertex2f(x + width, y);\n      glVertex2f(x + width, y + height);\n      glVertex2f(x, y + height);\n      glEnd();\n      break;\n  }\n}\n\nstatic void draw_title_screen_3d(void) {\n  // Get actual window dimensions\n  int w, h;\n  SDL_GetWindowSize(g_window, &w, &h);\n  \n  printf(\"Drawing title screen: %d x %d\\n\", w, h);\n  \n  // Set up OpenGL for 2D rendering\n  glViewport(0, 0, w, h);\n  glClearColor(0.07f, 0.07f, 0.11f, 1.0f);  // Dark blue background\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n  \n  // Disable depth testing for UI\n  glDisable(GL_DEPTH_TEST);\n  \n  // Set up simple 2D projection\n  glMatrixMode(GL_PROJECTION);\n  glLoadIdentity();\n  glOrtho(0, w, h, 0, -1, 1); // Correct coordinate system (0,0 at top-left)\n  glMatrixMode(GL_MODELVIEW);\n  glLoadIdentity();\n  \n  // Enable blending for transparency\n  glEnable(GL_BLEND);\n  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n  \n  // Draw title background panel\n  glColor3f(0.15f, 0.2f, 0.35f);\n  glBegin(GL_QUADS);\n  glVertex2f(w * 0.1f, h * 0.05f);\n  glVertex2f(w * 0.9f, h * 0.05f);\n  glVertex2f(w * 0.9f, h * 0.35f);\n  glVertex2f(w * 0.1f, h * 0.35f);\n  glEnd();\n  \n  // Draw start button (green)\n  glColor3f(0.2f, 0.7f, 0.2f);\n  glBegin(GL_QUADS);\n  glVertex2f(w * 0.35f, h * 0.45f);\n  glVertex2f(w * 0.65f, h * 0.45f);\n  glVertex2f(w * 0.65f, h * 0.55f);\n  glVertex2f(w * 0.35f, h * 0.55f);\n  glEnd();\n  \n  // Draw create world button (blue)\n  glColor3f(0.2f, 0.4f, 0.8f);\n  glBegin(GL_QUADS);\n  glVertex2f(w * 0.35f, h * 0.60f);\n  glVertex2f(w * 0.65f, h * 0.60f);\n  glVertex2f(w * 0.65f, h * 0.70f);\n  glVertex2f(w * 0.35f, h * 0.70f);\n  glEnd();\n  \n  // Draw quit button (red)\n  glColor3f(0.8f, 0.2f, 0.2f);\n  glBegin(GL_QUADS);\n  glVertex2f(w * 0.35f, h * 0.75f);\n  glVertex2f(w * 0.65f, h * 0.75f);\n  glVertex2f(w * 0.65f, h * 0.85f);\n  glVertex2f(w * 0.35f, h * 0.85f);\n  glEnd();\n  \n  // Simple text rendering using OpenGL rectangles (since Raylib text doesn't work with SDL context)\n  \n  // Draw \"SAMCRAFT\" title using rectangles\n  glColor3f(1.0f, 1.0f, 1.0f); // White\n  int title_width = 200;\n  int title_height = 40;\n  int title_x = w / 2 - title_width / 2;\n  int title_y = h * 0.1f;\n  \n  // Draw title background\n  glBegin(GL_QUADS);\n  glVertex2f(title_x - 5, title_y - 5);\n  glVertex2f(title_x + title_width + 5, title_y - 5);\n  glVertex2f(title_x + title_width + 5, title_y + title_height + 5);\n  glVertex2f(title_x - 5, title_y + title_height + 5);\n  glEnd();\n  \n  // Draw \"SAMCRAFT\" text with actual letter shapes\n  glColor3f(1.0f, 1.0f, 1.0f); // White text\n  int letter_width = 40;\n  int letter_height = 60;\n  int letter_spacing = 15;\n  const char* title = \"SAMCRAFT\";\n  \n  for (int i = 0; title[i]; i++) {\n    int x = title_x + 20 + i * (letter_width + letter_spacing);\n    int y = title_y + 15;\n    \n    // Draw letter shapes using lines\n    glLineWidth(3.0f);\n    glBegin(GL_LINES);\n    \n    switch(title[i]) {\n      case 'S':\n        // Draw S shape\n        glVertex2f(x + 5, y + 5);\n        glVertex2f(x + letter_width - 5, y + 5);\n        glVertex2f(x + letter_width - 5, y + letter_height/2);\n        glVertex2f(x + 5, y + letter_height/2);\n        glVertex2f(x + 5, y + letter_height - 5);\n        glVertex2f(x + letter_width - 5, y + letter_height - 5);\n        break;\n      case 'A':\n        // Draw A shape\n        glVertex2f(x + letter_width/2, y + 5);\n        glVertex2f(x + 5, y + letter_height - 5);\n        glVertex2f(x + letter_width - 5, y + letter_height - 5);\n        glVertex2f(x + letter_width/2, y + 5);\n        glVertex2f(x + 5, y + letter_height/2);\n        glVertex2f(x + letter_width - 5, y + letter_height/2);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_world_create_3d","file":"game.c","line_start":9452,"line_end":9478,"snippet":"      case 'M':\n        // Draw M shape\n        glVertex2f(x + 5, y + letter_height - 5);\n        glVertex2f(x + 5, y + 5);\n        glVertex2f(x + 5, y + 5);\n        glVertex2f(x + letter_width/2, y + letter_height/2);\n        glVertex2f(x + letter_width/2, y + letter_height/2);\n        glVertex2f(x + letter_width - 5, y + 5);\n        glVertex2f(x + letter_width - 5, y + 5);\n        glVertex2f(x + letter_width - 5, y + letter_height - 5);\n        break;\n      case 'C':\n        // Draw C shape\n        glVertex2f(x + letter_width - 5, y + 5);\n        glVertex2f(x + 5, y + 5);\n        glVertex2f(x + 5, y + letter_height - 5);\n        glVertex2f(x + letter_width - 5, y + letter_height - 5);\n        break;\n      case 'R':\n        // Draw R shape\n        glVertex2f(x + 5, y + letter_height - 5);\n        glVertex2f(x + 5, y + 5);\n        glVertex2f(x + 5, y + 5);\n        glVertex2f(x + letter_width - 5, y + 5);\n        glVertex2f(x + letter_width - 5, y + 5);\n        glVertex2f(x + letter_width - 5, y + letter_height/2);\n        glVertex2f(x + letter_width - 5, y + letter_height/2);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_world_select_3d","file":"game.c","line_start":9480,"line_end":9644,"snippet":"        glVertex2f(x + 5, y + letter_height/2);\n        glVertex2f(x + letter_width - 5, y + letter_height - 5);\n        break;\n      case 'F':\n        // Draw F shape\n        glVertex2f(x + 5, y + letter_height - 5);\n        glVertex2f(x + 5, y + 5);\n        glVertex2f(x + 5, y + 5);\n        glVertex2f(x + letter_width - 5, y + 5);\n        glVertex2f(x + 5, y + letter_height/2);\n        glVertex2f(x + letter_width - 10, y + letter_height/2);\n        break;\n      case 'T':\n        // Draw T shape\n        glVertex2f(x + 5, y + 5);\n        glVertex2f(x + letter_width - 5, y + 5);\n        glVertex2f(x + letter_width/2, y + 5);\n        glVertex2f(x + letter_width/2, y + letter_height - 5);\n        break;\n      default:\n        // Draw rectangle for unknown letters\n        glBegin(GL_LINE_LOOP);\n        glVertex2f(x, y);\n        glVertex2f(x + letter_width, y);\n        glVertex2f(x + letter_width, y + letter_height);\n        glVertex2f(x, y + letter_height);\n        glEnd();\n        glLineWidth(3.0f);\n        glBegin(GL_LINES);\n        break;\n    }\n    glEnd();\n    glLineWidth(1.0f);\n  }\n  \n  // Draw button labels using actual text shapes\n  glColor3f(1.0f, 1.0f, 1.0f); // White text\n  glLineWidth(2.0f);\n  \n  // START GAME label\n  int start_x = w / 2 - 80;\n  int start_y = h * 0.48f;\n  const char* start_text = \"START\";\n  for (int i = 0; start_text[i]; i++) {\n    int x = start_x + i * 25;\n    int y = start_y + 5;\n    draw_simple_letter(start_text[i], x, y, 20, 25);\n  }\n  \n  // CREATE WORLD label  \n  int create_x = w / 2 - 90;\n  int create_y = h * 0.63f;\n  const char* create_text = \"CREATE\";\n  for (int i = 0; create_text[i]; i++) {\n    int x = create_x + i * 25;\n    int y = create_y + 5;\n    draw_simple_letter(create_text[i], x, y, 20, 25);\n  }\n  \n  // QUIT label\n  int quit_x = w / 2 - 40;\n  int quit_y = h * 0.78f;\n  const char* quit_text = \"QUIT\";\n  for (int i = 0; quit_text[i]; i++) {\n    int x = quit_x + i * 25;\n    int y = quit_y + 5;\n    draw_simple_letter(quit_text[i], x, y, 20, 25);\n  }\n  \n  glLineWidth(1.0f);\n  \n  // Re-enable depth testing\n  glEnable(GL_DEPTH_TEST);\n  \n  // Handle mouse clicks for buttons\n  if (IsMouseButtonPressed_SDL(1)) { // Left click\n    float mouse_x = g_mouse_x;\n    float mouse_y = g_mouse_y;\n    \n    // Check start button (green rectangle)\n    if (mouse_x >= w * 0.35f && mouse_x <= w * 0.65f &&\n        mouse_y >= h * 0.45f && mouse_y <= h * 0.55f) {\n      g_state = STATE_WORLD_SELECT;\n      printf(\"Start button clicked - going to world select\\n\");\n    }\n    \n    // Check create world button (blue rectangle)\n    if (mouse_x >= w * 0.35f && mouse_x <= w * 0.65f &&\n        mouse_y >= h * 0.60f && mouse_y <= h * 0.70f) {\n      g_state = STATE_WORLD_CREATE;\n      printf(\"Create World button clicked\\n\");\n    }\n    \n    // Check quit button (red rectangle)\n    if (mouse_x >= w * 0.35f && mouse_x <= w * 0.65f &&\n        mouse_y >= h * 0.75f && mouse_y <= h * 0.85f) {\n      g_should_quit = 1;\n      printf(\"Quit button clicked - exiting\\n\");\n    }\n  }\n}\n\nstatic void draw_world_create_3d(void) {\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_CULL_FACE);\n  ui_draw_rect(0, 0, (float)GetScreenWidth(), (float)GetScreenHeight(),\n               (Color){18, 18, 28, 255});\n  ui_draw_text_size(60, 50, \"Create World\", 34, RAYWHITE);\n  ui_draw_text_size(60, 120, \"World Name\", 18, RAYWHITE);\n  ui_textbox_gl((Rectangle){60, 145, 360, 45}, g_world_name,\n                sizeof(g_world_name), &g_typing_name, 0);\n  ui_draw_text_size(60, 205, \"Seed\", 18, RAYWHITE);\n  ui_textbox_gl((Rectangle){60, 230, 200, 45}, g_seed_text, sizeof(g_seed_text),\n                &g_typing_seed, 1);\n\n  if (ui_button_gl((Rectangle){60, 300, 200, 50}, \"Create & Play\", 20)) {\n    g_world_seed = (uint32_t)strtoul(g_seed_text, NULL, 10);\n    world_reset(g_world_seed);\n    save_world_to_disk(g_world_name); // create initial save\n    g_state = STATE_PLAYING;\n    ensure_agents_ready_on_enter();\n  }\n\n  if (ui_button_gl((Rectangle){280, 300, 140, 50}, \"Back\", 20)) {\n    g_state = STATE_TITLE;\n  }\n  glEnable(GL_CULL_FACE);\n  glEnable(GL_DEPTH_TEST);\n}\n\nstatic void draw_world_select_3d(void) {\n  static int initialized = 0;\n  if (!initialized) {\n    world_list_refresh(&g_world_list);\n    initialized = 1;\n  }\n\n  world_list_ensure_valid(&g_world_list);\n\n  int w = GetScreenWidth();\n  int h = GetScreenHeight();\n  if (w <= 0 || h <= 0)\n    return;\n\n  // If 3D renderer is not ready, use 2D fallback rendering\n  if (!g_3d_ready) {\n    // 2D fallback rendering with proper scaling\n    float ui_scale_x = w / 1280.0f;\n    float ui_scale_y = h / 800.0f;\n\n    DrawRectangle(0, 0, w, h, (Color){18, 18, 28, 255});\n    DrawText(\"Select World\", (int)(40 * ui_scale_x), (int)(30 * ui_scale_y),\n             (int)(44 * ui_scale_y), RAYWHITE);\n\n    Rectangle listBox = {(float)(40 * ui_scale_x), (float)(100 * ui_scale_y),\n                         (float)(520 * ui_scale_x),\n                         (float)(h - 180 * ui_scale_y)};\n    DrawRectangleRounded(listBox, 0.12f, 8, (Color){25, 25, 40, 255});\n    DrawRectangleRoundedLines(listBox, 0.12f, 8, (Color){0, 0, 0, 160});\n\n    // Scale font sizes for world list items\n    int item_font_size = (int)(22 * ui_scale_y);\n    if (item_font_size < 12)\n      item_font_size = 12;\n    if (item_font_size > 32)"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_keybinds_menu_3d","file":"game.c","line_start":9646,"line_end":9700,"snippet":"\n    int itemH = (int)(44 * ui_scale_y);\n    int visible = (int)(listBox.height / itemH);\n    if (visible < 1)\n      visible = 1;\n\n    // mouse wheel scroll\n    float wheel = GetMouseWheelMove();\n    if (wheel != 0.0f && g_world_list.count > 0) {\n      g_world_list.scroll -= (int)wheel;\n      if (g_world_list.scroll < 0)\n        g_world_list.scroll = 0;\n      int maxScroll =\n          (g_world_list.count > visible) ? (g_world_list.count - visible) : 0;\n      if (g_world_list.scroll > maxScroll)\n        g_world_list.scroll = maxScroll;\n    }\n\n    // keyboard nav\n    if (IsKeyPressed(KEY_UP) && g_world_list.selected > 0)\n      g_world_list.selected--;\n    if (IsKeyPressed(KEY_DOWN) &&\n        g_world_list.selected < g_world_list.count - 1)\n      g_world_list.selected++;\n\n    // keep selected in view\n    if (g_world_list.selected >= 0) {\n      if (g_world_list.selected < g_world_list.scroll)\n        g_world_list.scroll = g_world_list.selected;\n      if (g_world_list.selected >= g_world_list.scroll + visible)\n        g_world_list.scroll = g_world_list.selected - visible + 1;\n    }\n\n    // draw items\n    for (int i = 0; i < visible; i++) {\n      int idx = g_world_list.scroll + i;\n      if (idx >= g_world_list.count)\n        break;\n\n      Rectangle row = {listBox.x + 10, listBox.y + 10 + i * itemH,\n                       listBox.width - 20, (float)itemH - 6};\n      int hot = CheckCollisionPointRec(GetMousePosition(), row);\n\n      Color bg = (Color){35, 35, 55, 255};\n      if (idx == g_world_list.selected)\n        bg = (Color){60, 60, 95, 255};\n      else if (hot)\n        bg = (Color){45, 45, 70, 255};\n\n      DrawRectangleRounded(row, 0.18f, 8, bg);\n\n      DrawText(g_world_list.names[idx], (int)(row.x + 12), (int)(row.y + 10),\n               item_font_size, RAYWHITE);\n\n      if (hot && IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_graphics_menu_3d","file":"game.c","line_start":9702,"line_end":9782,"snippet":"      }\n    }\n\n    // Scale buttons\n    float button_width = 260 * ui_scale_x;\n    float button_height = 54 * ui_scale_y;\n    float button_x = 600 * ui_scale_x;\n\n    Rectangle rPlay = {button_x, 140 * ui_scale_y, button_width, button_height};\n    Rectangle rDelete = {button_x, 210 * ui_scale_y, button_width,\n                         button_height};\n    Rectangle rCreate = {button_x, 280 * ui_scale_y, button_width,\n                         button_height};\n    Rectangle rBack = {button_x, 350 * ui_scale_y, button_width, button_height};\n\n    int hasSelection = (g_world_list.selected >= 0 &&\n                        g_world_list.selected < g_world_list.count);\n\n    if (ui_button(rPlay, hasSelection ? \"Play Selected\" : \"Play (no world)\")) {\n      if (hasSelection) {\n        snprintf(g_world_name, sizeof(g_world_name), \"%s\",\n                 g_world_list.names[g_world_list.selected]);\n\n        // load\n        if (!load_world_from_disk(g_world_name)) {\n          // if load fails, create fresh using current seed\n          world_reset(g_world_seed);\n          save_world_to_disk(g_world_name);\n          save_models_to_disk(g_world_name);\n        } else {\n          load_models_from_disk(g_world_name);\n        }\n        g_state = STATE_PLAYING;\n        ensure_agents_ready_on_enter();\n      }\n    }\n\n    if (ui_button(rDelete,\n                  hasSelection ? \"Delete World\" : \"Delete (no world)\")) {\n      if (hasSelection) {\n        const char *wname = g_world_list.names[g_world_list.selected];\n        delete_world_by_name(wname);\n\n        world_list_refresh(&g_world_list);\n        world_list_ensure_valid(&g_world_list);\n      }\n    }\n\n    if (ui_button(rCreate, \"Create New World\")) {\n      // go to your create UI\n      g_state = STATE_WORLD_CREATE;\n    }\n\n    if (ui_button(rBack, \"Back\")) {\n      g_state = STATE_TITLE;\n    }\n\n    // Enter to play\n    if (hasSelection && IsKeyPressed(KEY_ENTER)) {\n      snprintf(g_world_name, sizeof(g_world_name), \"%s\",\n               g_world_list.names[g_world_list.selected]);\n      if (!load_world_from_disk(g_world_name)) {\n        world_reset(g_world_seed);\n        save_world_to_disk(g_world_name);\n      }\n      g_state = STATE_PLAYING;\n      ensure_agents_ready_on_enter();\n    }\n    return;\n  }\n  glEnable(GL_CULL_FACE);\n  glEnable(GL_DEPTH_TEST);\n}\n\nstatic void draw_keybinds_menu_3d(void) {\n  int w = GetScreenWidth();\n  int h = GetScreenHeight();\n  if (w <= 0 || h <= 0)\n    return;\n\n  glDisable(GL_DEPTH_TEST);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"init_3d_renderer","file":"game.c","line_start":9784,"line_end":9934,"snippet":"  ui_draw_text(40, 40, \"Keybinds (TAB toggles primary/secondary)\", RAYWHITE);\n\n  float y = 90.0f;\n  for (int i = 0; i < BIND_COUNT; i++) {\n    char line[128];\n    snprintf(line, sizeof(line), \"%d) %s: %s / %s\", i + 1, g_keybinds[i].name,\n             key_name(g_keybinds[i].primary),\n             key_name(g_keybinds[i].secondary));\n    ui_draw_text(40, y, line, (i == g_rebind_index) ? ORANGE : RAYWHITE);\n    y += 28.0f;\n  }\n\n  if (g_rebind_index >= 0) {\n    ui_draw_text(40, y + 20,\n                 g_rebind_index >= 0 ? \"Press a key (ESC cancels)\" : \"\",\n                 RAYWHITE);\n    KeyboardKey k = poll_any_key_pressed();\n    if (k == KEY_ESCAPE) {\n      g_rebind_index = -1;\n    } else if (k != KEY_NULL && k != KEY_TAB) {\n      if (g_pause_page == 2) {\n        g_keybinds[g_rebind_index].secondary = k;\n      } else {\n        g_keybinds[g_rebind_index].primary = k;\n      }\n      g_rebind_index = -1;\n      save_keybinds();\n    }\n  } else {\n    if (IsKeyPressed(KEY_TAB)) {\n      g_pause_page = (g_pause_page == 1) ? 2 : 1;\n    }\n    if (IsKeyPressed(KEY_ESCAPE) || IsKeyPressed(KEY_BACKSPACE)) {\n      g_pause_page = 0;\n      g_rebind_index = -1;\n    }\n    for (int i = 0; i < BIND_COUNT && i < 8; i++) {\n      KeyboardKey k = (KeyboardKey)(KEY_ONE + i);\n      if (IsKeyPressed(k)) {\n        g_rebind_index = i;\n        break;\n      }\n    }\n  }\n\n  glEnable(GL_DEPTH_TEST);\n}\n\nstatic void draw_graphics_menu_3d(void) {\n  int w = GetScreenWidth();\n  int h = GetScreenHeight();\n  if (w <= 0 || h <= 0)\n    return;\n\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_CULL_FACE);\n  ui_draw_rect(0, 0, (float)w, (float)h, (Color){0, 0, 0, 160});\n  ui_draw_text(40, 40, \"Graphics\", RAYWHITE);\n  ui_draw_text(40, 68, \"F6 cycles Low/Medium/High\",\n               (Color){200, 200, 200, 200});\n\n  float y = 120.0f;\n  float bx = 60.0f;\n  float bw = 180.0f;\n  float bh = 46.0f;\n  int changed = 0;\n\n  ui_draw_text((int)bx, (int)(y - 26.0f), \"Quality Presets\", RAYWHITE);\n  if (ui_button_gl((Rectangle){bx, y, bw, bh}, \"Low\", 20)) {\n    apply_graphics_quality(GFX_LOW);\n    changed = 1;\n  }\n  if (ui_button_gl((Rectangle){bx + bw + 16, y, bw, bh}, \"Medium\", 20)) {\n    apply_graphics_quality(GFX_MED);\n    changed = 1;\n  }\n  if (ui_button_gl((Rectangle){bx + (bw + 16) * 2, y, bw, bh}, \"High\", 20)) {\n    apply_graphics_quality(GFX_HIGH);\n    changed = 1;\n  }\n\n  y += 80.0f;\n  ui_draw_text((int)bx, (int)(y - 26.0f), \"Toggles\", RAYWHITE);\n  if (ui_button_gl((Rectangle){bx, y, bw + 40, bh},\n                   g_enable_grass ? \"Grass: ON\" : \"Grass: OFF\", 20)) {\n    g_enable_grass = !g_enable_grass;\n    g_gfx_quality = GFX_CUSTOM;\n    apply_graphics_custom_runtime();\n    changed = 1;\n  }\n  if (ui_button_gl((Rectangle){bx + bw + 60, y, bw + 60, bh},\n                   g_enable_ground_tex ? \"Ground Tex: ON\" : \"Ground Tex: OFF\",\n                   20)) {\n    g_enable_ground_tex = !g_enable_ground_tex;\n    g_gfx_quality = GFX_CUSTOM;\n    changed = 1;\n  }\n\n  y += 80.0f;\n  ui_draw_text((int)bx, (int)(y - 26.0f), \"Texture Scale\", RAYWHITE);\n  if (ui_button_gl((Rectangle){bx, y, 44, bh}, \"-\", 24)) {\n    g_ground_tex_scale = fmaxf(0.02f, g_ground_tex_scale - 0.01f);\n    g_gfx_quality = GFX_CUSTOM;\n    changed = 1;\n  }\n  ui_draw_text_size(bx + 64, y + 10, TextFormat(\"%.3f\", g_ground_tex_scale), 20,\n                    RAYWHITE);\n  if (ui_button_gl((Rectangle){bx + 160, y, 44, bh}, \"+\", 24)) {\n    g_ground_tex_scale = fminf(0.20f, g_ground_tex_scale + 0.01f);\n    g_gfx_quality = GFX_CUSTOM;\n    changed = 1;\n  }\n\n  y += 90.0f;\n  if (ui_button_gl((Rectangle){bx, y, 180, 46}, \"Back\", 20)) {\n    g_pause_page = 0;\n    changed = 1;\n  }\n  if (IsKeyPressed(KEY_ESCAPE) || IsKeyPressed(KEY_BACKSPACE)) {\n    g_pause_page = 0;\n    changed = 1;\n  }\n\n  if (changed) {\n    save_graphics_config();\n  }\n  glEnable(GL_CULL_FACE);\n  glEnable(GL_DEPTH_TEST);\n}\n\nstatic void init_3d_renderer(void) {\n  if (g_3d_ready)\n    return;\n\n  const char *vs = \"#version 330 core\\n\"\n                   \"layout(location = 0) in vec3 aPos;\\n\"\n                   \"layout(location = 1) in vec3 aNormal;\\n\"\n                   \"uniform mat4 uMVP;\\n\"\n                   \"uniform mat4 uModel;\\n\"\n                   \"out vec3 FragPos;\\n\"\n                   \"out vec3 Normal;\\n\"\n                   \"void main() {\\n\"\n                   \"  FragPos = vec3(uModel * vec4(aPos, 1.0));\\n\"\n                   \"  Normal = mat3(transpose(inverse(uModel))) * aNormal;\\n\"\n                   \"  gl_Position = uMVP * vec4(aPos, 1.0);\\n\"\n                   \"}\\n\";\n\n  const char *fs = \"#version 330 core\\n\"\n                   \"in vec3 FragPos;\\n\"\n                   \"in vec3 Normal;\\n\"\n                   \"uniform vec3 uColor;\\n\""},
  {"kind":"fn_def","vis":"PRIVATE","name":"color_to_vec3","file":"game.c","line_start":9970,"line_end":9972,"snippet":"      -0.5f,\n      -0.5f,\n      0.5f,"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"vec3","file":"game.c","line_start":9971,"line_end":9971,"snippet":"      -0.5f,"},
  {"kind":"fn_def","vis":"PRIVATE","name":"render_player_3d","file":"game.c","line_start":9974,"line_end":9997,"snippet":"      0,\n      1,\n      0.5f,\n      -0.5f,\n      0.5f,\n      0,\n      0,\n      1,\n      0.5f,\n      0.5f,\n      0.5f,\n      0,\n      0,\n      1,\n      -0.5f,\n      0.5f,\n      0.5f,\n      0,\n      0,\n      1,\n      // Back face\n      -0.5f,\n      -0.5f,\n      -0.5f,"},
  {"kind":"fn_def","vis":"PRIVATE","name":"render_mobs_3d","file":"game.c","line_start":9999,"line_end":10081,"snippet":"      0,\n      -1,\n      0.5f,\n      -0.5f,\n      -0.5f,\n      0,\n      0,\n      -1,\n      0.5f,\n      0.5f,\n      -0.5f,\n      0,\n      0,\n      -1,\n      -0.5f,\n      0.5f,\n      -0.5f,\n      0,\n      0,\n      -1,\n  };\n  unsigned int cube_idx[] = {\n      0, 1, 2, 0, 2, 3, // Front\n      4, 6, 5, 4, 7, 6, // Back\n      0, 4, 5, 0, 5, 1, // Bottom\n      2, 6, 7, 2, 7, 3, // Top\n      0, 3, 7, 0, 7, 4, // Left\n      1, 5, 6, 1, 6, 2, // Right\n  };\n  mesh_init(&g_mesh_cube, cube_verts, 8, cube_idx, 36);\n\n  // Load player model\n  g_mesh_player_loaded = load_glb_mesh(ASSET_PLAYER_GLB, &g_mesh_player);\n\n  // Load mob models\n  g_mesh_mob_loaded[MOB_PIG] =\n      load_glb_mesh(ASSET_PIG_GLB, &g_mesh_mobs[MOB_PIG]);\n  g_mesh_mob_loaded[MOB_SHEEP] =\n      load_glb_mesh(ASSET_SHEEP_GLB, &g_mesh_mobs[MOB_SHEEP]);\n  g_mesh_mob_loaded[MOB_SKELETON] =\n      load_glb_mesh(ASSET_SKELETON_GLB, &g_mesh_mobs[MOB_SKELETON]);\n  g_mesh_mob_loaded[MOB_ZOMBIE] =\n      load_glb_mesh(ASSET_ZOMBIE_GLB, &g_mesh_mobs[MOB_ZOMBIE]);\n\n  // Load resource models\n  g_mesh_resource_loaded[RES_TREE] =\n      load_glb_mesh(ASSET_TREE_GLB, &g_mesh_resources[RES_TREE]);\n  g_mesh_resource_loaded[RES_ROCK] =\n      load_glb_mesh(ASSET_ROCK_GLB, &g_mesh_resources[RES_ROCK]);\n  g_mesh_resource_loaded[RES_GOLD] =\n      load_glb_mesh(ASSET_GOLD_GLB, &g_mesh_resources[RES_GOLD]);\n  g_mesh_resource_loaded[RES_FOOD] =\n      load_glb_mesh(ASSET_FOOD_GLB, &g_mesh_resources[RES_FOOD]);\n\n  // Load base model\n  g_mesh_base_loaded = load_glb_mesh(ASSET_BASE_GLB, &g_mesh_base);\n\n  // Load terrain tile\n  g_mesh_ground_tile_loaded =\n      load_glb_mesh(ASSET_TERRAIN_GLB, &g_mesh_ground_tile);\n\n  // Build fallback sphere for any failed loads\n  build_sphere_mesh(8, 8);\n\n  g_3d_ready = 1;\n}\n\nstatic void render_mesh(const GameMesh *m, Mat4 model, Mat4 view_proj,\n                        Vec3 color) {\n  Mat4 mvp = mat4_mul(view_proj, model);\n  glUseProgram(g_shader);\n  glUniformMatrix4fv(g_u_mvp, 1, GL_FALSE, mvp.m);\n  glUniformMatrix4fv(g_u_model, 1, GL_FALSE, model.m);\n  glUniform3f(g_u_color, color.x, color.y, color.z);\n  if (g_u_use_tex >= 0)\n    glUniform1i(g_u_use_tex, 0);\n  glBindVertexArray(m->vao);\n  glDrawElements(GL_TRIANGLES, m->index_count, GL_UNSIGNED_INT, 0);\n  glBindVertexArray(0);\n  g_prof_draw_calls++;\n}\n\nstatic void render_mesh_textured(const GameMesh *m, Mat4 model, Mat4 view_proj,"},
  {"kind":"fn_def","vis":"PRIVATE","name":"render_agents_3d","file":"game.c","line_start":10083,"line_end":10153,"snippet":"  Mat4 mvp = mat4_mul(view_proj, model);\n  glUseProgram(g_shader);\n  glUniformMatrix4fv(g_u_mvp, 1, GL_FALSE, mvp.m);\n  glUniformMatrix4fv(g_u_model, 1, GL_FALSE, model.m);\n  glUniform3f(g_u_color, color.x, color.y, color.z);\n  if (g_u_use_tex >= 0)\n    glUniform1i(g_u_use_tex, 1);\n  glUniform1f(g_u_tex_scale, tex_scale);\n  glActiveTexture(GL_TEXTURE0);\n  glBindTexture(GL_TEXTURE_2D, tex);\n  glUniform1i(g_u_tex, 0);\n  glBindVertexArray(m->vao);\n  glDrawElements(GL_TRIANGLES, m->index_count, GL_UNSIGNED_INT, 0);\n  glBindVertexArray(0);\n  g_prof_draw_calls++;\n}\n\nstatic Vec3 color_to_vec3(Color c) {\n  return vec3(c.r / 255.0f, c.g / 255.0f, c.b / 255.0f);\n}\n\nstatic void render_player_3d(Vec3 player_pos, Mat4 view_proj) {\n  if (g_mesh_player_loaded) {\n    Mat4 model = mat4_mul(\n        mat4_mul(mat4_translate(vec3(player_pos.x, player_pos.y, player_pos.z)),\n                 mat4_rotate_y(g_player_yaw)),\n        mat4_scale(vec3(0.9f, 0.9f, 0.9f)));\n    render_mesh(&g_mesh_player, model, view_proj, vec3(0.85f, 0.75f, 0.65f));\n    return;\n  }\n\n  Mat4 body =\n      mat4_mul(mat4_mul(mat4_translate(vec3(player_pos.x, player_pos.y + 1.0f,\n                                            player_pos.z)),\n                        mat4_rotate_y(g_player_yaw)),\n               mat4_scale(vec3(0.6f, 1.5f, 0.6f)));\n  render_mesh(&g_mesh_cylinder, body, view_proj, vec3(0.75f, 0.55f, 0.45f));\n\n  Mat4 head =\n      mat4_mul(mat4_mul(mat4_translate(vec3(player_pos.x, player_pos.y + 2.4f,\n                                            player_pos.z)),\n                        mat4_rotate_y(g_player_yaw)),\n               mat4_scale(vec3(0.6f, 0.6f, 0.6f)));\n  render_mesh(&g_mesh_sphere, head, view_proj, vec3(0.85f, 0.75f, 0.65f));\n}\n\nstatic void render_mobs_3d(Vec3 player_pos, Mat4 view_proj) {\n  int cx = (int)(player.position.x / CHUNK_SIZE);\n  int cy = (int)(player.position.y / CHUNK_SIZE);\n  int drawn = 0;\n  int max_draw = 50;\n  float max_dist = 30.0f;\n  float max_dist2 = max_dist * max_dist;\n\n  for (int dy = -2; dy <= 2; dy++) {\n    for (int dx = -2; dx <= 2; dx++) {\n      if (drawn >= max_draw)\n        break;\n      Chunk *c = get_chunk(cx + dx, cy + dy);\n      if (!c)\n        continue;\n      pthread_rwlock_rdlock(&c->lock);\n      for (int i = 0; i < MAX_MOBS && drawn < max_draw; i++) {\n        Mob *m = &c->mobs[i];\n        if (m->health <= 0)\n          continue;\n        float mpx = (cx + dx) * CHUNK_SIZE + m->position.x;\n        float mpz = (cy + dy) * CHUNK_SIZE + m->position.y;\n        float yaw = 0.0f;\n        float vlen = sqrtf(m->vel.x * m->vel.x + m->vel.y * m->vel.y);\n        if (vlen > 1e-3f) {"},
  {"kind":"fn_def","vis":"PRIVATE","name":"render_bases_3d","file":"game.c","line_start":10155,"line_end":10177,"snippet":"        }\n\n        float s = mob_radius_world(m->type) * 1.6f;\n        float ground_y = g_use_perlin_ground ? terrain_height(mpx, mpz) : 0.0f;\n        float mpy = ground_y + s * 0.35f;\n        Vec3 mp = vec3(mpx, mpy, mpz);\n        float dxp = mp.x - player_pos.x;\n        float dzp = mp.z - player_pos.z;\n        if (dxp * dxp + dzp * dzp > max_dist2)\n          continue;\n        Mat4 model = mat4_mul(mat4_mul(mat4_translate(vec3(mp.x, mp.y, mp.z)),\n                                       mat4_rotate_y(yaw)),\n                              mat4_scale(vec3(s, s, s)));\n        Vec3 tint = color_to_vec3(mob_colors[m->type]);\n\n        if (m->type >= 0 && m->type < MOB_COUNT && g_mesh_mob_loaded[m->type]) {\n          render_mesh(&g_mesh_mobs[m->type], model, view_proj, tint);\n        } else {\n          Mat4 body = mat4_mul(model, mat4_scale(vec3(0.7f, 0.7f, 0.7f)));\n          render_mesh(&g_mesh_sphere, body, view_proj, tint);\n        }\n\n        // Draw health bar above mob"},
  {"kind":"fn_def","vis":"PRIVATE","name":"render_grass_3d","file":"game.c","line_start":10179,"line_end":10246,"snippet":"          float hp_percent = (float)m->health / 100.0f;\n          float bar_width = 1.2f;\n          float bar_height = 0.15f;\n          float bar_y = mp.y + s + 0.5f; // Above mob\n\n          Vec3 bar_pos = vec3(mp.x, bar_y, mp.z);\n          Mat4 bar_model =\n              mat4_mul(mat4_translate(bar_pos),\n                       mat4_scale(vec3(bar_width, bar_height, 0.01f)));\n\n          // Background\n          render_mesh(&g_mesh_cube, bar_model, view_proj,\n                      vec3(0.2f, 0.2f, 0.2f));\n\n          // Health fill\n          float health_width = bar_width * hp_percent;\n          Mat4 health_model = mat4_mul(\n              mat4_translate(\n                  vec3(mp.x - bar_width / 2 + health_width / 2, bar_y, mp.z)),\n              mat4_scale(vec3(health_width, bar_height, 0.01f)));\n          Vec3 health_color_vec3 =\n              hp_percent > 0.5f\n                  ? vec3(80.0f / 255.0f, 220.0f / 255.0f, 80.0f / 255.0f)\n                  : vec3(220.0f / 255.0f, 80.0f / 255.0f, 80.0f / 255.0f);\n          render_mesh(&g_mesh_cube, health_model, view_proj, health_color_vec3);\n        }\n\n        drawn++;\n      }\n      pthread_rwlock_unlock(&c->lock);\n    }\n  }\n}\n\nstatic void render_agents_3d(Vec3 player_pos, Mat4 view_proj) {\n  int drawn = 0;\n  int max_draw = 60;\n  float max_dist = 30.0f;\n  float max_dist2 = max_dist * max_dist;\n\n  for (int i = 0; i < MAX_AGENTS && drawn < max_draw; i++) {\n    Agent *a = &agents[i];\n    if (!a->alive)\n      continue;\n    float ax = a->position.x;\n    float az = a->position.y;\n    float ay = g_use_perlin_ground ? terrain_height(ax, az) : 0.0f;\n    Vec3 ap = vec3(ax, ay, az);\n    float dxp = ap.x - player_pos.x;\n    float dzp = ap.z - player_pos.z;\n    if (dxp * dxp + dzp * dzp > max_dist2)\n      continue;\n\n    float yaw = 0.0f;\n    float flen = sqrtf(a->facing.x * a->facing.x + a->facing.y * a->facing.y);\n    if (flen > 1e-3f) {\n      yaw = atan2f(a->facing.x, -a->facing.y);\n    }\n\n    Color tc = tribes[a->agent_id / AGENT_PER_TRIBE].color;\n    Vec3 tint = color_to_vec3(tc);\n    float s = 0.85f;\n    Mat4 model = mat4_mul(mat4_mul(mat4_translate(ap), mat4_rotate_y(yaw)),\n                          mat4_scale(vec3(s, s, s)));\n    if (g_mesh_player_loaded) {\n      render_mesh(&g_mesh_player, model, view_proj, tint);\n    } else {\n      Mat4 body = mat4_mul(mat4_translate(vec3(ap.x, ap.y + 1.0f, ap.z)),"},
  {"kind":"fn_proto","vis":"PRIVATE","name":"render_resources_3d","file":"game.c","line_start":10249,"line_end":10249,"snippet":"      Mat4 head = mat4_mul(mat4_translate(vec3(ap.x, ap.y + 2.2f, ap.z)),"},
  {"kind":"fn_def","vis":"PRIVATE","name":"render_scene_3d","file":"game.c","line_start":10251,"line_end":10409,"snippet":"      render_mesh(&g_mesh_sphere, head, view_proj, tint);\n    }\n\n    // Draw action indicator above agent\n    if (a->last_action >= 0 && a->last_action < ACTION_COUNT) {\n      const char *action_names[] = {\n          \"\",    \"\",     \"\",     \"\",   \"ATTACK\", \"HARVEST\", \"CRAFT\", \"AXE\",\n          \"PICK\", \"SWORD\", \"ARMOR\", \"BOW\", \"ARROWS\", \"EAT\",     \"JUMP\"};\n      const char *action_name =\n          (a->last_action < sizeof(action_names) / sizeof(action_names[0]))\n              ? action_names[a->last_action]\n              : \"?\";\n\n      // Animated floating indicator above agent\n      float time = GetTime();\n      float bounce = sinf(time * 8.0f) * 0.1f; // Bounce animation\n      float text_y = ap.y + s + 1.0f + bounce;\n      Vec3 text_pos = vec3(ap.x, text_y, ap.z);\n      Mat4 text_model = mat4_mul(mat4_translate(text_pos),\n                                 mat4_scale(vec3(0.3f, 0.3f, 0.01f)));\n\n      // Pulsing color effect\n      float pulse = (sinf(time * 6.0f) + 1.0f) * 0.5f;\n      Color action_color = (Color){255, (unsigned char)(255 * pulse),\n                                   (unsigned char)(100 * pulse), 255};\n      Vec3 action_tint = vec3(action_color.r / 255.0f, action_color.g / 255.0f,\n                              action_color.b / 255.0f);\n      render_mesh(&g_mesh_cube, text_model, view_proj, action_tint);\n    }\n\n    drawn++;\n  }\n}\n\nstatic void render_bases_3d(Mat4 view_proj) {\n  if (!g_mesh_base_loaded)\n    return;\n  glDisable(GL_CULL_FACE); // render interior faces so base isn't see-through\n  Vector2 world_center = (Vector2){WORLD_SIZE * 0.5f, WORLD_SIZE * 0.5f};\n  for (int t = 0; t < TRIBE_COUNT; t++) {\n    Vector2 bp = tribes[t].base.position;\n    float h = 0.0f;\n    if (g_use_perlin_ground) {\n      h = g_tribes_ready ? g_base_flat_height[t] : terrain_height(bp.x, bp.y);\n    }\n    Vector2 to_center = (Vector2){world_center.x - bp.x, world_center.y - bp.y};\n    float yaw = atan2f(to_center.x, -to_center.y);\n    Vec3 tint = color_to_vec3(tribes[t].color);\n    float s = tribes[t].base.radius * 0.35f * 1.25f;\n    float base_drop = -0.85f * s; // align dome base to ground\n    Vec3 pos = vec3(bp.x, h + base_drop, bp.y);\n    Mat4 model = mat4_mul(mat4_mul(mat4_translate(pos), mat4_rotate_y(yaw)),\n                          mat4_scale(vec3(s, s, s)));\n    render_mesh(&g_mesh_base, model, view_proj, tint);\n  }\n  glEnable(GL_CULL_FACE);\n}\n\nstatic void render_grass_3d(Vec3 player_pos, Mat4 view_proj, float tnow) {\n  (void)tnow;\n  int pcx = (int)(player_pos.x / CHUNK_SIZE);\n  int pcz = (int)(player_pos.z / CHUNK_SIZE);\n\n  for (int cz = pcz - GRASS_CHUNK_RADIUS; cz <= pcz + GRASS_CHUNK_RADIUS;\n       cz++) {\n    if (cz < 0 || cz >= WORLD_SIZE)\n      continue;\n    for (int cx = pcx - GRASS_CHUNK_RADIUS; cx <= pcx + GRASS_CHUNK_RADIUS;\n         cx++) {\n      if (cx < 0 || cx >= WORLD_SIZE)\n        continue;\n\n      Chunk *c = get_chunk(cx, cz);\n      if (!c)\n        continue;\n      pthread_rwlock_rdlock(&c->lock);\n      if (!c->grass_ready && !c->grass_building) {\n        c->grass_building = 1;\n        pthread_rwlock_unlock(&c->lock);\n        grass_enqueue_job(cx, cz);\n        continue;\n      }\n\n      GrassBlade *blades = c->grass;\n      int count = c->grass_count;\n      pthread_rwlock_unlock(&c->lock);\n      if (!blades || count <= 0)\n        continue;\n\n      int dx = cx - pcx;\n      int dz = cz - pcz;\n      int dist = abs(dx);\n      if (abs(dz) > dist)\n        dist = abs(dz);\n      int stride = g_grass_stride_far;\n      if (dist <= 1)\n        stride = g_grass_stride_near;\n      else if (dist == 2)\n        stride = g_grass_stride_mid;\n      if (stride < 1)\n        stride = 1;\n\n      int max_draw = g_grass_max_chunk_far;\n      if (dist <= 1)\n        max_draw = g_grass_max_chunk_near;\n      else if (dist == 2)\n        max_draw = g_grass_max_chunk_mid;\n\n      int drawn = 0;\n      for (int i = 0; i < count && drawn < max_draw; i += stride) {\n        float px = blades[i].x;\n        float py = blades[i].y;\n        float pz = blades[i].z;\n        float yaw = blades[i].yaw;\n        float scale = blades[i].scale;\n\n        Mat4 model = mat4_mul(\n            mat4_mul(mat4_translate(vec3(px, py, pz)), mat4_rotate_y(yaw)),\n            mat4_mul(mat4_rotate_x(0.0f),\n                     mat4_scale(vec3(scale, scale, scale))));\n        render_mesh(&g_mesh_grass, model, view_proj, vec3(0.55f, 0.86f, 0.55f));\n        drawn++;\n      }\n    }\n  }\n}\n\n// Render resources with optimized culling and proper locking\nstatic void render_resources_3d(Vec3 player_pos, Mat4 view_proj);\n\nstatic void render_scene_3d(void) {\n  init_3d_renderer();\n\n  // Apply graphics quality settings on first 3D render\n  static int graphics_applied = 0;\n  if (!graphics_applied) {\n    if (g_gfx_quality == GFX_LOW || g_gfx_quality == GFX_MED ||\n        g_gfx_quality == GFX_HIGH) {\n      apply_graphics_quality(g_gfx_quality);\n    } else {\n      g_gfx_quality = GFX_CUSTOM;\n      apply_graphics_custom_runtime();\n    }\n    graphics_applied = 1;\n  }\n\n  int w = GetScreenWidth();\n  int h = GetScreenHeight();\n  if (w <= 0 || h <= 0)\n    return;\n\n  glViewport(0, 0, w, h);\n  glClearColor(0.1f, 0.2f, 0.3f, 1.0f);\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n  float aspect = (float)w / (float)h;\n  Mat4 proj = mat4_perspective(60.0f, aspect, 0.1f, 400.0f);\n  float player_h = g_use_perlin_ground\n                       ? terrain_height(player.position.x, player.position.y)\n                       : 0.0f;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"render_resources_3d","file":"game.c","line_start":10412,"line_end":10546,"snippet":"  Vec3 forward =\n      vec3(cosf(g_player_pitch) * sinf(g_player_yaw), sinf(g_player_pitch),\n           cosf(g_player_pitch) * -cosf(g_player_yaw));\n  Vec3 eye = vec3_add(\n      player_pos,\n      vec3(0.0f, (g_camera_mode == CAM_FIRST_PERSON) ? 1.7f : 0.0f, 0.0f));\n  if (g_camera_mode == CAM_THIRD_PERSON) {\n    float dist = 8.0f;\n    float height = 2.5f;\n    Vec3 back = vec3_scale(forward, -dist);\n    eye = vec3_add(player_pos, back);\n    eye.y += height;\n  }\n  Vec3 target = vec3_add(eye, forward);\n  Mat4 view = mat4_lookat(eye, target, vec3(0, 1, 0));\n  Mat4 view_proj = mat4_mul(proj, view);\n\n  glUseProgram(g_shader);\n  // Set up dynamic sun/lighting based on day/night cycle\n  float day_progress = time_of_day; // 0.0 = dawn, 0.5 = noon, 1.0 = next dawn\n  float sun_angle = day_progress * 2.0f * PI; // Full rotation per day\n\n  // Enhanced sun position: higher arc for better lighting\n  float sun_height = sinf(sun_angle) * 0.9f + 0.2f; // Higher peaks\n  Vec3 sun_dir = vec3(cosf(sun_angle), sun_height, sinf(sun_angle * 0.6f));\n\n  // Brighter ambient light during day\n  float ambient_base = is_night_cached ? 0.15f : 0.4f; // Brighter day\n  float sun_intensity = is_night_cached ? 0.2f : 0.8f; // Stronger sun\n\n  // At night, use moonlight (dimmer but with blue tint)\n  if (is_night_cached) {\n    sun_dir = vec3_scale(sun_dir, 0.4f); // Gentler night light\n    sun_dir.x += 0.05f;                  // Slight blue tint for moon\n    sun_dir.y += 0.02f;\n  } else {\n    // During day, add more dynamic intensity based on sun position\n    sun_intensity =\n        sun_intensity * (0.7f + 0.3f * sun_height); // Varies with sun height\n  }\n\n  // Combine ambient and directional light\n  Vec3 final_light = vec3_add(vec3(ambient_base, ambient_base, ambient_base),\n                              vec3_scale(sun_dir, sun_intensity));\n\n  glUniform3f(g_u_light, final_light.x, final_light.y, final_light.z);\n\n  // Render ground using optimized terrain tiles with LOD\n  if (g_mesh_ground_tile_loaded) {\n    // Render far fewer terrain tiles for performance\n    float tile_size = 40.0f;            // Larger tiles = fewer draw calls\n    int tile_radius = 3;                // Only render 3x3 grid around player\n    float base_render_distance = 50.0f; // Base render distance for terrain too\n\n    for (int x = -tile_radius; x <= tile_radius; x++) {\n      for (int y = -tile_radius; y <= tile_radius; y++) {\n        // Skip far tiles for LOD\n        float dist = sqrtf((float)(x * x + y * y)) * tile_size;\n        if (dist > base_render_distance)\n          continue;\n\n        Vec3 pos = vec3(x * tile_size, 0.0f, y * tile_size);\n\n        // LOD scaling - use larger tiles for distance\n        float lod_scale = 1.0f;\n        if (dist > 30.0f)\n          lod_scale = 1.5f;\n        else if (dist > 20.0f)\n          lod_scale = 1.2f;\n\n        Mat4 ground =\n            mat4_mul(mat4_translate(pos),\n                     mat4_scale(vec3(tile_size * lod_scale * 0.5f, 1.0f,\n                                     tile_size * lod_scale * 0.5f)));\n        render_mesh(&g_mesh_ground_tile, ground, view_proj,\n                    vec3(0.35f, 0.75f, 0.35f));\n      }\n    }\n  } else {\n    // Fallback to simple ground plane\n    Mat4 ground = mat4_mul(mat4_translate(vec3(0.0f, 0.0f, 0.0f)),\n                           mat4_scale(vec3(100.0f, 0.1f, 100.0f)));\n    render_mesh(&g_mesh_cube, ground, view_proj, vec3(0.35f, 0.75f, 0.35f));\n  }\n\n  // Render player\n  if (g_mesh_player_loaded) {\n    // Get terrain height at player position\n    float terrain_h = 0.0f;\n    if (g_use_perlin_ground) {\n      terrain_h = terrain_height(player_pos.x, player_pos.z);\n    }\n\n    Vec3 player_3d = vec3(player_pos.x, terrain_h, player_pos.z);\n    Mat4 player_model =\n        mat4_mul(mat4_translate(player_3d), mat4_scale(vec3(1.0f, 1.0f, 1.0f)));\n    render_mesh(&g_mesh_player, player_model, view_proj,\n                vec3(0.8f, 0.4f, 0.2f));\n  } else {\n    // Fallback to cube\n    Vec3 player_3d = vec3(player_pos.x, 0.0f, player_pos.z);\n    Mat4 player_model =\n        mat4_mul(mat4_translate(player_3d), mat4_scale(vec3(0.5f, 1.0f, 0.5f)));\n    render_mesh(&g_mesh_cube, player_model, view_proj, vec3(0.8f, 0.4f, 0.2f));\n  }\n\n  // Render grass with distance-based density optimization\n  if (g_enable_grass) {\n    float grass_density = 1.0f;\n    render_grass_3d(player_pos, view_proj, 1.0f);\n    float player_dist_sq =\n        player_pos.x * player_pos.x + player_pos.z * player_pos.z;\n    float player_dist = sqrtf(player_dist_sq);\n\n    // Reduce grass density based on distance for performance\n    if (player_dist > 20.0f) {\n      grass_density = 0.5f; // Half density at medium distance\n    }\n    if (player_dist > 30.0f) {\n      grass_density = 0.25f; // Quarter density at far distance\n    }\n\n    render_grass_3d(player_pos, view_proj, grass_density);\n  }\n\n  // Render resources with optimized culling\n  render_resources_3d(player_pos, view_proj);\n}\n\n// Render resources with optimized culling and proper locking\nstatic void render_resources_3d(Vec3 player_pos, Mat4 view_proj) {\n  float base_render_distance = 50.0f; // Base render distance\n  float render_distance = base_render_distance;\n\n  // Dynamic render distance based on FPS (with safety check)"},
  {"kind":"fn_def","vis":"PRIVATE","name":"start_ai_vs_ai_training","file":"game.c","line_start":10550,"line_end":10582,"snippet":"  } else if (g_current_fps > 0.0f && g_current_fps < 30.0f) {\n    render_distance =\n        base_render_distance * 0.5f; // Aggressive reduction for low FPS\n  }\n\n  // Calculate player chunk position for optimized rendering\n  int player_cx = (int)(player_pos.x / CHUNK_SIZE);\n  int player_cy = (int)(player_pos.z / CHUNK_SIZE);\n  int chunk_render_radius = (int)(render_distance / CHUNK_SIZE) + 1;\n\n  int chunks_rendered = 0;\n  int resources_rendered = 0;\n\n  for (int dx = -chunk_render_radius; dx <= chunk_render_radius; dx++) {\n    for (int dy = -chunk_render_radius; dy <= chunk_render_radius; dy++) {\n      int cx = player_cx + dx;\n      int cy = player_cy + dy;\n\n      // Skip if chunk is outside world bounds\n      if (cx < 0 || cx >= WORLD_SIZE || cy < 0 || cy >= WORLD_SIZE)\n        continue;\n\n      // Quick distance check for chunk\n      float chunk_dist_sq =\n          (float)(dx * dx + dy * dy) * CHUNK_SIZE * CHUNK_SIZE;\n      if (chunk_dist_sq > render_distance * render_distance)\n        continue;\n\n      Chunk *c = get_chunk(cx, cy);\n      if (!c)\n        continue;\n\n      chunks_rendered++;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"stop_ai_vs_ai_training","file":"game.c","line_start":10584,"line_end":10592,"snippet":"\n      for (int i = 0; i < MAX_RESOURCES; i++) {\n        Resource *r = &c->resources[i];\n        if (r->health <= 0)\n          continue;\n\n        // Convert resource position to world coordinates\n        float world_x = cx * CHUNK_SIZE + r->position.x;\n        float world_z = cy * CHUNK_SIZE + r->position.y;"},
  {"kind":"fn_def","vis":"PRIVATE","name":"save_ai_models","file":"game.c","line_start":10594,"line_end":10607,"snippet":"        // Distance culling\n        float dx_res = world_x - player_pos.x;\n        float dz_res = world_z - player_pos.z;\n        float dist_sq = dx_res * dx_res + dz_res * dz_res;\n        if (dist_sq > render_distance * render_distance)\n          continue;\n\n        // Use simple terrain height calculation\n        float terrain_h = 0.0f;\n        if (g_use_perlin_ground) {\n          terrain_h = terrain_height(world_x, world_z);\n        }\n\n        Vec3 pos = vec3(world_x, terrain_h, world_z);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"update_ai_vs_ai_training","file":"game.c","line_start":10609,"line_end":10651,"snippet":"\n        // Scale models appropriately\n        if (r->type == RES_TREE)\n          scale = 2.0f;\n        else if (r->type == RES_ROCK)\n          scale = 0.5f;\n        else if (r->type == RES_GOLD)\n          scale = 0.3f;\n        else if (r->type == RES_FOOD)\n          scale = 0.4f;\n\n        Mat4 model = mat4_mul(mat4_translate(pos),\n                              mat4_scale(vec3(scale, scale, scale)));\n\n        if (r->type >= 0 && r->type < RES_COUNT &&\n            g_mesh_resource_loaded[r->type]) {\n          Vec3 tint = vec3(1.0f, 1.0f, 1.0f);\n          if (r->type == RES_TREE)\n            tint = vec3(0.2f, 0.8f, 0.2f);\n          else if (r->type == RES_ROCK)\n            tint = vec3(0.5f, 0.5f, 0.5f);\n          else if (r->type == RES_GOLD)\n            tint = vec3(1.0f, 0.8f, 0.0f);\n          else if (r->type == RES_FOOD)\n            tint = vec3(0.8f, 0.4f, 0.2f);\n\n          render_mesh(&g_mesh_resources[r->type], model, view_proj, tint);\n          resources_rendered++;\n        }\n      }\n      pthread_rwlock_unlock(&c->lock);\n    }\n  }\n\n  // Render damage numbers\n  for (int i = 0; i < MAX_DAMAGE_NUMBERS; i++) {\n    if (damage_numbers[i].timer > 0.0f) {\n      float alpha = damage_numbers[i].timer / 3.0f;\n      if (alpha <= 0.0f) {\n        damage_numbers[i].timer = 0.0f;\n        continue;\n      }"},
  {"kind":"fn_def","vis":"PRIVATE","name":"toggle_spectator_mode","file":"game.c","line_start":10655,"line_end":10678,"snippet":"                                                     damage_numbers[i].pos.y)\n                                    : 0.0f) +\n                   2.0f,\n               damage_numbers[i].pos.y);\n      Mat4 dmg_model = mat4_mul(mat4_translate(dmg_pos),\n                                mat4_scale(vec3(0.3f, 0.3f, 0.01f)));\n      Color dmg_color = damage_numbers[i].color;\n      dmg_color.a = (unsigned char)(255 * alpha);\n\n      // Animated floating effect\n      float time = GetTime();\n      float bounce = sinf(time * 10.0f) * 0.05f; // Small bounce\n      float scale = 1.0f + bounce;               // Pulse effect\n\n      Mat4 animated_model =\n          mat4_mul(dmg_model, mat4_scale(vec3(scale, scale, 0.01f)));\n      Vec3 dmg_tint = vec3(dmg_color.r / 255.0f, dmg_color.g / 255.0f,\n                           dmg_color.b / 255.0f);\n      render_mesh(&g_mesh_cube, animated_model, view_proj, dmg_tint);\n    }\n  }\n}\n\n/* ======================="},
  {"kind":"fn_def","vis":"PRIVATE","name":"update_spectator_camera","file":"game.c","line_start":10680,"line_end":10697,"snippet":"======================= */\n\nvoid start_ai_vs_ai_training(void) {\n  g_ai_training_active = 1;\n  g_ai_episode_count = 0;\n  g_ai_step_count = 0;\n  g_ai_training_reward = 0.0f;\n\n  // Create AI agent with default config\n  AgentConfig config = {.use_world_model = 1,\n                        .use_self_play = 1,\n                        .curriculum_learning = 1,\n                        .num_training_threads = 4,\n                        .learning_rate = 0.001f,\n                        .batch_size = 32,\n                        .replay_buffer_size = 10000,\n                        .max_episode_length = 1000};\n  g_ai_agent = rl_agent_create(&config);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"update_spectator_controls","file":"game.c","line_start":10699,"line_end":10739,"snippet":"    printf(\"Failed to create RL agent!\\n\");\n    g_ai_training_active = 0;\n    return;\n    printf(\"Created RL agent with Dreamer world model and Soft Actor-Critic\\n\");\n  }\n\n  // Reset agent for new training session\n  rl_agent_reset(g_ai_agent);\n\n  printf(\"Starting AI vs AI training...\\n\");\n  printf(\"Agent will use Dreamer for world modeling and Soft Actor-Critic for \"\n         \"policy learning\\n\");\n\n  // Resume game and start training\n  g_state = STATE_PLAYING;\n}\n\nvoid stop_ai_vs_ai_training(void) {\n  g_ai_training_active = 0;\n  printf(\"Training stopped. Episodes: %d, Total Reward: %.2f\\n\",\n         g_ai_episode_count, g_ai_training_reward);\n\n  if (g_ai_agent) {\n    printf(\"Final agent performance metrics available\\n\");\n  }\n}\n\nvoid save_ai_models(void) {\n  if (!g_ai_agent) {\n    printf(\"No AI agent to save!\\n\");\n    return;\n  }\n\n  // Save trained models to disk\n  printf(\"Saving AI models (Dreamer world model + Soft Actor-Critic \"\n         \"policy)...\\n\");\n\n  // This would integrate with the RL_AGENT save functionality\n  // For now, just indicate that models would be saved\n  printf(\"Models saved to: ./ai_models/\\n\");\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"render_spectator_hud","file":"game.c","line_start":10741,"line_end":10774,"snippet":"void update_ai_vs_ai_training(float dt) {\n  if (!g_ai_training_active || !g_ai_agent)\n    return;\n\n  g_ai_step_count++;\n\n  // Create observation from current game state\n  // This would normally extract features from game world\n  GridObservation observation = {0}; // Simplified observation\n  int obs_size = 128;\n\n  // Select action using RL agent\n  PolicyOutput action = rl_agent_act(g_ai_agent, &observation);\n\n  // Execute action (simplified - in real implementation this would control\n  // agents)\n  float reward = 0.1f; // Simplified reward\n\n  // Get next observation\n  GridObservation next_obs = {0};\n\n  // Update agent with experience\n  rl_agent_update(g_ai_agent, reward, &next_obs, 0);\n\n  g_ai_training_reward += reward;\n\n  // Check episode completion\n  if (g_ai_step_count >= 1000) {\n    g_ai_episode_count++;\n    g_ai_step_count = 0;\n\n    // Reset agent for new episode\n    rl_agent_reset(g_ai_agent);"},
  {"kind":"fn_def","vis":"PRIVATE","name":"main","file":"game.c","line_start":10777,"line_end":11438,"snippet":"  }\n\n  // Stop after target episodes\n  if (g_ai_episode_count >= g_ai_training_episodes) {\n    stop_ai_vs_ai_training();\n  }\n}\n\n/* =======================\n   SPECTATOR MODE FUNCTIONS\n======================= */\n\nvoid toggle_spectator_mode(void) {\n  g_spectator_mode = !g_spectator_mode;\n\n  if (g_spectator_mode) {\n    printf(\"Spectator mode ENABLED - Free camera movement\\n\");\n    printf(\"Controls: WASD/Arrows=Move, Mouse=Look, Shift=Speed, Space=Up, \"\n           \"Ctrl=Down\\n\");\n\n    // Initialize spectator position to current player position\n    g_spectator_pos.x = player.position.x;\n    g_spectator_pos.y = player.position.y + 10.0f; // Start above player\n\n    // Unlock mouse for free look\n    SDL_ShowCursor();\n    g_mouse_locked = 0;\n  } else {\n    printf(\"Spectator mode DISABLED\\n\");\n    // Restore normal mouse state\n    if (g_state == STATE_PLAYING) {\n      SDL_HideCursor();\n      g_mouse_locked = 1;\n    }\n  }\n}\n\nvoid update_spectator_camera(float dt) {\n  if (!g_spectator_mode)\n    return;\n\n  // Update position based on velocity\n  g_spectator_pos.x += g_spectator_velocity.x * dt;\n  g_spectator_pos.y += g_spectator_velocity.y * dt;\n  g_spectator_pos.z += g_spectator_velocity.z * dt;\n\n  // Apply damping to velocity\n  g_spectator_velocity.x *= 0.85f;\n  g_spectator_velocity.y *= 0.85f;\n  g_spectator_velocity.z *= 0.85f;\n\n  // Update camera to follow spectator position\n  // This would update the main camera system\n  // For now, we'll integrate with existing camera system\n}\n\nvoid update_spectator_controls(void) {\n  if (!g_spectator_mode)\n    return;\n\n  float speed = SPECTATOR_SPEED;\n  if (IsKeyDown(KEY_LEFT_SHIFT))\n    speed *= 2.0f; // Turbo mode\n\n  // Movement controls\n  if (IsKeyDown(KEY_W) || IsKeyDown(KEY_UP)) {\n    g_spectator_velocity.x += speed * 0.016f; // Forward\n  }\n  if (IsKeyDown(KEY_S) || IsKeyDown(KEY_DOWN)) {\n    g_spectator_velocity.x -= speed * 0.016f; // Backward\n  }\n  if (IsKeyDown(KEY_A)) {\n    g_spectator_velocity.z -= speed * 0.016f; // Left\n  }\n  if (IsKeyDown(KEY_D)) {\n    g_spectator_velocity.z += speed * 0.016f; // Right\n  }\n  if (IsKeyDown(KEY_SPACE)) {\n    g_spectator_velocity.y += speed * 0.016f; // Up\n  }\n  if (IsKeyDown(KEY_LEFT_CONTROL) || IsKeyDown(KEY_RIGHT_CONTROL)) {\n    g_spectator_velocity.y -= speed * 0.016f; // Down\n  }\n\n  // Mouse look\n  if (g_mouse_locked) {\n    Vector2 mouse_delta = GetMouseDelta();\n    g_spectator_yaw += mouse_delta.x * SPECTATOR_MOUSE_SENSITIVITY;\n    g_spectator_pitch -= mouse_delta.y * SPECTATOR_MOUSE_SENSITIVITY;\n\n    // Clamp pitch to prevent camera flip\n    if (g_spectator_pitch > 89.0f)\n      g_spectator_pitch = 89.0f;\n    if (g_spectator_pitch < -89.0f)\n      g_spectator_pitch = -89.0f;\n  }\n}\n\nvoid render_spectator_hud(void) {\n  if (!g_spectator_mode)\n    return;\n\n  int w = GetScreenWidth();\n  int h = GetScreenHeight();\n\n  // Draw spectator mode indicator\n  const char *spectator_text = \"SPECTATOR MODE\";\n  int text_width = MeasureText(spectator_text, 20);\n  DrawRectangle(10, 10, text_width + 20, 40, (Color){0, 0, 0, 180});\n  DrawText(spectator_text, 20, 20, 20, YELLOW);\n\n  // Draw controls help\n  DrawText(\"WASD/Arrows: Move\", 20, 60, 16, RAYWHITE);\n  DrawText(\"Mouse: Look\", 20, 80, 16, RAYWHITE);\n  DrawText(\"Space: Up | Ctrl: Down\", 20, 100, 16, RAYWHITE);\n  DrawText(\"Shift: Turbo | ESC: Exit\", 20, 120, 16, RAYWHITE);\n\n  // Draw position info\n  char pos_info[128];\n  snprintf(pos_info, sizeof(pos_info), \"Pos: (%.1f, %.1f, %.1f)\",\n           g_spectator_pos.x, g_spectator_pos.y, g_spectator_pos.z);\n  DrawText(pos_info, 20, h - 60, 16, RAYWHITE);\n\n  // Draw training status if AI training is active\n  if (g_ai_training_active) {\n    char training_info[128];\n    snprintf(training_info, sizeof(training_info),\n             \"AI Training: Episode %d | Step %d\", g_ai_episode_count,\n             g_ai_step_count);\n    DrawText(training_info, 20, h - 40, 16, GREEN);\n  }\n}\n\n/* =======================\n   MAIN\n======================= */\nint main(int argc, char *argv[]) {\n\n  srand(time(NULL));\n\n  // Simple performance initialization\n  g_last_frame_time = 0.0f; // Will be set on first frame\n  g_current_fps = 60.0f;\n\n  if (g_use_3d) {\n    // OpenGL will be initialized by Raylib\n  }\n\n  // Initialize SDL\n  if (!SDL_Init(SDL_INIT_VIDEO)) {\n    printf(\"Failed to initialize SDL: %s\\n\", SDL_GetError());\n    return 1;\n  }\n  \n  // Create SDL window\n  int display_w = 1440;\n  int display_h = 900;\n  \n  printf(\"Creating SDL window: %d x %d\\n\", display_w, display_h);\n  \n  g_window = SDL_CreateWindow(\n    \"MUZE Tribal Simulation\",\n    display_w,\n    display_h,\n    SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE\n  );\n  \n  if (!g_window) {\n    printf(\"Failed to create SDL window: %s\\n\", SDL_GetError());\n    return 1;\n  }\n  \n  // Create OpenGL context\n  SDL_GLContext gl_context = SDL_GL_CreateContext(g_window);\n  if (!gl_context) {\n    printf(\"Failed to create OpenGL context: %s\\n\", SDL_GetError());\n    SDL_DestroyWindow(g_window);\n    return 1;\n  }\n  \n  // Set OpenGL attributes\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n  \n  // Set swap interval for vsync\n  SDL_GL_SetSwapInterval(1);\n  \n  // Make OpenGL context current\n  SDL_GL_MakeCurrent(g_window, gl_context);\n  \n  // Show and enable mouse cursor\n  SDL_ShowCursor();\n  SDL_SetWindowMouseGrab(g_window, false);\n  SDL_SetWindowRelativeMouseMode(g_window, false);\n  \n  printf(\"SDL window created successfully: %d x %d\\n\", display_w, display_h);\n\n  // Initialize SDL3 TTF\n  if (!TTF_Init()) {\n    printf(\"TTF_Init failed\\n\");\n    // Try to find fonts in common locations\n    const char* font_paths[] = {\n      \"/System/Library/Fonts/Arial.ttf\",\n      \"/System/Library/Fonts/Helvetica.ttc\",\n      \"/System/Library/Fonts/Times New Roman.ttf\",\n      \"/Library/Fonts/Arial.ttf\",\n      NULL\n    };\n    \n    for (int i = 0; font_paths[i]; i++) {\n      if (access(font_paths[i], R_OK) == 0) {\n        printf(\"Found font: %s\\n\", font_paths[i]);\n        break;\n      }\n    }\n  } else {\n    printf(\"TTF initialized successfully\\n\");\n  }\n\n  g_state = STATE_TITLE;\n  printf(\"Game state initialized to: %d\\n\", g_state);\n\n  // Initialize mouse state for UI\n  SDL_SetWindowRelativeMouseMode(g_window, true);\n  SDL_ShowCursor();\n  g_mouse_locked = 0;\n  \n  // Get actual window dimensions\n  SDL_GetWindowSize(g_window, &SCREEN_WIDTH, &SCREEN_HEIGHT);\n  TILE_SIZE = SCREEN_HEIGHT / 18.0f;\n\n  load_keybinds();\n  load_graphics_config();\n  init_tribes();\n  init_agents();\n  init_player();\n  // Temporarily disable ALL complex systems to test basic window\n  /*\n  if (!g_muze_loop_started) {\n    muze_loop_thread_start(&g_muze_loop);\n    g_muze_loop_started = 1;\n  }\n  */\n  // Re-enable MUZE system with fixed transformer\n  if (!g_muze_loop_started) {\n    muze_loop_thread_start(&g_muze_loop);\n    g_muze_loop_started = 1;\n  }\n  // Re-enable worker systems and grass worker\n  // Workers disabled to avoid threading issues - agents run in main thread\n  // Grass worker disabled temporarily to debug OpenGL texture issues\n  if (g_enable_grass) {\n    // start_grass_worker();\n  }\n  if (g_use_3d) {\n    g_state = STATE_TITLE;\n  }\n\n  // Defer graphics quality setup to avoid initialization conflicts\n  // Graphics quality will be set on first frame\n\n  for (int x = 0; x < WORLD_SIZE; x++) {\n    for (int y = 0; y < WORLD_SIZE; y++) {\n      pthread_rwlock_init(&world[x][y].lock, NULL);\n      world[x][y].generated = false;\n      world[x][y].resource_count = 0;\n      world[x][y].mob_spawn_timer = 0.0f;\n      world[x][y].grass = NULL;\n      world[x][y].grass_count = 0;\n      world[x][y].grass_capacity = 0;\n      world[x][y].grass_ready = 0;\n      world[x][y].grass_building = 0;\n    }\n  }\n\n  for (int i = 0; i < MAX_PROJECTILES; i++)\n    projectiles[i].alive = false;\n\n  while (!g_should_quit) {\n    // Handle SDL events\n    SDL_Event event;\n    while (SDL_PollEvent(&event)) {\n      if (event.type == SDL_EVENT_QUIT) {\n        g_should_quit = 1;\n        break;\n      }\n    }\n\n    if (g_should_quit) {\n      break;\n    }\n\n    // Update SDL input state\n    update_sdl_input_state();\n\n    // Calculate delta time\n    static Uint64 last_time = 0;\n    Uint64 current_time = SDL_GetPerformanceCounter();\n    if (last_time == 0) last_time = current_time;\n    \n    float dt = (float)(current_time - last_time) / (float)SDL_GetPerformanceFrequency();\n    last_time = current_time;\n\n    // Safety check to prevent infinite loops\n    if (dt <= 0.0f || dt > 1.0f) {\n      dt = 1.0f / 60.0f; // Default to 60 FPS\n    }\n\n    // Update screen dimensions continuously\n    SDL_GetWindowSize(g_window, &SCREEN_WIDTH, &SCREEN_HEIGHT);\n\n    // Test mouse button detection with proper Raylib constants\n    if (IsMouseButtonPressed(MOUSE_BUTTON_LEFT)) {\n      printf(\"LEFT MOUSE BUTTON PRESSED\\n\");\n    }\n    if (IsMouseButtonPressed(MOUSE_BUTTON_RIGHT)) {\n      printf(\"RIGHT MOUSE BUTTON PRESSED\\n\");\n    }\n\n    // Window close is handled by SDL event loop above\n\n    double frame_start_ms = prof_now_ms();\n\n    camera_pos.x += (player.position.x - camera_pos.x) * 0.1f;\n    camera_pos.y += (player.position.y - camera_pos.y) * 0.1f;\n\n    if (cam_shake > 0.0f) {\n      cam_shake -= dt;\n      float mag = cam_shake * 0.65f;\n      camera_pos.x += randf(-mag, mag);\n    }\n    WORLD_SCALE = lerp(WORLD_SCALE, target_world_scale, 0.12f);\n\n    double update_start_ms = prof_now_ms();\n    // Re-enable agent worker system with fixed transformer\n    // TEMPORARILY DISABLED TO DEBUG WORLD ENTRY STUCK ISSUE\n    // if (g_state == STATE_PLAYING) {\n    //   run_agent_jobs();\n    // }\n\n    // Simple agent update in main thread (no workers)\n    if (g_state == STATE_PLAYING) {\n      for (int i = 0; i < MAX_AGENTS; i++) {\n        if (agents[i].alive) {\n          update_agent(&agents[i]);\n        }\n      }\n    }\n    if (g_state == STATE_PLAYING) {\n      update_player();\n      update_visible_world(dt);\n      update_projectiles(dt);\n      update_daynight(dt);\n      update_ai_training(dt);      // Add AI training update\n      update_spectator_controls(); // Add spectator controls\n      collect_nearby_pickups();\n\n      g_dt = dt;\n\n      // detect transition night->day for reward\n      int now_night = is_night_cached;\n      if (was_night && !now_night) {\n        // dawn reward: shards + small base repair\n        inv_shards += 5;\n        for (int t = 0; t < TRIBE_COUNT; t++) {\n          tribes[t].integrity = fminf(100.0f, tribes[t].integrity + 15.0f);\n        }\n      }\n      was_night = now_night;\n\n      // raid spawner\n      if (is_night_cached) {\n        raid_timer -= dt;\n        if (raid_timer <= 0.0f) {\n          raid_timer = raid_interval;\n          spawn_raid_wave();\n        }\n      } else {\n        raid_timer = 1.5f;\n      }\n\n      for (int i = 0; i < MAX_AGENTS; i++) {\n        if (!agents[i].alive)\n          continue;\n        int acx = (int)(agents[i].position.x / CHUNK_SIZE);\n        int acy = (int)(agents[i].position.y / CHUNK_SIZE);\n        (void)get_chunk(acx, acy);\n      }\n\n      update_pickups(dt);\n    }\n\n    // Update spectator camera and render HUD\n    update_spectator_camera(dt);\n    render_spectator_hud();\n\n    double update_ms = prof_now_ms() - update_start_ms;\n\n    if (g_use_3d) {\n      // Use manual click detection for mouse locking\n      static int last_mouse_down = 0;\n      int current_mouse_down = IsMouseButtonDown(MOUSE_LEFT_BUTTON);\n      int mouse_clicked = current_mouse_down && !last_mouse_down;\n      last_mouse_down = current_mouse_down;\n\n      // Only lock mouse when playing AND user clicks (not immediately on\n      // entry)\n      if (g_state == STATE_PLAYING && !g_mouse_locked && mouse_clicked) {\n        // Try without relative mode first\n        SDL_HideCursor();\n        int mw, mh;\n        SDL_GetWindowSize(g_window, &mw, &mh);\n        if (mw > 0 && mh > 0) {\n          SDL_WarpMouseInWindow(g_window, mw / 2, mh / 2);\n        }\n        g_mouse_locked = 1;\n      } else if ((g_state != STATE_PLAYING) && g_mouse_locked) {\n        SDL_ShowCursor();\n        g_mouse_locked = 0;\n      }\n\n      // Allow manual unlock with TAB key\n      if (g_state == STATE_PLAYING && g_mouse_locked && IsKeyPressed(KEY_TAB)) {\n        SDL_ShowCursor();\n        g_mouse_locked = 0;\n      }\n\n      // Ensure mouse is always visible and not in relative mode for UI\n      // screens\n      if (g_state == STATE_TITLE || g_state == STATE_WORLD_SELECT ||\n          g_state == STATE_WORLD_CREATE || g_state == STATE_PAUSED) {\n        SDL_ShowCursor();\n        SDL_SetWindowMouseGrab(g_window, false);\n        SDL_SetWindowRelativeMouseMode(g_window, false);\n        g_mouse_locked = 0;\n      }\n    }\n\n    // ...\n    if (g_use_3d && IsKeyPressed(KEY_V)) {\n      g_camera_mode = (g_camera_mode == CAM_THIRD_PERSON) ? CAM_FIRST_PERSON\n                                                          : CAM_THIRD_PERSON;\n    }\n    if (g_use_3d && g_state == STATE_PLAYING && IsKeyPressed(KEY_M)) {\n      g_minimap_zoomed = !g_minimap_zoomed;\n    }\n    if (g_use_3d && IsKeyPressed(KEY_F6)) {\n      GraphicsQuality next = GFX_LOW;\n      if (g_gfx_quality == GFX_LOW)\n        next = GFX_MED;\n      else if (g_gfx_quality == GFX_MED)\n        next = GFX_HIGH;\n      else\n        next = GFX_LOW;\n      apply_graphics_quality(next);\n      save_graphics_config();\n    }\n    if (g_use_3d && IsKeyPressed(KEY_F7)) {\n      g_profiler_enabled = !g_profiler_enabled;\n    }\n\n    if (IsKeyPressed(KEY_ESCAPE)) {\n      if (g_state == STATE_PLAYING) {\n        g_state = STATE_PAUSED;\n        g_pause_page = 0;\n        // Unlock mouse when paused\n        SDL_ShowCursor();\n        g_mouse_locked = 0;\n      } else if (g_state == STATE_PAUSED) {\n        g_state = STATE_PLAYING;\n      }\n    }\n    \n    if (IsKeyPressed(KEY_P)) {\n      if (g_state == STATE_PAUSED) {\n        g_state = STATE_PLAYING;\n      }\n    }\n    \n    // Debug: Press G to jump directly to game world\n    if (IsKeyDown(KEY_G)) {\n      printf(\"G key down - Jumping to game world for testing\\n\");\n      g_state = STATE_PLAYING;\n      // Initialize a basic world\n      printf(\"About to call world_reset(12345)\\n\");\n      world_reset(12345);\n      printf(\"world_reset completed\\n\");\n      printf(\"About to call save_world_to_disk(\\\"test_world\\\")\\n\");\n      save_world_to_disk(\"test_world\");\n      printf(\"save_world_to_disk completed\\n\");\n    }\n    \n    // Debug: Test if any key is being detected\n    if (IsKeyPressed(KEY_SPACE)) {\n      printf(\"SPACE key pressed - Testing input detection\\n\");\n    }\n    \n    // Debug: Test if G key is being held down\n    if (IsKeyDown(KEY_G)) {\n      printf(\"G key is down\\n\");\n    }\n\n    // SDL render loop\n    // Clear screen\n    glClearColor(135.0f/255.0f, 206.0f/255.0f, 235.0f/255.0f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    \n    if (g_use_3d) {\n      g_prof_draw_calls = 0;\n      g_prof_triangles = 0;\n      double render_start_ms = prof_now_ms();\n      if (g_state == STATE_PLAYING || g_state == STATE_PAUSED) {\n        // Set viewport to full window\n        glViewport(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);\n        \n        printf(\"Rendering 3D scene - State: %d\\n\", g_state);\n        printf(\"About to call render_scene_3d()\\n\");\n        render_scene_3d();\n        printf(\"3D scene rendered successfully\\n\");\n      } else {\n        printf(\"Not rendering 3D scene - State: %d\\n\", g_state);\n      }\n      double render_ms = prof_now_ms() - render_start_ms;\n\n      double ui_start_ms = prof_now_ms();\n      if (g_state == STATE_PLAYING || g_state == STATE_PAUSED) {\n        glUseProgram(0); // Disable 3D shader before 2D drawing\n\n        printf(\"Re-enabling UI drawing system\\n\");\n        printf(\"Drawing UI elements\\n\");\n        printf(\"About to call draw_ui_3d_full()\\n\");\n        draw_ui_3d_full();\n        printf(\"draw_ui_3d_full completed\\n\");\n        \n        printf(\"About to call draw_minimap_3d()\\n\");\n        draw_minimap_3d();\n        printf(\"draw_minimap_3d completed\\n\");\n        \n        printf(\"About to call draw_daynight_overlay_3d()\\n\");\n        draw_daynight_overlay_3d();\n        printf(\"draw_daynight_overlay_3d completed\\n\");\n        \n        printf(\"About to call draw_hurt_vignette_3d()\\n\");\n        draw_hurt_vignette_3d();\n        printf(\"draw_hurt_vignette_3d completed\\n\");\n        \n        printf(\"About to call draw_crafting_ui_3d()\\n\");\n        draw_crafting_ui_3d();\n        printf(\"draw_crafting_ui_3d completed\\n\");\n        \n        printf(\"About to call draw_hover_label_3d()\\n\");\n        draw_hover_label_3d();\n        printf(\"draw_hover_label_3d completed\\n\");\n        \n        if (g_state == STATE_PLAYING) {\n          printf(\"About to call draw_crosshair_3d()\\n\");\n          draw_crosshair_3d();\n          printf(\"draw_crosshair_3d completed\\n\");\n        }\n      }\n\n      if (g_state == STATE_PAUSED) {\n        if (g_pause_page == 0)\n          draw_pause_menu_3d();\n        else if (g_pause_page == 3)\n          draw_graphics_menu_3d();\n        else if (g_pause_page == 4)\n          draw_ai_training_menu_3d();\n        else\n          draw_keybinds_menu_3d();\n      } else if (g_state == STATE_WORLD_SELECT) {\n        printf(\"Drawing world select screen\\n\");\n        draw_world_select_3d();\n      } else if (g_state == STATE_WORLD_CREATE) {\n    } else {\n      // 2D rendering path (when g_use_3d = 0)\n      if (g_state == STATE_TITLE) {\n        // Simple SDL/OpenGL 2D title screen\n        int w = 1440, h = 900;\n        glViewport(0, 0, w, h);\n        glClearColor(0.07f, 0.07f, 0.11f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        \n        // Handle mouse clicks for buttons (same logic as 3D version)\n        if (IsMouseButtonPressed_SDL(1)) { // Left click\n          float mouse_x = g_mouse_x;\n          float mouse_y = g_mouse_y;\n          \n          // Check start button area\n          if (mouse_x >= 60 && mouse_x <= 320 && mouse_y >= 160 && mouse_y <= 210) {\n            g_state = STATE_WORLD_SELECT;\n            printf(\"Start button clicked - going to world select\\n\");\n          }\n          \n          // Check create world button area\n          if (mouse_x >= 60 && mouse_x <= 320 && mouse_y >= 220 && mouse_y <= 270) {\n            g_state = STATE_WORLD_CREATE;\n            printf(\"Create World button clicked\\n\");\n          }\n          \n          // Check quit button area\n          if (mouse_x >= 60 && mouse_x <= 320 && mouse_y >= 280 && mouse_y <= 330) {\n            g_should_quit = 1;\n            printf(\"Quit button clicked - exiting\\n\");\n          }\n        }\n      }\n    }\n  } else if (g_state == STATE_WORLD_CREATE) {\n      // Get screen dimensions for scaling\n      int w, h;\n      SDL_GetWindowSize(g_window, &w, &h);\n\n      DrawText(\"Create World\", 60, 50, 34, RAYWHITE);\n\n      DrawText(\"World Name\", 60, 120, 18, RAYWHITE);\n      ui_textbox((Rectangle){60, 145, 360, 45}, g_world_name,\n                 sizeof(g_world_name), &g_typing_name, 0);\n\n      DrawText(\"Seed\", 60, 205, 18, RAYWHITE);\n      // Scale UI elements based on screen resolution\n      float ui_scale_x = w / 1280.0f; // Reference width\n      float ui_scale_y = h / 800.0f;  // Reference height\n\n      ui_textbox((Rectangle){60 * ui_scale_x, 230 * ui_scale_y,\n                             200 * ui_scale_x, 45 * ui_scale_y},\n                 g_seed_text, sizeof(g_seed_text), &g_typing_seed, 1);\n\n      float button_width = 200 * ui_scale_x;\n      float button_height = 50 * ui_scale_y;\n      float button_y = 300 * ui_scale_y;\n\n      if (ui_button((Rectangle){60 * ui_scale_x, button_y, button_width,\n                                button_height},\n                    \"Create & Play\")) {\n        g_world_seed = (uint32_t)strtoul(g_seed_text, NULL, 10);\n        world_reset(g_world_seed);\n        save_world_to_disk(g_world_name); // create initial save\n        g_state = STATE_PLAYING;\n        ensure_agents_ready_on_enter();\n      }\n\n      if (ui_button((Rectangle){280 * ui_scale_x, button_y, 140 * ui_scale_x,\n                                button_height},\n                    \"Back\")) {\n        g_state = STATE_TITLE;\n      }\n    } else if (g_state == STATE_WORLD_SELECT) {\n      // Get screen dimensions for scaling\n      int w, h;\n      SDL_GetWindowSize(g_window, &w, &h);\n\n      // Scale UI elements based on screen resolution\n      float ui_scale_x = w / 1280.0f; // Reference width\n      float ui_scale_y = h / 800.0f;  // Reference height\n\n      DrawRectangle(0, 0, w, h, (Color){18, 18, 28, 255});\n      DrawText(\"Select World\", (int)(40 * ui_scale_x), (int)(30 * ui_scale_y),\n               (int)(44 * ui_scale_y), RAYWHITE);\n\n      Rectangle listBox = {(float)(40 * ui_scale_x), (float)(100 * ui_scale_y),"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_circle_filled_opengl","file":"game_impl.c","line_start":10,"line_end":20,"snippet":"void draw_circle_filled_opengl(float centerX, float centerY, float radius, Color color) {\n    glBegin(GL_TRIANGLE_FAN);\n    glColor4f(color.r/255.0f, color.g/255.0f, color.b/255.0f, color.a/255.0f);\n    glVertex2f(centerX, centerY);\n    int segments = 32;\n    for (int i = 0; i <= segments; i++) {\n        float angle = 2.0f * PI * (float)i / (float)segments;\n        glVertex2f(centerX + cosf(angle) * radius, centerY + sinf(angle) * radius);\n    }\n    glEnd();\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_circle_outline_opengl","file":"game_impl.c","line_start":22,"line_end":31,"snippet":"void draw_circle_outline_opengl(float centerX, float centerY, float radius, Color color) {\n    glBegin(GL_LINE_LOOP);\n    glColor4f(color.r/255.0f, color.g/255.0f, color.b/255.0f, color.a/255.0f);\n    int segments = 32;\n    for (int i = 0; i <= segments; i++) {\n        float angle = 2.0f * PI * (float)i / (float)segments;\n        glVertex2f(centerX + cosf(angle) * radius, centerY + sinf(angle) * radius);\n    }\n    glEnd();\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_triangle_opengl","file":"game_impl.c","line_start":33,"line_end":40,"snippet":"void draw_triangle_opengl(Vector2 v1, Vector2 v2, Vector2 v3, Color color) {\n    glBegin(GL_TRIANGLES);\n    glColor4f(color.r/255.0f, color.g/255.0f, color.b/255.0f, color.a/255.0f);\n    glVertex2f(v1.x, v1.y);\n    glVertex2f(v2.x, v2.y);\n    glVertex2f(v3.x, v3.y);\n    glEnd();\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_line_opengl","file":"game_impl.c","line_start":42,"line_end":50,"snippet":"void draw_line_opengl(float x1, float y1, float x2, float y2, float thickness, Color color) {\n    glLineWidth(thickness);\n    glBegin(GL_LINES);\n    glColor4f(color.r/255.0f, color.g/255.0f, color.b/255.0f, color.a/255.0f);\n    glVertex2f(x1, y1);\n    glVertex2f(x2, y2);\n    glEnd();\n    glLineWidth(1.0f); // Reset to default\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_ellipse_filled_opengl","file":"game_impl.c","line_start":52,"line_end":62,"snippet":"void draw_ellipse_filled_opengl(int centerX, int centerY, int radiusX, int radiusY, Color color) {\n    glBegin(GL_TRIANGLE_FAN);\n    glColor4f(color.r/255.0f, color.g/255.0f, color.b/255.0f, color.a/255.0f);\n    glVertex2f(centerX, centerY);\n    int segments = 32;\n    for (int i = 0; i <= segments; i++) {\n        float angle = 2.0f * PI * (float)i / (float)segments;\n        glVertex2f(centerX + cosf(angle) * radiusX, centerY + sinf(angle) * radiusY);\n    }\n    glEnd();\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_polygon_filled_opengl","file":"game_impl.c","line_start":64,"line_end":73,"snippet":"void draw_polygon_filled_opengl(Vector2 center, int sides, float radius, float rotation, Color color) {\n    glBegin(GL_TRIANGLE_FAN);\n    glColor4f(color.r/255.0f, color.g/255.0f, color.b/255.0f, color.a/255.0f);\n    glVertex2f(center.x, center.y);\n    for (int i = 0; i <= sides; i++) {\n        float angle = rotation + 2.0f * PI * (float)i / (float)sides;\n        glVertex2f(center.x + cosf(angle) * radius, center.y + sinf(angle) * radius);\n    }\n    glEnd();\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_polygon_outline_opengl","file":"game_impl.c","line_start":75,"line_end":83,"snippet":"void draw_polygon_outline_opengl(Vector2 center, int sides, float radius, float rotation, Color color) {\n    glBegin(GL_LINE_LOOP);\n    glColor4f(color.r/255.0f, color.g/255.0f, color.b/255.0f, color.a/255.0f);\n    for (int i = 0; i <= sides; i++) {\n        float angle = rotation + 2.0f * PI * (float)i / (float)sides;\n        glVertex2f(center.x + cosf(angle) * radius, center.y + sinf(angle) * radius);\n    }\n    glEnd();\n}"},
  {"kind":"fn_def","vis":"PRIVATE","name":"draw_rectangle_outline_opengl","file":"game_impl.c","line_start":85,"line_end":93,"snippet":"void draw_rectangle_outline_opengl(int x, int y, int width, int height, Color color) {\n    glBegin(GL_LINE_LOOP);\n    glColor4f(color.r/255.0f, color.g/255.0f, color.b/255.0f, color.a/255.0f);\n    glVertex2f(x, y);\n    glVertex2f(x + width, y);\n    glVertex2f(x + width, y + height);\n    glVertex2f(x, y + height);\n    glEnd();\n}"}
]
